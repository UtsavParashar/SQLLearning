3.2 Entering Queries
Make sure that you are connected to the server, as discussed in the previous section. Doing so does not in itself select any database to work with, but that is okay. At this point, it is more important to find out a little about how to issue queries than to jump right in creating tables, loading data into them, and retrieving data from them. This section describes the basic principles of entering queries, using several queries you can try out to familiarize yourself with how mysql works.

Here is a simple query that asks the server to tell you its version number and the current date. Type it in as shown here following the mysql> prompt and press Enter:
SELECT VERSION(), CURRENT_DATE;

This query illustrates several things about mysql:

A query normally consists of an SQL statement followed by a semicolon. (There are some exceptions where a semicolon may be omitted. QUIT, mentioned earlier, is one of them. We'll get to others later.)

When you issue a query, mysql sends it to the server for execution and displays the results, then prints another mysql> prompt to indicate that it is ready for another query.

mysql displays query output in tabular form (rows and columns). The first row contains labels for the columns. The rows following are the query results. Normally, column labels are the names of the columns you fetch from database tables. If you're retrieving the value of an expression rather than a table column (as in the example just shown), mysql labels the column using the expression itself.

mysql shows how many rows were returned and how long the query took to execute, which gives you a rough idea of server performance. These values are imprecise because they represent wall clock time (not CPU or machine time), and because they are affected by factors such as server load and network latency. (For brevity, the “rows in set” line is sometimes not shown in the remaining examples in this chapter.)

Keywords may be entered in any lettercase. The following queries are equivalent:

mysql> SELECT VERSION(), CURRENT_DATE;
mysql> select version(), current_date;
mysql> SeLeCt vErSiOn(), current_DATE;

Here is another query. It demonstrates that you can use mysql as a simple calculator:
SELECT SIN(PI()/4), 4+1*5;

The queries shown thus far have been relatively short, single-line statements. You can even enter multiple statements on a single line. Just end each one with a semicolon:
SELECT VERSION(); SELECT NOW();

A query need not be given all on a single line, so lengthy queries that require several lines are not a problem. mysql determines where your statement ends by looking for the terminating semicolon, not by looking for the end of the input line. (In other words, mysql accepts free-format input: it collects input lines but does not execute them until it sees the semicolon.)

Here is a simple multiple-line statement:
SELECT user()
,
current_time(),
current_time,
current_timestamp,
current_timestamp(),
current_date,
current_date(),
current_user(),
curtime(),
curdate()
curtime;

In this example, notice how the prompt changes from mysql> to -> after you enter the first line of a multiple-line query. This is how mysql indicates that it has not yet seen a complete statement and is waiting for the rest. The prompt is your friend, because it provides valuable feedback. If you use that feedback, you can always be aware of what mysql is waiting for.

If you decide you do not want to execute a query that you are in the process of entering, cancel it by typing \c:

Here, too, notice the prompt. It switches back to mysql> after you type \c, providing feedback to indicate that mysql is ready for a new query.

The following table shows each of the prompts you may see and summarizes what they mean about the state that mysql is in.

Prompt	Meaning
mysql>	Ready for new query
->	    Waiting for next line of multiple-line query
'>	    Waiting for next line, waiting for completion of a string that began with a single quote (')
">	    Waiting for next line, waiting for completion of a string that began with a double quote (")
`>	    Waiting for next line, waiting for completion of an identifier that began with a backtick (`)
/*>	    Waiting for next line, waiting for completion of a comment that began with /*

Multiple-line statements commonly occur by accident when you intend to issue a query on a single line, but forget the terminating semicolon. In this case, mysql waits for more input:


mysql> SELECT USER()
    ->

If this happens to you (you think you've entered a statement but the only response is a -> prompt), most likely mysql is waiting for the semicolon. If you don't notice what the prompt is telling you, you might sit there for a while before realizing what you need to do. Enter a semicolon to complete the statement, and mysql executes it:

mysql> SELECT USER()
    -> ;

The '> and "> prompts occur during string collection (another way of saying that MySQL is waiting for completion of a string). In MySQL, you can write strings surrounded by either ' or " characters (for example, 'hello' or "goodbye"), and mysql lets you enter strings that span multiple lines. When you see a '> or "> prompt, it means that you have entered a line containing a string that begins with a ' or " quote character, but have not yet entered the matching quote that terminates the string. This often indicates that you have inadvertently left out a quote character. For example:


mysql> SELECT * FROM my_table WHERE name = 'Smith AND age < 30;
    '>

If you enter this SELECT statement, then press Enter and wait for the result, nothing happens. Instead of wondering why this query takes so long, notice the clue provided by the '> prompt. It tells you that mysql expects to see the rest of an unterminated string. (Do you see the error in the statement? The string 'Smith is missing the second single quotation mark.)

At this point, what do you do? The simplest thing is to cancel the query. However, you cannot just type \c in this case, because mysql interprets it as part of the string that it is collecting. Instead, enter the closing quote character (so mysql knows you've finished the string), then type \c:

mysql> SELECT * FROM my_table WHERE name = 'Smith AND age < 30;
    '> '\c
mysql>
The prompt changes back to mysql>, indicating that mysql is ready for a new query.

The `> prompt is similar to the '> and "> prompts, but indicates that you have begun but not completed a backtick-quoted identifier.

It is important to know what the '>, ">, and `> prompts signify, because if you mistakenly enter an unterminated string, any further lines you type appear to be ignored by mysql—including a line containing QUIT. This can be quite confusing, especially if you do not know that you need to supply the terminating quote before you can cancel the current query.

Note
Multiline statements from this point on are written without the secondary (-> or other) prompts, to make it easier to copy and paste the statements to try for yourself.

3.3 Creating and Using a Database
---------------------------------
Once you know how to enter SQL statements, you are ready to access a database.

Suppose that you have several pets in your home (your menagerie) and you would like to keep track of various types of information about them. You can do so by creating tables to hold your data and loading them with the desired information. Then you can answer different sorts of questions about your animals by retrieving data from the tables. This section shows you how to perform the following operations:

Create a database

Create a table

Load data into the table

Retrieve data from the table in various ways

Use multiple tables

The menagerie database is simple (deliberately), but it is not difficult to think of real-world situations in which a similar type of database might be used. For example, a database like this could be used by a farmer to keep track of livestock, or by a veterinarian to keep track of patient records. A menagerie distribution containing some of the queries and sample data used in the following sections can be obtained from the MySQL website. It is available in both compressed tar file and Zip formats at https://dev.mysql.com/doc/.

Use the SHOW statement to find out what databases currently exist on the server:

show DATABASES;
# Database
'information_schema'
'mysql'
'performance_schema'
'sys'
'test'

To get list of all tables in a particular database/table_schema use:
SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA='TEST'; # For test DB
SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA='INFORMATION_SCHEMA'; # for information_schema db

To get list of all tables:
SELECT * FROM INFORMATION_SCHEMA.TABLES;

The mysql database describes user access privileges. The test database often is available as a workspace for users to try things out.

The list of databases displayed by the statement may be different on your machine; SHOW DATABASES does not show databases that you have no privileges for if you do not have the SHOW DATABASES privilege. See Section 13.7.7.14, “SHOW DATABASES Statement”.

If the test database exists, try to access it:

The mysql database describes user access privileges. The test database often is available as a workspace for users to try things out.

The list of databases displayed by the statement may be different on your machine; SHOW DATABASES does not show databases that you have no privileges for if you do not have the SHOW DATABASES privilege. See Section 13.7.7.14, “SHOW DATABASES Statement”.

If the test database exists, try to access it:

mysql> GRANT ALL ON menagerie.* TO 'your_mysql_name'@'your_client_host';
where your_mysql_name is the MySQL user name assigned to you and your_client_host is the host from which you connect to the server.


3.3.1 Creating and Selecting a Database

If the administrator creates your database for you when setting up your permissions, you can begin using it. Otherwise, you need to create it yourself:

CREATE DATABASE menagerie;

Under Unix, database names are case-sensitive (unlike SQL keywords), so you must always refer to your database as menagerie, not as Menagerie, MENAGERIE, or some other variant. This is also true for table names. (Under Windows, this restriction does not apply, although you must refer to databases and tables using the same lettercase throughout a given query. However, for a variety of reasons, the recommended best practice is always to use the same lettercase that was used when the database was created.)

Note
If you get an error such as ERROR 1044 (42000): Access denied for user 'micah'@'localhost' to database 'menagerie' when attempting to create a database, this means that your user account does not have the necessary privileges to do so.

Creating a database does not select it for use; you must do that explicitly. To make menagerie the current database, use this statement:

mysql> USE menagerie
Database changed

Your database needs to be created only once, but you must select it for use each time you begin a mysql session. You can do this by issuing a USE statement as shown in the example. Alternatively, you can select the database on the command line when you invoke mysql. Just specify its name after any connection parameters that you might need to provide. For example:

shell> mysql -h host -u user -p menagerie
Enter password: ********
Important
menagerie in the command just shown is not your password. If you want to supply your password on the command line after the -p option, you must do so with no intervening space (for example, as -ppassword, not as -p password). However, putting your password on the command line is not recommended, because doing so exposes it to snooping by other users logged in on your machine.

Note
You can see at any time which database is currently selected using SELECT DATABASE().
SELECT DATABASE(); # 'menagerie'

3.3.2 Creating a Table
----------------------
Creating the database is the easy part, but at this point it is empty, as SHOW TABLES tells you:

mysql> SHOW TABLES;
Empty set (0.00 sec)

SHOW TABLES;

The harder part is deciding what the structure of your database should be: what tables you need and what columns should be in each of them.

You want a table that contains a record for each of your pets. This can be called the pet table, and it should contain, as a bare minimum, each animal's name. Because the name by itself is not very interesting, the table should contain other information. For example, if more than one person in your family keeps pets, you might want to list each animal's owner. You might also want to record some basic descriptive information such as species and sex.

How about age? That might be of interest, but it is not a good thing to store in a database. Age changes as time passes, which means you'd have to update your records often. Instead, it is better to store a fixed value such as date of birth. Then, whenever you need age, you can calculate it as the difference between the current date and the birth date. MySQL provides functions for doing date arithmetic, so this is not difficult. Storing birth date rather than age has other advantages, too:

You can use the database for tasks such as generating reminders for upcoming pet birthdays. (If you think this type of query is somewhat silly, note that it is the same question you might ask in the context of a business database to identify clients to whom you need to send out birthday greetings in the current week or month, for that computer-assisted personal touch.)

You can calculate age in relation to dates other than the current date. For example, if you store death date in the database, you can easily calculate how old a pet was when it died.

You can probably think of other types of information that would be useful in the pet table, but the ones identified so far are sufficient: name, owner, species, sex, birth, and death.

Use a CREATE TABLE statement to specify the layout of your table:

CREATE TABLE pet (
    name VARCHAR(20),
    owner VARCHAR(20),
    species VARCHAR(20),
    sex ENUM('M', 'F'),
    birth DATE,
    death DATE
);

VARCHAR is a good choice for the name, owner, and species columns because the column values vary in length. The lengths in those column definitions need not all be the same, and need not be 20. You can normally pick any length from 1 to 65535, whatever seems most reasonable to you. If you make a poor choice and it turns out later that you need a longer field, MySQL provides an ALTER TABLE statement.

Several types of values can be chosen to represent sex in animal records, such as 'm' and 'f', or perhaps 'male' and 'female'. It is simplest to use the single characters 'm' and 'f'.

The use of the DATE data type for the birth and death columns is a fairly obvious choice.

Once you have created a table, SHOW TABLES should produce some output:

mysql> SHOW TABLES;
+---------------------+
| Tables in menagerie |
+---------------------+
| pet                 |
+---------------------+
To verify that your table was created the way you expected, use a DESCRIBE statement:

DESCRIBE pet;
# Field, Type, Null, Key, Default, Extra
'name', 'varchar(20)', 'YES', '', NULL, ''
'owner', 'varchar(20)', 'YES', '', NULL, ''
'species', 'varchar(20)', 'YES', '', NULL, ''
'sex', 'enum(\'M\',\'F\')', 'YES', '', NULL, ''
'birth', 'date', 'YES', '', NULL, ''
'death', 'date', 'YES', '', NULL, ''

3.3.3 Loading Data into a Table
After creating your table, you need to populate it. The LOAD DATA and INSERT statements are useful for this.

Suppose that your pet records can be described as shown here. (Observe that MySQL expects dates in 'YYYY-MM-DD' format; this may differ from what you are used to.)

Because you are beginning with an empty table, an easy way to populate it is to create a text file containing a row for each of your animals, then load the contents of the file into the table with a single statement.

You could create a text file pet.txt containing one record per line, with values separated by tabs, and given in the order in which the columns were listed in the CREATE TABLE statement. For missing values (such as unknown sexes or death dates for animals that are still living), you can use NULL values. To represent these in your text file, use \N (backslash, capital-N). For example, the record for Whistler the bird would look like this (where the whitespace between values is a single tab character):

To load a file:
start the mysql server as - (base) Utsavs-MacBook-Air:LaunchDaemons utsav$ mysql -u root -p --local-infile menagerie
mysql> SET GLOBAL local_infile = 1;
mysql> LOAD DATA LOCAL INFILE '/Users/utsav/Desktop/repos/SQLLearning/te.txt' INTO TABLE pet;

If you created the file on Windows with an editor that uses \r\n as a line terminator, you should use this statement instead:

mysql> LOAD DATA LOCAL INFILE '/path/pet.txt' INTO TABLE pet
       LINES TERMINATED BY '\r\n';

(On an Apple machine running macOS, you would likely want to use LINES TERMINATED BY '\r'.)

You can specify the column value separator and end of line marker explicitly in the LOAD DATA statement if you wish, but the defaults are tab and linefeed. These are sufficient for the statement to read the file pet.txt properly.

If the statement fails, it is likely that your MySQL installation does not have local file capability enabled by default. See Section 6.1.6, “Security Considerations for LOAD DATA LOCAL”(https://dev.mysql.com/doc/refman/8.0/en/load-data-local-security.html), for information on how to change this.

When you want to add new records one at a time, the INSERT statement is useful. In its simplest form, you supply values for each column, in the order in which the columns were listed in the CREATE TABLE statement. Suppose that Diane gets a new hamster named “Puffball.” You could add a new record using an INSERT statement like this:

String and date values are specified as quoted strings here. Also, with INSERT, you can insert NULL directly to represent a missing value. You do not use \N like you do with LOAD DATA.

From this example, you should be able to see that there would be a lot more typing involved to load your records initially using several INSERT statements rather than a single LOAD DATA statement.

Load a csv file -
SET GLOBAL local_infile = 1;
mysql> LOAD DATA LOCAL INFILE '/Users/utsav/Desktop/repos/SQLLearning/te.csv' INTO TABLE test_csv_load fields terminated by ',';
Query OK, 8 rows affected (0.01 sec)
Records: 8  Deleted: 0  Skipped: 0  Warnings: 0

mysql> select * from test_csv_load;
+----------+--------+---------+------+------------+------------+
| name     | owner  | species | sex  | birth      | death      |
+----------+--------+---------+------+------------+------------+
| Fluffy   | Harold | cat     | F    | 1993-02-04 | NULL       |
| Claws    | Gwen   | cat     | M    | 1994-03-17 | NULL       |
| Buffy    | Harold | dog     | F    | 1989-05-13 | NULL       |
| Fang     | Benny  | dog     | M    | 1990-08-27 | NULL       |
| Bowser   | Diane  | dog     | M    | 1979-08-31 | 1995-07-29 |
| Chirpy   | Gwen   | bird    | F    | 1998-09-11 | NULL       |
| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |
| Slim     | Benny  | snake   | M    | 1996-04-29 | NULL       |
+----------+--------+---------+------+------------+------------+
8 rows in set (0.00 sec)

3.3.4 Retrieving Information from a Table
------------------------------------------
The SELECT statement is used to pull information from a table. The general form of the statement is:

SELECT what_to_select
FROM which_table
WHERE conditions_to_satisfy;
what_to_select indicates what you want to see. This can be a list of columns, or * to indicate “all columns.” which_table indicates the table from which you want to retrieve data. The WHERE clause is optional. If it is present, conditions_to_satisfy specifies one or more conditions that rows must satisfy to qualify for retrieval.

3.3.4.1 Selecting All Data

The simplest form of SELECT retrieves everything from a table:
SELECT * FROM pet;

This form of SELECT uses *, which is shorthand for “select all columns.” This is useful if you want to review your entire table, for example, after you've just loaded it with your initial data set. For example, you may happen to think that the birth date for Bowser doesn't seem quite right. Consulting your original pedigree papers, you find that the correct birth year should be 1989, not 1979.

There are at least two ways to fix this:

Edit the file pet.txt to correct the error, then empty the table and reload it using DELETE and LOAD DATA:

mysql> select * from pet;                                                                                            +----------+--------+---------+------+------------+------------+
| name     | owner  | species | sex  | birth      | death      |
+----------+--------+---------+------+------------+------------+
| Fluffy   | Harold | cat     | F    | 1993-02-04 | NULL       |
| Claws    | Gwen   | cat     | M    | 1994-03-17 | NULL       |
| Buffy    | Harold | dog     | F    | 1989-05-13 | NULL       |
| Fang     | Benny  | dog     | M    | 1990-08-27 | NULL       |
| Bowser   | Diane  | dog     | M    | 1989-08-31 | 1995-07-29 |
| Chirpy   | Gwen   | bird    | F    | 1998-09-11 | NULL       |
| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |
| Slim     | Benny  | snake   | M    | 1996-04-29 | NULL       |
+----------+--------+---------+------+------------+------------+

mysql> DELETE FROM pet;
mysql> LOAD DATA LOCAL INFILE 'pet.txt' INTO TABLE pet;
However, if you do this, you must also re-enter the record for Puffball.

Fix only the erroneous record with an UPDATE statement:

mysql> UPDATE pet SET birth = '1989-08-31' WHERE name = 'Bowser';
The UPDATE changes only the record in question and does not require you to reload the table.

There is an exception to the principle that SELECT * selects all columns. If a table contains invisible columns, * does not include them. For more information, see Section 13.1.20.10, “Invisible Columns”.

3.3.4.2 Selecting Particular Rows

As shown in the preceding section, it is easy to retrieve an entire table. Just omit the WHERE clause from the SELECT statement. But typically you don't want to see the entire table, particularly when it becomes large. Instead, you're usually more interested in answering a particular question, in which case you specify some constraints on the information you want. Let's look at some selection queries in terms of questions about your pets that they answer.

You can select only particular rows from your table. For example, if you want to verify the change that you made to Bowser's birth date, select Bowser's record like this:

mysql> SELECT * FROM pet WHERE name = 'Bowser';
+--------+-------+---------+------+------------+------------+
| name   | owner | species | sex  | birth      | death      |
+--------+-------+---------+------+------------+------------+
| Bowser | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+-------+---------+------+------------+------------+
The output confirms that the year is correctly recorded as 1989, not 1979.

String comparisons normally are case-insensitive, so you can specify the name as 'bowser', 'BOWSER', and so forth. The query result is the same.

You can specify conditions on any column, not just name. For example, if you want to know which animals were born during or after 1998, test the birth column:

mysql> SELECT * FROM pet WHERE birth >= '1998-1-1';
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Puffball | Diane | hamster | f    | 1999-03-30 | NULL  |
+----------+-------+---------+------+------------+-------+
You can combine conditions, for example, to locate female dogs:

mysql> SELECT * FROM pet WHERE species = 'dog' AND sex = 'f';
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
The preceding query uses the AND logical operator. There is also an OR operator:

mysql> SELECT * FROM pet WHERE species = 'snake' OR species = 'bird';
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL  |
| Slim     | Benny | snake   | m    | 1996-04-29 | NULL  |
+----------+-------+---------+------+------------+-------+
AND and OR may be intermixed, although AND has higher precedence than OR. If you use both operators, it is a good idea to use parentheses to indicate explicitly how conditions should be grouped:

mysql> SELECT * FROM pet WHERE (species = 'cat' AND sex = 'm')
       OR (species = 'dog' AND sex = 'f');
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+

3.3.4.3 Selecting Particular Columns
------------------------------------
If you do not want to see entire rows from your table, just name the columns in which you are interested, separated by commas. For example, if you want to know when your animals were born, select the name and birth columns:

mysql> SELECT name, birth FROM pet;
+----------+------------+
| name     | birth      |
+----------+------------+
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Buffy    | 1989-05-13 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Puffball | 1999-03-30 |
+----------+------------+
To find out who owns pets, use this query:

mysql> SELECT owner FROM pet;
+--------+
| owner  |
+--------+
| Harold |
| Gwen   |
| Harold |
| Benny  |
| Diane  |
| Gwen   |
| Gwen   |
| Benny  |
| Diane  |
+--------+
Notice that the query simply retrieves the owner column from each record, and some of them appear more than once. To minimize the output, retrieve each unique output record just once by adding the keyword DISTINCT:

mysql> SELECT DISTINCT owner FROM pet;
+--------+
| owner  |
+--------+
| Benny  |
| Diane  |
| Gwen   |
| Harold |
+--------+
You can use a WHERE clause to combine row selection with column selection. For example, to get birth dates for dogs and cats only, use this query:

mysql> SELECT name, species, birth FROM pet
       WHERE species = 'dog' OR species = 'cat';
+--------+---------+------------+
| name   | species | birth      |
+--------+---------+------------+
| Fluffy | cat     | 1993-02-04 |
| Claws  | cat     | 1994-03-17 |
| Buffy  | dog     | 1989-05-13 |
| Fang   | dog     | 1990-08-27 |
| Bowser | dog     | 1989-08-31 |
+--------+---------+------------+

3.3.4.4 Sorting Rows

You may have noticed in the preceding examples that the result rows are displayed in no particular order. It is often easier to examine query output when the rows are sorted in some meaningful way. To sort a result, use an ORDER BY clause.

Here are animal birthdays, sorted by date:

mysql> SELECT name, birth FROM pet ORDER BY birth;
+----------+------------+
| name     | birth      |
+----------+------------+
| Buffy    | 1989-05-13 |
| Bowser   | 1989-08-31 |
| Fang     | 1990-08-27 |
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Slim     | 1996-04-29 |
| Whistler | 1997-12-09 |
| Chirpy   | 1998-09-11 |
| Puffball | 1999-03-30 |
+----------+------------+
On character type columns, sorting—like all other comparison operations—is normally performed in a case-insensitive fashion. This means that the order is undefined for columns that are identical except for their case. You can force a case-sensitive sort for a column by using BINARY like so: ORDER BY BINARY col_name.

mysql> select * from pet order by BINARY name;
+----------+--------+---------+------+------------+------------+
| name     | owner  | species | sex  | birth      | death      |
+----------+--------+---------+------+------------+------------+
| Bowser   | Diane  | dog     | M    | 1989-08-31 | 1995-07-29 |
| Buffy    | Harold | dog     | F    | 1989-05-13 | NULL       |
| Chirpy   | Gwen   | bird    | F    | 1998-09-11 | NULL       |
| Claws    | Gwen   | cat     | M    | 1994-03-17 | NULL       |
| Fang     | Benny  | dog     | M    | 1990-08-27 | NULL       |
| Fluffy   | Harold | cat     | F    | 1993-02-04 | NULL       |
| Slim     | Benny  | snake   | M    | 1996-04-29 | NULL       |
| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |
| bruzo    | Chinku | dog     | M    | 2019-01-04 | NULL       |
+----------+--------+---------+------+------------+------------+
9 rows in set (0.00 sec)

You can sort on multiple columns, and you can sort different columns in different directions. For example, to sort by type of animal in ascending order, then by birth date within animal type in descending order (youngest animals first), use the following query:

mysql> select name, species, birth from pet
    -> order by species, birth desc;
+----------+---------+------------+
| name     | species | birth      |
+----------+---------+------------+
| Chirpy   | bird    | 1998-09-11 |
| Whistler | bird    | 1997-12-09 |
| Claws    | cat     | 1994-03-17 |
| Fluffy   | cat     | 1993-02-04 |
| bruzo    | dog     | 2019-01-04 |
| Fang     | dog     | 1990-08-27 |
| Bowser   | dog     | 1989-08-31 |
| Buffy    | dog     | 1989-05-13 |
| Slim     | snake   | 1996-04-29 |
+----------+---------+------------+

NOTE - The DESC keyword applies only to the column name immediately preceding it (birth); it does not affect the species column sort order.

If we need both species and birth in descending order, then desc with each col
mysql> select name, species, birth from pet  order by species desc, birth desc;
+----------+---------+------------+
| name     | species | birth      |
+----------+---------+------------+
| Slim     | snake   | 1996-04-29 |
| bruzo    | dog     | 2019-01-04 |
| Fang     | dog     | 1990-08-27 |
| Bowser   | dog     | 1989-08-31 |
| Buffy    | dog     | 1989-05-13 |
| Claws    | cat     | 1994-03-17 |
| Fluffy   | cat     | 1993-02-04 |
| Chirpy   | bird    | 1998-09-11 |
| Whistler | bird    | 1997-12-09 |
+----------+---------+------------+
9 rows in set (0.00 sec)


mysql> describe pet;
+---------+---------------+------+-----+---------+-------+
| Field   | Type          | Null | Key | Default | Extra |
+---------+---------------+------+-----+---------+-------+
| name    | varchar(20)   | YES  |     | NULL    |       |
| owner   | varchar(20)   | YES  |     | NULL    |       |
| species | varchar(20)   | YES  |     | NULL    |       |
| sex     | enum('M','F') | YES  |     | NULL    |       |
| birth   | date          | YES  |     | NULL    |       |
| death   | date          | YES  |     | NULL    |       |
+---------+---------------+------+-----+---------+-------+
6 rows in set (0.01 sec)

NOTE - describe is equivalent to meta in kdb

3.3.4.5 Date Calculations
-------------------------

MySQL provides several functions that you can use to perform calculations on dates, for example, to calculate ages or extract parts of dates.

To determine how many years old each of your pets is, use the TIMESTAMPDIFF() function. Its arguments are the unit in which you want the result expressed, and the two dates for which to take the difference. The following query shows, for each pet, the birth date, the current date, and the age in years. An alias (age) is used to make the final output column label more meaningful.

mysql> select name, birth, curdate(), timestampdiff(YEAR,birth,curdate()) as age from pet order by age desc;
+----------+------------+------------+------+
| name     | birth      | curdate()  | age  |
+----------+------------+------------+------+
| Buffy    | 1989-05-13 | 2021-07-05 |   32 |
| Bowser   | 1989-08-31 | 2021-07-05 |   31 |
| Fang     | 1990-08-27 | 2021-07-05 |   30 |
| Fluffy   | 1993-02-04 | 2021-07-05 |   28 |
| Claws    | 1994-03-17 | 2021-07-05 |   27 |
| Slim     | 1996-04-29 | 2021-07-05 |   25 |
| Whistler | 1997-12-09 | 2021-07-05 |   23 |
| Chirpy   | 1998-09-11 | 2021-07-05 |   22 |
| bruzo    | 2019-01-04 | 2021-07-05 |    2 |
+----------+------------+------------+------+
9 rows in set (0.00 sec)

A similar query can be used to determine age at death for animals that have died. You determine which animals these are by checking whether the death value is NULL. Then, for those with non-NULL values, compute the difference between the death and birth values:
mysql> select name, birth, death, timestampdiff(YEAR, birth, death) as age from pet where death IS NOT NULL order by name;
+--------+------------+------------+------+
| name   | birth      | death      | age  |
+--------+------------+------------+------+
| Bowser | 1989-08-31 | 1995-07-29 |    5 |
+--------+------------+------------+------+

Similarly if we want age of species which are alive.
mysql> select name, birth, death, timestampdiff(YEAR, birth, curdate()) as age from pet where death IS NULL order by name;
+----------+------------+-------+------+
| name     | birth      | death | age  |
+----------+------------+-------+------+
| bruzo    | 2019-01-04 | NULL  |    2 |
| Buffy    | 1989-05-13 | NULL  |   32 |
| Chirpy   | 1998-09-11 | NULL  |   22 |
| Claws    | 1994-03-17 | NULL  |   27 |
| Fang     | 1990-08-27 | NULL  |   30 |
| Fluffy   | 1993-02-04 | NULL  |   28 |
| Slim     | 1996-04-29 | NULL  |   25 |
| Whistler | 1997-12-09 | NULL  |   23 |
+----------+------------+-------+------+

The query uses death IS NOT NULL rather than death <> NULL because NULL is a special value that cannot be compared using the usual comparison operators. This is discussed later. See Section 3.3.4.6, “Working with NULL Values”.

What if you want to know which animals have birthdays next month? For this type of calculation, year and day are irrelevant; you simply want to extract the month part of the birth column. MySQL provides several functions for extracting parts of dates, such as YEAR(), MONTH(), and DAYOFMONTH(). MONTH() is the appropriate function here. To see how it works, run a simple query that displays the value of both birth and MONTH(birth):

Get complete birth details
mysql> select birth, year(birth), month(birth), dayofmonth(birth), weekday(birth), dayname(birth) from pet;
+------------+-------------+--------------+-------------------+----------------+----------------+
| birth      | year(birth) | month(birth) | dayofmonth(birth) | weekday(birth) | dayname(birth) |
+------------+-------------+--------------+-------------------+----------------+----------------+
| 1993-02-04 |        1993 |            2 |                 4 |              3 | Thursday       |
| 1994-03-17 |        1994 |            3 |                17 |              3 | Thursday       |
| 1989-05-13 |        1989 |            5 |                13 |              5 | Saturday       |
| 1990-08-27 |        1990 |            8 |                27 |              0 | Monday         |
| 1989-08-31 |        1989 |            8 |                31 |              3 | Thursday       |
| 1998-09-11 |        1998 |            9 |                11 |              4 | Friday         |
| 1997-12-09 |        1997 |           12 |                 9 |              1 | Tuesday        |
| 1996-04-29 |        1996 |            4 |                29 |              0 | Monday         |
| 2019-01-04 |        2019 |            1 |                 4 |              4 | Friday         |
+------------+-------------+--------------+-------------------+----------------+----------------+

Get the pets whose birthday is in coming month.
mysql> select name, birth, species from pet where month(birth)=(month(curdate())+1);
+--------+------------+---------+
| name   | birth      | species |
+--------+------------+---------+
| Fang   | 1990-08-27 | dog     |
| Bowser | 1989-08-31 | dog     |
+--------+------------+---------+

Other then using curdate()+1, you can use DATE_ADD()
First let's see few examples of DATE_ADD()
mysql> select DATE_ADD(curdate(),INTERVAL 1 MONTH);
+--------------------------------------+
| DATE_ADD(curdate(),INTERVAL 1 MONTH) |
+--------------------------------------+
| 2021-08-05                           |
+--------------------------------------+
1 row in set (0.00 sec)

mysql> select DATE_ADD(curdate(),INTERVAL 1 DAY);
+------------------------------------+
| DATE_ADD(curdate(),INTERVAL 1 DAY) |
+------------------------------------+
| 2021-07-06                         |
+------------------------------------+
1 row in set (0.00 sec)

mysql> select DATE_ADD(curdate(),INTERVAL 1 YEAR);
+-------------------------------------+
| DATE_ADD(curdate(),INTERVAL 1 YEAR) |
+-------------------------------------+
| 2022-07-05                          |
+-------------------------------------+
1 row in set (0.00 sec)

Query - mysql> select name, birth, species from pet where month(birth)=(month(DATE_ADD(curdate(),INTERVAL 1 MONTH)));
        +--------+------------+---------+
        | name   | birth      | species |
        +--------+------------+---------+
        | Fang   | 1990-08-27 | dog     |
        | Bowser | 1989-08-31 | dog     |
        +--------+------------+---------+



But the above code will fail if the current month is december, for that we can use:
mysql> select name, birth, species from pet where month(birth)=(month(DATE_ADD('2020-12-01',INTERVAL 1 MONTH)));
+-------+------------+---------+
| name  | birth      | species |
+-------+------------+---------+
| bruzo | 2019-01-04 | dog     |
+-------+------------+---------+

You can write the query so that it works no matter what the current month is, so that you do not have to use the number for a particular month. DATE_ADD() enables you to add a time interval to a given date. If you add a month to the value of CURDATE(), then extract the month part with MONTH(), the result produces the month in which to look for birthdays:

mysql> SELECT name, birth FROM pet
       WHERE MONTH(birth) = MONTH(DATE_ADD(CURDATE(),INTERVAL 1 MONTH));

A different way to accomplish the same task is to add 1 to get the next month after the current one after using the modulo function (MOD) to wrap the month value to 0 if it is currently 12:


mysql> select name, birth, species from pet where month(birth)=MOD(MONTH(CURDATE()), 12)+1;
+--------+------------+---------+
| name   | birth      | species |
+--------+------------+---------+
| Fang   | 1990-08-27 | dog     |
| Bowser | 1989-08-31 | dog     |
+--------+------------+---------+
2 rows in set (0.00 sec)

mysql> select name, birth, species from pet where month(birth)=MOD(MONTH('2020-12-01'), 12)+1;
+-------+------------+---------+
| name  | birth      | species |
+-------+------------+---------+
| bruzo | 2019-01-04 | dog     |
+-------+------------+---------+
1 row in set (0.00 sec)

MONTH() returns a number between 1 and 12. And MOD(something,12) returns a number between 0 and 11. So the addition has to be after the MOD(), otherwise we would go from November (11) to January (1).

If a calculation uses invalid dates, the calculation fails and produces warnings:
mysql> select '2021-06-04' + 1;
+------------------+
| '2021-06-04' + 1 |
+------------------+
|             2022 |
+------------------+
1 row in set, 1 warning (0.00 sec)

mysql> select '2021-06-04' + INTERVAL 1 DAY;
+-------------------------------+
| '2021-06-04' + INTERVAL 1 DAY |
+-------------------------------+
| 2021-06-05                    |
+-------------------------------+
1 row in set (0.00 sec)

mysql> select '2021-06-32' + INTERVAL 1 DAY;
+-------------------------------+
| '2021-06-32' + INTERVAL 1 DAY |
+-------------------------------+
| NULL                          |
+-------------------------------+
1 row in set, 1 warning (0.00 sec)

mysql> show warnings;
+---------+------+----------------------------------------+
| Level   | Code | Message                                |
+---------+------+----------------------------------------+
| Warning | 1292 | Incorrect datetime value: '2021-06-32' |
+---------+------+----------------------------------------+
1 row in set (0.00 sec)

3.3.4.6 Working with NULL Values
--------------------------------
The NULL value can be surprising until you get used to it. Conceptually, NULL means “a missing unknown value” and it is treated somewhat differently from other values.

To test for NULL, use the IS NULL and IS NOT NULL operators, as shown here:

mysql> SELECT 2 IS NULL, 2 IS NOT NULL;
+-----------+---------------+
| 2 IS NULL | 2 IS NOT NULL |
+-----------+---------------+
|         0 |             1 |
+-----------+---------------+

You cannot use arithmetic comparison operators such as =, <, or <> to test for NULL. To demonstrate this for yourself, try the following query:
mysql> select 1=NULL, 1<>NULL, 1<NULL, 1>NULL;
+--------+---------+--------+--------+
| 1=NULL | 1<>NULL | 1<NULL | 1>NULL |
+--------+---------+--------+--------+
|   NULL |    NULL |   NULL |   NULL |
+--------+---------+--------+--------+

Because the result of any arithmetic comparison with NULL is also NULL, you cannot obtain any meaningful results from such comparisons.

In MySQL, 0 or NULL means false and anything else means true. The default truth value from a boolean operation is 1.

This special treatment of NULL is why, in the previous section, it was necessary to determine which animals are no longer alive using death IS NOT NULL instead of death <> NULL.

Two NULL values are regarded as equal in a GROUP BY.

When doing an ORDER BY, NULL values are presented first if you do ORDER BY ... ASC and last if you do ORDER BY ... DESC.

mysql> SELECT 2 OR NULL;
+-----------+
| 2 OR NULL |
+-----------+
|         1 |
+-----------+
1 row in set (0.00 sec)

mysql> SELECT 0 OR NULL;
+-----------+
| 0 OR NULL |
+-----------+
|      NULL |
+-----------+
1 row in set (0.00 sec)

mysql> select 2 AND NULL;
+------------+
| 2 AND NULL |
+------------+
|       NULL |
+------------+
1 row in set (0.01 sec)

A common error when working with NULL is to assume that it is not possible to insert a zero or an empty string into a column defined as NOT NULL, but this is not the case. These are in fact values, whereas NULL means “not having a value.” You can test this easily enough by using IS [NOT] NULL as shown:
mysql> SELECT 0 IS NULL, 0 IS NOT NULL, '' IS NULL, '' IS NOT NULL;
+-----------+---------------+------------+----------------+
| 0 IS NULL | 0 IS NOT NULL | '' IS NULL | '' IS NOT NULL |
+-----------+---------------+------------+----------------+
|         0 |             1 |          0 |              1 |
+-----------+---------------+------------+----------------+

B.3.4.3 Problems with NULL Values
---------------------------------
The concept of the NULL value is a common source of confusion for newcomers to SQL, who often think that NULL is the same thing as an empty string ''. This is not the case. For example, the following statements are completely different:

mysql> INSERT INTO my_table (phone) VALUES (NULL);
mysql> INSERT INTO my_table (phone) VALUES ('');
Both statements insert a value into the phone column, but the first inserts a NULL value and the second inserts an empty string. The meaning of the first can be regarded as “phone number is not known” and the meaning of the second can be regarded as “the person is known to have no phone, and thus no phone number.”

In SQL, the NULL value is never true in comparison to any other value, even NULL. An expression that contains NULL always produces a NULL value unless otherwise indicated in the documentation for the operators and functions involved in the expression. All columns in the following example return NULL:
mysql> SELECT NULL, 1+NULL, CONCAT('Invisible', NULL);
+------+--------+---------------------------+
| NULL | 1+NULL | CONCAT('Invisible', NULL) |
+------+--------+---------------------------+
| NULL |   NULL | NULL                      |
+------+--------+---------------------------+

To search for column values that are NULL, you cannot use an expr = NULL test. The following statement returns no rows, because expr = NULL is never true for any expression:
SELECT * FROM my_table WHERE phone = NULL;

To look for NULL values, you must use the IS NULL test. The following statements show how to find the NULL phone number and the empty phone number:

mysql> SELECT * FROM my_table WHERE phone IS NULL;
mysql> SELECT * FROM my_table WHERE phone = '';

You can add an index on a column that can have NULL values if you are using the MyISAM, InnoDB, or MEMORY storage engine. Otherwise, you must declare an indexed column NOT NULL, and you cannot insert NULL into the column.

When reading data with LOAD DATA, empty or missing columns are updated with ''. To load a NULL value into a column, use \N in the data file. The literal word NULL may also be used under some circumstances.

When using DISTINCT, GROUP BY, or ORDER BY, all NULL values are regarded as equal.

When using ORDER BY, NULL values are presented first, or last if you specify DESC to sort in descending order.

Aggregate (group) functions such as COUNT(), MIN(), and SUM() ignore NULL values. The exception to this is COUNT(*), which counts rows and not individual column values. For example, the following statement produces two counts. The first is a count of the number of rows in the table, and the second is a count of the number of non-NULL values in the age column:
mysql> SELECT COUNT(*), COUNT(SEX) FROM pet;
+----------+------------+
| COUNT(*) | COUNT(SEX) |
+----------+------------+
|        9 |          8 |
+----------+------------+
For some data types, MySQL handles NULL values specially. If you insert NULL into a TIMESTAMP column, the current date and time is inserted. If you insert NULL into an integer or floating-point column that has the AUTO_INCREMENT attribute, the next number in the sequence is inserted.

3.3.4.7 Pattern Matching
========================
MySQL provides standard SQL pattern matching as well as a form of pattern matching based on extended regular expressions similar to those used by Unix utilities such as vi, grep, and sed.

SQL pattern matching enables you to use _ to match any single character and % to match an arbitrary number of characters (including zero characters). In MySQL, SQL patterns are case-insensitive by default. Some examples are shown here. Do not use = or <> when you use SQL patterns. Use the LIKE or NOT LIKE comparison operators instead.

To find names beginning with b:
mysql> SELECT * FROM pet WHERE name LIKE 'B%';
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | F    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | M    | 1989-08-31 | 1995-07-29 |
| bruzo  | Chinku | dog     | M    | 2019-01-04 | NULL       |
+--------+--------+---------+------+------------+------------+
3 rows in set (0.01 sec)

mysql> SELECT * FROM pet WHERE name LIKE BINARY 'B%';
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | F    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | M    | 1989-08-31 | 1995-07-29 |
+--------+--------+---------+------+------------+------------+
2 rows in set (0.00 sec)

To find names ending with fy:
mysql> SELECT * FROM pet WHERE name LIKE '%FY';
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | F    | 1993-02-04 | NULL  |
| Buffy  | Harold | dog     | F    | 1989-05-13 | NULL  |
+--------+--------+---------+------+------------+-------+
2 rows in set (0.00 sec)

To find names containing a w:
mysql> SELECT * FROM pet WHERE name LIKE '%w%';
+----------+-------+---------+------+------------+------------+
| name     | owner | species | sex  | birth      | death      |
+----------+-------+---------+------+------------+------------+
| Claws    | Gwen  | cat     | M    | 1994-03-17 | NULL       |
| Bowser   | Diane | dog     | M    | 1989-08-31 | 1995-07-29 |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL       |
+----------+-------+---------+------+------------+------------+
3 rows in set (0.00 sec)

To find names containing exactly five characters, use five instances of the _ pattern character:
mysql> SELECT * FROM pet WHERE name LIKE '_____';
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | M    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | F    | 1989-05-13 | NULL  |
| bruzo | Chinku | dog     | M    | 2019-01-04 | NULL  |
+-------+--------+---------+------+------------+-------+
3 rows in set (0.00 sec)

The other type of pattern matching provided by MySQL uses extended regular expressions. When you test for a match for this type of pattern, use the REGEXP_LIKE() function (or the REGEXP or RLIKE operators, which are synonyms for REGEXP_LIKE()).

The following list describes some characteristics of extended regular expressions:

. matches any single character.

A character class [...] matches any character within the brackets. For example, [abc] matches a, b, or c. To name a range of characters, use a dash. [a-z] matches any letter, whereas [0-9] matches any digit.

* matches zero or more instances of the thing preceding it. For example, x* matches any number of x characters, [0-9]* matches any number of digits, and .* matches any number of anything.

A regular expression pattern match succeeds if the pattern matches anywhere in the value being tested. (This differs from a LIKE pattern match, which succeeds only if the pattern matches the entire value.)

To anchor a pattern so that it must match the beginning or end of the value being tested, use ^ at the beginning or $ at the end of the pattern.

To demonstrate how extended regular expressions work, the LIKE queries shown previously are rewritten here to use REGEXP_LIKE().

To find names beginning with b, use ^ to match the beginning of the name:

mysql> select * from pet where REGEXP_LIKE(name, '^b' COLLATE utf8mb4_0900_as_cs);
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| bruzo | Chinku | dog     | M    | 2019-01-04 | NULL  |
+-------+--------+---------+------+------------+-------+

mysql> select * from pet where REGEXP_LIKE(name, BINARY '^b');
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| bruzo | Chinku | dog     | M    | 2019-01-04 | NULL  |
+-------+--------+---------+------+------------+-------+

mysql> select * from pet where REGEXP_LIKE(name, '^b');
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | F    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | M    | 1989-08-31 | 1995-07-29 |
| bruzo  | Chinku | dog     | M    | 2019-01-04 | NULL       |
+--------+--------+---------+------+------------+------------+

mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, '^b', 'c');
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| bruzo | Chinku | dog     | M    | 2019-01-04 | NULL  |
+-------+--------+---------+------+------------+-------+
1 row in set (0.00 sec)

To find names ending with fy, use $ to match the end of the name:
mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, 'fy$');
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | F    | 1993-02-04 | NULL  |
| Buffy  | Harold | dog     | F    | 1989-05-13 | NULL  |
+--------+--------+---------+------+------------+-------+

To find names containing a w, use this query:
mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, 'w');
+----------+-------+---------+------+------------+------------+
| name     | owner | species | sex  | birth      | death      |
+----------+-------+---------+------+------------+------------+
| Claws    | Gwen  | cat     | M    | 1994-03-17 | NULL       |
| Bowser   | Diane | dog     | M    | 1989-08-31 | 1995-07-29 |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL       |
+----------+-------+---------+------+------------+------------+

mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, BINARY 'w');
+--------+-------+---------+------+------------+------------+
| name   | owner | species | sex  | birth      | death      |
+--------+-------+---------+------+------------+------------+
| Claws  | Gwen  | cat     | M    | 1994-03-17 | NULL       |
| Bowser | Diane | dog     | M    | 1989-08-31 | 1995-07-29 |
+--------+-------+---------+------+------------+------------+
2 rows in set (0.00 sec)

mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, 'w', 'c');
+--------+-------+---------+------+------------+------------+
| name   | owner | species | sex  | birth      | death      |
+--------+-------+---------+------+------------+------------+
| Claws  | Gwen  | cat     | M    | 1994-03-17 | NULL       |
| Bowser | Diane | dog     | M    | 1989-08-31 | 1995-07-29 |
+--------+-------+---------+------+------------+------------+
2 rows in set (0.00 sec)

Because a regular expression pattern matches if it occurs anywhere in the value, it is not necessary in the previous query to put a wildcard on either side of the pattern to get it to match the entire value as would be true with an SQL pattern.

To find names containing exactly five characters, use ^ and $ to match the beginning and end of the name, and five instances of . in between:
mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, '^.....$');
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | M    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | F    | 1989-05-13 | NULL  |
| bruzo | Chinku | dog     | M    | 2019-01-04 | NULL  |
+-------+--------+---------+------+------------+-------+

You could also write the previous query using the {n} (“repeat-n-times”) operator:
mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, '^.{5}$');
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | M    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | F    | 1989-05-13 | NULL  |
| bruzo | Chinku | dog     | M    | 2019-01-04 | NULL  |
+-------+--------+---------+------+------------+-------+

mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, '^.{4,6}$');
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Fluffy | Harold | cat     | F    | 1993-02-04 | NULL       |
| Claws  | Gwen   | cat     | M    | 1994-03-17 | NULL       |
| Buffy  | Harold | dog     | F    | 1989-05-13 | NULL       |
| Fang   | Benny  | dog     | M    | 1990-08-27 | NULL       |
| Bowser | Diane  | dog     | M    | 1989-08-31 | 1995-07-29 |
| Chirpy | Gwen   | bird    | F    | 1998-09-11 | NULL       |
| Slim   | Benny  | snake   | M    | 1996-04-29 | NULL       |
| bruzo  | Chinku | dog     | M    | 2019-01-04 | NULL       |
+--------+--------+---------+------+------------+------------+

12.8.2 Regular Expressions
---------------------------
Table 12.14 Regular Expression Functions and Operators

Name	            Description
NOT REGEXP	        Negation of REGEXP
REGEXP	            Whether string matches regular expression
REGEXP_INSTR()	    Starting index of substring matching regular expression
REGEXP_LIKE()	    Whether string matches regular expression
REGEXP_REPLACE()	Replace substrings matching regular expression
REGEXP_SUBSTR()	    Return substring matching regular expression
RLIKE	            Whether string matches regular expression

A regular expression is a powerful way of specifying a pattern for a complex search. This section discusses the functions and operators available for regular expression matching and illustrates, with examples, some of the special characters and constructs that can be used for regular expression operations

MySQL implements regular expression support using International Components for Unicode (ICU), which provides full Unicode support and is multibyte safe.

Regular Expression Function and Operator Descriptions
======================================================
expr NOT REGEXP pat, expr NOT RLIKE pat
This is the same as NOT (expr REGEXP pat).
expr REGEXP pat, expr RLIKE pat
Returns 1 if the string expr matches the regular expression specified by the pattern pat, 0 otherwise. If expr or pat is NULL, the return value is NULL.
REGEXP and RLIKE are synonyms for REGEXP_LIKE().
For additional information about how matching occurs, see the description for REGEXP_LIKE().

mysql> SELECT 'Michael!' REGEXP '.*';
+------------------------+
| 'Michael!' REGEXP '.*' |
+------------------------+
|                      1 |
+------------------------+
1 row in set (0.00 sec)

mysql> SELECT 'Michael!' RLIKE '.*';
+-----------------------+
| 'Michael!' RLIKE '.*' |
+-----------------------+
|                     1 |
+-----------------------+
1 row in set (0.02 sec)

mysql> select 'new*\n*line' REGEXP '.*';
+---------------------------+
| 'new*\n*line' REGEXP '.*' |
+---------------------------+
|                         1 |
+---------------------------+
1 row in set (0.00 sec)

mysql> select 'new*\n*line' REGEXP 'new\\*.\\*line';
+---------------------------------------+
| 'new*\n*line' REGEXP 'new\\*.\\*line' |
+---------------------------------------+
|                                     0 |
+---------------------------------------+
1 row in set (0.01 sec)

mysql> select 'a' regexp '^[a-d]';
+---------------------+
| 'a' regexp '^[a-d]' |
+---------------------+
|                   1 |
+---------------------+
1 row in set (0.00 sec)

mysql> select 'a' regexp 'A', 'a' regexp binary 'A';
+----------------+-----------------------+
| 'a' regexp 'A' | 'a' regexp binary 'A' |
+----------------+-----------------------+
|              1 |                     0 |
+----------------+-----------------------+

REGEXP_INSTR(expr, pat[, pos[, occurrence[, return_option[, match_type]]]])
-----------------------------------------------------------------------------
Returns the starting index of the substring of the string expr that matches the regular expression specified by the pattern pat, 0 if there is no match. If expr or pat is NULL, the return value is NULL. Character indexes begin at 1.

REGEXP_INSTR() takes these optional arguments:

pos: The position in expr at which to start the search. If omitted, the default is 1.

occurrence: Which occurrence of a match to search for. If omitted, the default is 1.

return_option: Which type of position to return. If this value is 0, REGEXP_INSTR() returns the position of the matched substring's first character. If this value is 1, REGEXP_INSTR() returns the position following the matched substring. If omitted, the default is 0.

match_type: A string that specifies how to perform matching. The meaning is as described for REGEXP_LIKE().

For additional information about how matching occurs, see the description for REGEXP_LIKE().

mysql> select REGEXP_INSTR('dog cat dog', 'dog');
+------------------------------------+
| REGEXP_INSTR('dog cat dog', 'dog') |
+------------------------------------+
|                                  1 |
+------------------------------------+
1 row in set (0.01 sec)

mysql> select REGEXP_INSTR('dog cat dog', 'cat');
+------------------------------------+
| REGEXP_INSTR('dog cat dog', 'cat') |
+------------------------------------+
|                                  5 |
+------------------------------------+
1 row in set (0.00 sec)

mysql> select REGEXP_INSTR('dog cat dog', 'dog', 2);
+---------------------------------------+
| REGEXP_INSTR('dog cat dog', 'dog', 2) |
+---------------------------------------+
|                                     9 |
+---------------------------------------+

mysql> select REGEXP_INSTR('dogdog cat dog', 'dog', 2);                                                                         +------------------------------------------+
| REGEXP_INSTR('dogdog cat dog', 'dog', 2) |
+------------------------------------------+
|                                        4 |
+------------------------------------------+


mysql> select REGEXP_INSTR('AA AAA AAA', 'A{2}');
+------------------------------------+
| REGEXP_INSTR('AA AAA AAA', 'A{2}') |
+------------------------------------+
|                                  1 |
+------------------------------------+
1 row in set (0.00 sec)

mysql> select REGEXP_INSTR('AA AAA AAAA', 'A{3}');
+-------------------------------------+
| REGEXP_INSTR('AA AAA AAAA', 'A{3}') |
+-------------------------------------+
|                                   4 |
+-------------------------------------+
1 row in set (0.00 sec)

mysql> select REGEXP_INSTR('AA AAA AAAA', 'A{4}');
+-------------------------------------+
| REGEXP_INSTR('AA AAA AAAA', 'A{4}') |
+-------------------------------------+
|                                   8 |
+-------------------------------------+

mysql> select REGEXP_INSTR('AA AAA AAAA', 'B{4}');
+-------------------------------------+
| REGEXP_INSTR('AA AAA AAAA', 'B{4}') |
+-------------------------------------+
|                                   0 |
+-------------------------------------+
1 row in set (0.00 sec)

mysql> select REGEXP_INSTR('AA AAA AAAA', 'NULL');
+-------------------------------------+
| REGEXP_INSTR('AA AAA AAAA', 'NULL') |
+-------------------------------------+
|                                   0 |
+-------------------------------------+
1 row in set (0.00 sec)

REGEXP_LIKE(expr, pat[, match_type])
-------------------------------------
Returns 1 if the string expr matches the regular expression specified by the pattern pat, 0 otherwise. If expr or pat is NULL, the return value is NULL.

The pattern can be an extended regular expression, the syntax for which is discussed in Regular Expression Syntax. The pattern need not be a literal string. For example, it can be specified as a string expression or table column.

The optional match_type argument is a string that may contain any or all the following characters specifying how to perform matching:

c: Case-sensitive matching.

i: Case-insensitive matching.

m: Multiple-line mode. Recognize line terminators within the string. The default behavior is to match line terminators only at the start and end of the string expression.

n: The . character matches line terminators. The default is for . matching to stop at the end of a line.

u: Unix-only line endings. Only the newline character is recognized as a line ending by the ., ^, and $ match operators.

If characters specifying contradictory options are specified within match_type, the rightmost one takes precedence.

By default, regular expression operations use the character set and collation of the expr and pat arguments when deciding the type of a character and performing the comparison. If the arguments have different character sets or collations, coercibility rules apply as described in Section 10.8.4, “Collation Coercibility in Expressions”. Arguments may be specified with explicit collation indicators to change comparison behavior.

mysql> select regexp_like('CamelCase', 'CAMELCASE');
+---------------------------------------+
| regexp_like('CamelCase', 'CAMELCASE') |
+---------------------------------------+
|                                     1 |
+---------------------------------------+

mysql> select regexp_like('CamelCase', 'CAMELCASE', 'c');
+--------------------------------------------+
| regexp_like('CamelCase', 'CAMELCASE', 'c') |
+--------------------------------------------+
|                                          0 |
+--------------------------------------------+

mysql> select regexp_like('CamelCase', 'CAMELCASE' COLLATE utf8mb4_0900_as_cs);
+------------------------------------------------------------------+
| regexp_like('CamelCase', 'CAMELCASE' COLLATE utf8mb4_0900_as_cs) |
+------------------------------------------------------------------+
|                                                                0 |
+------------------------------------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like('CamelCase', BINARY 'CAMELCASE');
+----------------------------------------------+
| regexp_like('CamelCase', BINARY 'CAMELCASE') |
+----------------------------------------------+
|                                            0 |
+----------------------------------------------+

match_type may be specified with the c or i characters to override the default case sensitivity. Exception: If either argument is a binary string, the arguments are handled in case-sensitive fashion as binary strings, even if match_type contains the i character.

mysql> select regexp_like('CamelCase', BINARY 'CAMELCASE', 'i');
+---------------------------------------------------+
| regexp_like('CamelCase', BINARY 'CAMELCASE', 'i') |
+---------------------------------------------------+
|                                                 1 |
+---------------------------------------------------+

Note
MySQL uses C escape syntax in strings (for example, \n to represent the newline character). If you want your expr or pat argument to contain a literal \, you must double it. (Unless the NO_BACKSLASH_ESCAPES SQL mode is enabled, in which case no escape character is used.)

REGEXP_REPLACE(expr, pat, repl[, pos[, occurrence[, match_type]]])
--------------------------------------------------------------------
Replaces occurrences in the string expr that match the regular expression specified by the pattern pat with the replacement string repl, and returns the resulting string. If expr, pat, or repl is NULL, the return value is NULL.

REGEXP_REPLACE() takes these optional arguments:

pos: The position in expr at which to start the search. If omitted, the default is 1.

occurrence: Which occurrence of a match to replace. If omitted, the default is 0 (which means “replace all occurrences”).

match_type: A string that specifies how to perform matching. The meaning is as described for REGEXP_LIKE().

Prior to MySQL 8.0.17, the result returned by this function used the UTF-16 character set; in MySQL 8.0.17 and later, the character set and collation of the expression searched for matches is used. (Bug #94203, Bug #29308212)

For additional information about how matching occurs, see the description for REGEXP_LIKE().

mysql> select REGEXP_REPLACE('a b c', 'b', 'X');
+-----------------------------------+
| regexp_replace('a b c', 'b', 'X') |
+-----------------------------------+
| a X c                             |
+-----------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_replace('abc def ghi', '[a-z]+', 'X', 1,3);
+---------------------------------------------------+
| regexp_replace('abc def ghi', '[a-z]+', 'X', 1,3) |
+---------------------------------------------------+
| abc def X                                         |
+---------------------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_replace('abc def ghi', '[a-z]+', 'X');
+----------------------------------------------+
| regexp_replace('abc def ghi', '[a-z]+', 'X') |
+----------------------------------------------+
| X X X                                        |
+----------------------------------------------+

REGEXP_SUBSTR(expr, pat[, pos[, occurrence[, match_type]]])
------------------------------------------------------------
Returns the substring of the string expr that matches the regular expression specified by the pattern pat, NULL if there is no match. If expr or pat is NULL, the return value is NULL.

REGEXP_SUBSTR() takes these optional arguments:

pos: The position in expr at which to start the search. If omitted, the default is 1.

occurrence: Which occurrence of a match to search for. If omitted, the default is 1.

match_type: A string that specifies how to perform matching. The meaning is as described for REGEXP_LIKE().

Prior to MySQL 8.0.17, the result returned by this function used the UTF-16 character set; in MySQL 8.0.17 and later, the character set and collation of the expression searched for matches is used. (Bug #94203, Bug #29308212)

For additional information about how matching occurs, see the description for REGEXP_LIKE().

mysql> select regexp_substr('abc def ghi', '[a-z]+');
+----------------------------------------+
| regexp_substr('abc def ghi', '[a-z]+') |
+----------------------------------------+
| abc                                    |
+----------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_substr('abc def ghi', '[a-z]+',1);
+------------------------------------------+
| regexp_substr('abc def ghi', '[a-z]+',1) |
+------------------------------------------+
| abc                                      |
+------------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_substr('abc def ghi', '[a-z]+',1,2);
+--------------------------------------------+
| regexp_substr('abc def ghi', '[a-z]+',1,2) |
+--------------------------------------------+
| def                                        |
+--------------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_substr('abc 12 def ghi', '[a-z]+',1,2);
+-----------------------------------------------+
| regexp_substr('abc 12 def ghi', '[a-z]+',1,2) |
+-----------------------------------------------+
| def                                           |
+-----------------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_substr('abc12def ghi', '[a-z]+',1,2);
+---------------------------------------------+
| regexp_substr('abc12def ghi', '[a-z]+',1,2) |
+---------------------------------------------+
| def                                         |
+---------------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_substr('abc12def ghi', '[a-z]+');
+-----------------------------------------+
| regexp_substr('abc12def ghi', '[a-z]+') |
+-----------------------------------------+
| abc                                     |
+-----------------------------------------+


Regular Expression Syntax
==========================
Regular Expression Syntax

A regular expression describes a set of strings. The simplest regular expression is one that has no special characters in it. For example, the regular expression hello matches hello and nothing else.

Nontrivial regular expressions use certain special constructs so that they can match more than one string. For example, the regular expression hello|world contains the | alternation operator and matches either the hello or world.

As a more complex example, the regular expression B[an]*s matches any of the strings Bananas, Baaaaas, Bs, and any other string starting with a B, ending with an s, and containing any number of a or n characters in between.

The following list covers some of the basic special characters and constructs that can be used in regular expressions. For information about the full regular expression syntax supported by the ICU library used to implement regular expression support, visit the International Components for Unicode website.

^ - Match the beginning of a string.
mysql> select regexp_like ('fo\nfo', '^fo$');
+--------------------------------+
| regexp_like ('fo\nfo', '^fo$') |
+--------------------------------+
|                              0 |
+--------------------------------+
1 row in set (0.01 sec)

mysql> select regexp_like ('fo\nfo', '^fo');
+-------------------------------+
| regexp_like ('fo\nfo', '^fo') |
+-------------------------------+
|                             1 |
+-------------------------------+

$ - Match the end of a string.
mysql> SELECT REGEXP_LIKE('fo\no', '^fo\no$');                 -> 1
mysql> SELECT REGEXP_LIKE('fo\no', '^fo$');                    -> 0

. - Match any character (including carriage return and newline, although to match these in the middle of a string, the m (multiple line) match-control character or the (?m) within-pattern modifier must be given).

mysql> select regexp_like ('fofo', '^f.*$');
+-------------------------------+
| regexp_like ('fofo', '^f.*$') |
+-------------------------------+
|                             1 |
+-------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like ('fo\r\nfo', '^f.*$');
+-----------------------------------+
| regexp_like ('fo\r\nfo', '^f.*$') |
+-----------------------------------+
|                                 0 |
+-----------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like ('fo\r\nfo', '^f.*$', 'm');
+----------------------------------------+
| regexp_like ('fo\r\nfo', '^f.*$', 'm') |
+----------------------------------------+
|                                      1 |
+----------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like ('fo\r\nfo', '(?m)^f.*$');
+---------------------------------------+
| regexp_like ('fo\r\nfo', '(?m)^f.*$') |
+---------------------------------------+
|                                     1 |
+---------------------------------------+

a* - Match any sequence of zero or more a characters.
mysql> SELECT REGEXP_LIKE('Ban', '^Ba*n');                     -> 1
mysql> SELECT REGEXP_LIKE('Baaan', '^Ba*n');                   -> 1
mysql> SELECT REGEXP_LIKE('Bn', '^Ba*n');                      -> 1

a+ - Match any sequence of one or more a characters.
mysql> SELECT REGEXP_LIKE('Ban', '^Ba+n');                     -> 1
mysql> SELECT REGEXP_LIKE('Bn', '^Ba+n');                      -> 0

a? - Match either zero or one a character.
mysql> SELECT REGEXP_LIKE('Bn', '^Ba?n');                      -> 1
mysql> SELECT REGEXP_LIKE('Ban', '^Ba?n');                     -> 1
mysql> SELECT REGEXP_LIKE('Baan', '^Ba?n');                    -> 0

de|abc - alternation; match either of the sequences de or abc.
mysql> SELECT REGEXP_LIKE('pi', 'pi|apa');                     -> 1
mysql> SELECT REGEXP_LIKE('axe', 'pi|apa');                    -> 0
mysql> SELECT REGEXP_LIKE('apa', 'pi|apa');                    -> 1
mysql> SELECT REGEXP_LIKE('apa', '^(pi|apa)$');                -> 1
mysql> SELECT REGEXP_LIKE('pi', '^(pi|apa)$');                 -> 1
mysql> SELECT REGEXP_LIKE('pix', '^(pi|apa)$');                -> 0

(abc)* - Match zero or more instances of the sequence abc.
mysql> SELECT REGEXP_LIKE('pi', '^(pi)*$');                    -> 1
mysql> SELECT REGEXP_LIKE('pip', '^(pi)*$');                   -> 0
mysql> SELECT REGEXP_LIKE('pipi', '^(pi)*$');                  -> 1

mysql> SELECT REGEXP_LIKE('pip', '(pi)*');
+-----------------------------+
| REGEXP_LIKE('pip', '(pi)*') |
+-----------------------------+
|                           1 |
+-----------------------------+
1 row in set (0.00 sec)

{1}, {2,3} - Repetition; {n} and {m,n} notation provide a more general way of writing regular expressions that match many occurrences of the previous atom (or “piece”) of the pattern. m and n are integers.

a* - Can be written as a{0,}.
a+ - Can be written as a{1,}.
a? - Can be written as a{0,1}.

mysql> select regexp_like ('abcde', 'a[bcd]{1}e');
+-------------------------------------+
| regexp_like ('abcde', 'a[bcd]{1}e') |
+-------------------------------------+
|                                   0 |
+-------------------------------------+
1 row in set (0.01 sec)

mysql> select regexp_like ('abcde', 'a[bcd]{1,}e');
+--------------------------------------+
| regexp_like ('abcde', 'a[bcd]{1,}e') |
+--------------------------------------+
|                                    1 |
+--------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like ('abcde', 'a[bcd]{2}e');
+-------------------------------------+
| regexp_like ('abcde', 'a[bcd]{2}e') |
+-------------------------------------+
|                                   0 |
+-------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like ('abcde', 'a[bcd]{3}e');
+-------------------------------------+
| regexp_like ('abcde', 'a[bcd]{3}e') |
+-------------------------------------+
|                                   1 |
+-------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like ('abcde', 'a[bcd]{4}e');
+-------------------------------------+
| regexp_like ('abcde', 'a[bcd]{4}e') |
+-------------------------------------+
|                                   0 |
+-------------------------------------+

mysql> SELECT REGEXP_LIKE('abcde', 'a[bcd]{1,10}e');           -> 1

[a-dX], [^a-dX] - Matches any character that is (or is not, if ^ is used) either a, b, c, d or X. A - character between two other characters forms a range that matches all characters from the first character to the second. For example, [0-9] matches any decimal digit. To include a literal ] character, it must immediately follow the opening bracket [. To include a literal - character, it must be written first or last. Any character that does not have a defined special meaning inside a [] pair matches only itself.

mysql> SELECT REGEXP_LIKE('aXbc', '[a-dXYZ]');                 -> 1
mysql> SELECT REGEXP_LIKE('aXbc', '^[a-dXYZ]$');               -> 0
mysql> SELECT REGEXP_LIKE('aXbc', '^[a-dXYZ]+$');              -> 1
mysql> SELECT REGEXP_LIKE('aXbc', '^[^a-dXYZ]+$');             -> 0
mysql> SELECT REGEXP_LIKE('gheis', '^[^a-dXYZ]+$');            -> 1
mysql> SELECT REGEXP_LIKE('gheisa', '^[^a-dXYZ]+$');           -> 0

mysql> SELECT REGEXP_LIKE('aXbcZ', '^[a-dXY]');
+----------------------------------+
| REGEXP_LIKE('aXbcZ', '^[a-dXY]') |
+----------------------------------+
|                                1 |
+----------------------------------+
1 row in set (0.00 sec)

mysql> SELECT REGEXP_LIKE('caXbcZ', '^[a-dXY]');
+-----------------------------------+
| REGEXP_LIKE('caXbcZ', '^[a-dXY]') |
+-----------------------------------+
|                                 1 |
+-----------------------------------+

[=character_class=] - Within a bracket expression (written using [ and ]), [=character_class=] represents an equivalence class. It matches all characters with the same collation value, including itself. For example, if o and (+) are the members of an equivalence class, [[=o=]], [[=(+)=]], and [o(+)] are all synonymous. An equivalence class may not be used as an endpoint of a range.

[:character_class:] - Within a bracket expression (written using [ and ]), [:character_class:] represents a character class that matches all characters belonging to that class. The following table lists the standard class names. These names stand for the character classes defined in the ctype(3) manual page. A particular locale may provide other class names. A character class may not be used as an endpoint of a range.

Character Class Name	Meaning
alnum	                Alphanumeric characters
alpha	                Alphabetic characters
blank	                Whitespace characters
cntrl	                Control characters
digit	                Digit characters
graph	                Graphic characters
lower	                Lowercase alphabetic characters
print	                Graphic or space characters
punct	                Punctuation characters
space	                Space, tab, newline, and carriage return
upper	                Uppercase alphabetic characters
xdigit	                Hexadecimal digit characters

mysql> SELECT REGEXP_LIKE('justalnums', '[[:alnum:]]+');       -> 1
mysql> SELECT REGEXP_LIKE('!!', '[[:alnum:]]+');               -> 0

To use a literal instance of a special character in a regular expression, precede it by two backslash (\) characters. The MySQL parser interprets one of the backslashes, and the regular expression library interprets the other. For example, to match the string 1+2 that contains the special + character, only the last of the following regular expressions is the correct one:

mysql> SELECT REGEXP_LIKE('1+2', '1+2');                       -> 0
mysql> SELECT REGEXP_LIKE('1+2', '1\+2');                      -> 0
mysql> SELECT REGEXP_LIKE('1+2', '1\\+2');                     -> 1

mysql> select regexp_like('ramesh123', '[[:alnum:]]');
+-----------------------------------------+
| regexp_like('ramesh123', '[[:alnum:]]') |
+-----------------------------------------+
|                                       1 |
+-----------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like('ramesh', '[[:alnum:]]');
+--------------------------------------+
| regexp_like('ramesh', '[[:alnum:]]') |
+--------------------------------------+
|                                    1 |
+--------------------------------------+
1 row in set (0.01 sec)

mysql> select regexp_like('123', '[[:alnum:]]');
+-----------------------------------+
| regexp_like('123', '[[:alnum:]]') |
+-----------------------------------+
|                                 1 |
+-----------------------------------+
1 row in set (0.01 sec)

mysql> select regexp_like('', '[[:alnum:]]');
+--------------------------------+
| regexp_like('', '[[:alnum:]]') |
+--------------------------------+
|                              0 |
+--------------------------------+
1 row in set (0.01 sec)

mysql> select regexp_like('123!', '[[:alnum:]]');
+------------------------------------+
| regexp_like('123!', '[[:alnum:]]') |
+------------------------------------+
|                                  1 |
+------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like('123!', '[[:alnum:]]+');
+-------------------------------------+
| regexp_like('123!', '[[:alnum:]]+') |
+-------------------------------------+
|                                   1 |
+-------------------------------------+
1 row in set (0.01 sec)


Regular Expression Resource Control

REGEXP_LIKE() and similar functions use resources that can be controlled by setting system variables:

The match engine uses memory for its internal stack. To control the maximum available memory for the stack in bytes, set the regexp_stack_limit system variable.

The match engine operates in steps. To control the maximum number of steps performed by the engine (and thus indirectly the execution time), set the regexp_time_limit system variable. Because this limit is expressed as number of steps, it affects execution time only indirectly. Typically, it is on the order of milliseconds.

3.3.4.8 Counting Rows
---------------------
Databases are often used to answer the question, “How often does a certain type of data occur in a table?” For example, you might want to know how many pets you have, or how many pets each owner has, or you might want to perform various kinds of census operations on your animals.

Counting the total number of animals you have is the same question as “How many rows are in the pet table?” because there is one record per pet. COUNT(*) counts the number of rows, so the query to count your animals looks like this:
mysql> select count(*) from pet;
+----------+
| count(*) |
+----------+
|        9 |
+----------+

Earlier, you retrieved the names of the people who owned pets. You can use COUNT() if you want to find out how many pets each owner has:
mysql> select owner, count(owner) from pet group by owner;
+--------+--------------+
| owner  | count(owner) |
+--------+--------------+
| Harold |            2 |
| Gwen   |            3 |
| Benny  |            2 |
| Diane  |            1 |
| Chinku |            1 |
+--------+--------------+
5 rows in set (0.00 sec)

The preceding query uses GROUP BY to group all records for each owner. The use of COUNT() in conjunction with GROUP BY is useful for characterizing your data under various groupings. The following examples show different ways to perform animal census operations.

Number of animals per species:
mysql> select species, count(species) from pet group by species;
+---------+----------------+
| species | count(species) |
+---------+----------------+
| cat     |              2 |
| dog     |              4 |
| bird    |              2 |
| snake   |              1 |
+---------+----------------+
4 rows in set (0.01 sec)

Number of animals per sex:
mysql> select sex, count(sex) from pet group by sex;
+------+------------+
| sex  | count(sex) |
+------+------------+
| F    |          3 |
| M    |          5 |
| NULL |          0 |
+------+------------+
3 rows in set (0.00 sec)

OR -
mysql> select sex, count(*) from pet group by sex;
+------+----------+
| sex  | count(*) |
+------+----------+
| F    |        3 |
| M    |        5 |
| NULL |        1 |
+------+----------+
3 rows in set (0.00 sec)

(In this output, NULL indicates that the sex is unknown.)

Number of animals per combination of species and sex:
mysql> select species, sex, count(*) from pet group by species, sex;
+---------+------+----------+
| species | sex  | count(*) |
+---------+------+----------+
| cat     | F    |        1 |
| cat     | M    |        1 |
| dog     | F    |        1 |
| dog     | M    |        3 |
| bird    | F    |        1 |
| bird    | NULL |        1 |
| snake   | M    |        1 |
+---------+------+----------+

You need not retrieve an entire table when you use COUNT(). For example, the previous query, when performed just on dogs and cats, looks like this:
mysql> select species, sex, count(*) from pet where species = 'dog' or species = 'cat' group by species, sex;
+---------+------+----------+
| species | sex  | count(*) |
+---------+------+----------+
| cat     | F    |        1 |
| cat     | M    |        1 |
| dog     | F    |        1 |
| dog     | M    |        3 |
+---------+------+----------+
4 rows in set (0.00 sec)

OR -
mysql> select species, sex, count(*) from pet group by species, sex having species='dog' or species='cat';
+---------+------+----------+
| species | sex  | count(*) |
+---------+------+----------+
| cat     | F    |        1 |
| cat     | M    |        1 |
| dog     | F    |        1 |
| dog     | M    |        3 |
+---------+------+----------+
4 rows in set (0.00 sec)

Or, if you wanted the number of animals per sex only for animals whose sex is known:
mysql> select species, sex, count(sex) from pet where sex is not null group by species, sex;
+---------+------+------------+
| species | sex  | count(sex) |
+---------+------+------------+
| cat     | F    |          1 |
| cat     | M    |          1 |
| dog     | F    |          1 |
| dog     | M    |          3 |
| bird    | F    |          1 |
| snake   | M    |          1 |
+---------+------+------------+
6 rows in set (0.00 sec)

mysql> select species, sex, count(*) from pet where sex is not null group by species, sex;
+---------+------+----------+
| species | sex  | count(*) |
+---------+------+----------+
| cat     | F    |        1 |
| cat     | M    |        1 |
| dog     | F    |        1 |
| dog     | M    |        3 |
| bird    | F    |        1 |
| snake   | M    |        1 |
+---------+------+----------+
6 rows in set (0.00 sec)

If you name columns to select in addition to the COUNT() value, a GROUP BY clause should be present that names those same columns. Otherwise, the following occurs:

If the ONLY_FULL_GROUP_BY SQL mode is enabled, an error occurs:

mysql> SET sql_mode = 'ONLY_FULL_GROUP_BY';
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT owner, COUNT(*) FROM pet;
ERROR 1140 (42000): In aggregated query without GROUP BY, expression
#1 of SELECT list contains nonaggregated column 'menagerie.pet.owner';
this is incompatible with sql_mode=only_full_group_by
If ONLY_FULL_GROUP_BY is not enabled, the query is processed by treating all rows as a single group, but the value selected for each named column is nondeterministic. The server is free to select the value from any row:

mysql> SET sql_mode = '';
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT owner, COUNT(*) FROM pet;
+--------+----------+
| owner  | COUNT(*) |
+--------+----------+
| Harold |        8 |
+--------+----------+
1 row in set (0.00 sec)

See also Section 12.20.3, “MySQL Handling of GROUP BY”. See Section 12.20.1, “Aggregate Function Descriptions” for information about COUNT(expr) behavior and related optimizations.

3.3.4.9 Using More Than one Table
---------------------------------
The pet table keeps track of which pets you have. If you want to record other information about them, such as events in their lives like visits to the vet or when litters are born, you need another table. What should this table look like? It needs to contain the following information:

The pet name so that you know which animal each event pertains to.
A date so that you know when the event occurred.
A field to describe the event.
An event type field, if you want to be able to categorize events.
Given these considerations, the CREATE TABLE statement for the event table might look like this:

mysql> create table event (name varchar(20), date DATE, type varchar(15), remark varchar(255));
Query OK, 0 rows affected (0.02 sec)

mysql> SET GLOBAL local_infile = 1;
mysql> load data local infile '/Users/utsav/Desktop/repos/SQLLearning/te.csv' into table event  fields terminated by '|';

Based on what you have learned from the queries that you have run on the pet table, you should be able to perform retrievals on the records in the event table; the principles are the same. But when is the event table by itself insufficient to answer questions you might ask?

Suppose that you want to find out the ages at which each pet had its litters. We saw earlier how to calculate ages from two dates. The litter date of the mother is in the event table, but to calculate her age on that date you need her birth date, which is stored in the pet table. This means the query requires both tables:

mysql> select pet.name, TIMESTAMPDIFF(YEAR, birth, date) as age, remark
    -> from pet join event on pet.name = event.name
    -> where event.type = 'litter';

OR
mysql> select p.name, TIMESTAMPDIFF(YEAR, p.birth, e.date) as age, e.remark
from pet p
join event e
on p.name=e.name
where e.type='litter';

There are several things to note about this query:

The FROM clause joins two tables because the query needs to pull information from both of them.

When combining (joining) information from multiple tables, you need to specify how records in one table can be matched to records in the other. This is easy because they both have a name column. The query uses an ON clause to match up records in the two tables based on the name values.

The query uses an INNER JOIN to combine the tables. An INNER JOIN permits rows from either table to appear in the result if and only if both tables meet the conditions specified in the ON clause. In this example, the ON clause specifies that the name column in the pet table must match the name column in the event table. If a name appears in one table but not the other, the row does not appear in the result because the condition in the ON clause fails.

Because the name column occurs in both tables, you must be specific about which table you mean when referring to the column. This is done by prepending the table name to the column name.

You need not have two different tables to perform a join. Sometimes it is useful to join a table to itself, if you want to compare records in a table to other records in that same table. For example, to find breeding pairs among your pets, you can join the pet table with itself to produce candidate pairs of live males and females of like species:

select p1.name, p1.sex, p2.name, p2.sex, p1.species
from pet p1
join pet p2
on p1.species = p2.species
and p1.sex = 'f' AND p1.death is null
and p2.sex = 'm' AND p2.death is null;

OR
SELECT p1.name, p1.sex, p2.name, p2.sex, p1.species
       FROM pet AS p1 INNER JOIN pet AS p2
         ON p1.species = p2.species
         AND p1.sex = 'f' AND p1.death IS NULL
         AND p2.sex = 'm' AND p2.death IS NULL;

In this query, we specify aliases for the table name to refer to the columns and keep straight which instance of the table each column reference is associated with.

3.4 Getting Information About Databases and Tables
---------------------------------------------------
What if you forget the name of a database or table, or what the structure of a given table is (for example, what its columns are called)? MySQL addresses this problem through several statements that provide information about the databases and tables it supports.

You have previously seen SHOW DATABASES, which lists the databases managed by the server. To find out which database is currently selected, use the DATABASE() function:

mysql> use menagerie;
Database changed
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| menagerie          |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
6 rows in set (0.00 sec)

mysql> select database();
+------------+
| database() |
+------------+
| menagerie  |
+------------+
1 row in set (0.00 sec)

If you have not yet selected any database, the result is NULL.

To find out what tables the default database contains (for example, when you are not sure about the name of a table), use this statement:
mysql> show tables;
+---------------------+
| Tables_in_menagerie |
+---------------------+
| event               |
| mytable             |
| pet                 |
+---------------------+
3 rows in set (0.00 sec)

The name of the column in the output produced by this statement is always Tables_in_db_name, where db_name is the name of the database. See Section 13.7.7.39, “SHOW TABLES Statement”, for more information.

If you want to find out about the structure of a table, the DESCRIBE statement is useful; it displays information about each of a table's columns:
mysql> describe pet;
+---------+---------------+------+-----+---------+-------+
| Field   | Type          | Null | Key | Default | Extra |
+---------+---------------+------+-----+---------+-------+
| name    | varchar(20)   | YES  |     | NULL    |       |
| owner   | varchar(20)   | YES  |     | NULL    |       |
| species | varchar(20)   | YES  |     | NULL    |       |
| sex     | enum('M','F') | YES  |     | NULL    |       |
| birth   | date          | YES  |     | NULL    |       |
| death   | date          | YES  |     | NULL    |       |
+---------+---------------+------+-----+---------+-------+
6 rows in set (0.02 sec)

Field indicates the column name, Type is the data type for the column, NULL indicates whether the column can contain NULL values, Key indicates whether the column is indexed, and Default specifies the column's default value. Extra displays special information about columns: If a column was created with the AUTO_INCREMENT option, the value is auto_increment rather than empty.

DESC is a short form of DESCRIBE. See Section 13.8.1, “DESCRIBE Statement”, for more information.

mysql> desc pet;
+---------+---------------+------+-----+---------+-------+
| Field   | Type          | Null | Key | Default | Extra |
+---------+---------------+------+-----+---------+-------+
| name    | varchar(20)   | YES  |     | NULL    |       |
| owner   | varchar(20)   | YES  |     | NULL    |       |
| species | varchar(20)   | YES  |     | NULL    |       |
| sex     | enum('M','F') | YES  |     | NULL    |       |
| birth   | date          | YES  |     | NULL    |       |
| death   | date          | YES  |     | NULL    |       |
+---------+---------------+------+-----+---------+-------+
6 rows in set (0.01 sec)

You can obtain the CREATE TABLE statement necessary to create an existing table using the SHOW CREATE TABLE statement. See Section 13.7.7.10, “SHOW CREATE TABLE Statement”.

If you have indexes on a table, SHOW INDEX FROM tbl_name produces information about them. See Section 13.7.7.22, “SHOW INDEX Statement”, for more about this statement.

mysql> show create table;
mysql> show index from pet;

3.5 Using mysql in Batch Mode
------------------------------
In the previous sections, you used mysql interactively to enter statements and view the results. You can also run mysql in batch mode. To do this, put the statements you want to run in a file, then tell mysql to read its input from the file:
3.5 Using mysql in Batch Mode

In the previous sections, you used mysql interactively to enter statements and view the results. You can also run mysql in batch mode. To do this, put the statements you want to run in a file, then tell mysql to read its input from the file:

shell> mysql < batch-file
If you are running mysql under Windows and have some special characters in the file that cause problems, you can do this:

C:\> mysql -e "source batch-file"
If you need to specify connection parameters on the command line, the command might look like this:

shell> mysql -h host -u user -p < batch-file
Enter password: ********

Example:
(base) Utsavs-MacBook-Air:~ utsav$ mysql < /Users/utsav/Desktop/repos/SQLLearning/batch-file.sql
(base) Utsavs-MacBook-Air:~ utsav$ mysql -u root -p < /Users/utsav/Desktop/repos/SQLLearning/batch-file.sql
Enter password:
name	owner	species	sex	birth	death
Fluffy	Harold	cat	F	1993-02-04	NULL
Claws	Gwen	cat	M	1994-03-17	NULL
Buffy	Harold	dog	F	1989-05-13	NULL
Fang	Benny	dog	M	1990-08-27	NULL
Bowser	Diane	dog	M	1989-08-31	1995-07-29
Chirpy	Gwen	bird	F	1998-09-11	NULL
Whistler	Gwen	bird	NULL	1997-12-09	NULL
Slim	Benny	snake	M	1996-04-29	NULL
bruzo	Chinku	dog	M	2019-01-04	NULL

When you use mysql this way, you are creating a script file, then executing the script.

If you want the script to continue even if some of the statements in it produce errors, you should use the --force command-line option.

Why use a script? Here are a few reasons:

If you run a query repeatedly (say, every day or every week), making it a script enables you to avoid retyping it each time you execute it.

You can generate new queries from existing ones that are similar by copying and editing script files.

Batch mode can also be useful while you're developing a query, particularly for multiple-line statements or multiple-statement sequences. If you make a mistake, you don't have to retype everything. Just edit your script to correct the error, then tell mysql to execute it again.

If you have a query that produces a lot of output, you can run the output through a pager rather than watching it scroll off the top of your screen:

shell> mysql < batch-file | more
You can catch the output in a file for further processing:


shell> mysql < batch-file > mysql.out

Example:
(base) Utsavs-MacBook-Air:~ utsav$ mysql -u root -p  < /Users/utsav/Desktop/repos/SQLLearning/batch-file.sql > /Users/utsav/Desktop/repos/SQLLearning/batch-file_output.csv
Enter password:

If you want to get the interactive output format in batch mode, use mysql -t. To echo to the output the statements that are executed, use mysql -v.
(base) Utsavs-MacBook-Air:~ utsav$ mysql -u root -p  -t < /Users/utsav/Desktop/repos/SQLLearning/batch-file.sql
Enter password:
+----------+--------+---------+------+------------+------------+
| name     | owner  | species | sex  | birth      | death      |
+----------+--------+---------+------+------------+------------+
| Fluffy   | Harold | cat     | F    | 1993-02-04 | NULL       |
| Claws    | Gwen   | cat     | M    | 1994-03-17 | NULL       |
| Buffy    | Harold | dog     | F    | 1989-05-13 | NULL       |
| Fang     | Benny  | dog     | M    | 1990-08-27 | NULL       |
| Bowser   | Diane  | dog     | M    | 1989-08-31 | 1995-07-29 |
| Chirpy   | Gwen   | bird    | F    | 1998-09-11 | NULL       |
| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |
| Slim     | Benny  | snake   | M    | 1996-04-29 | NULL       |
| bruzo    | Chinku | dog     | M    | 2019-01-04 | NULL       |
+----------+--------+---------+------+------------+------------+

(base) Utsavs-MacBook-Air:~ utsav$ mysql -u root -p  -t -v < /Users/utsav/Desktop/repos/SQLLearning/batch-file.sql
Enter password:
--------------
select * from pet limit 2
--------------

+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | F    | 1993-02-04 | NULL  |
| Claws  | Gwen   | cat     | M    | 1994-03-17 | NULL  |
+--------+--------+---------+------+------------+-------+
--------------
show tables
--------------

+---------------------+
| Tables_in_menagerie |
+---------------------+
| event               |
| mytable             |
| pet                 |
+---------------------+
--------------
select * from event limit 2
--------------

+--------+------------+--------+-----------------------------+
| name   | date       | type   | remark                      |
+--------+------------+--------+-----------------------------+
| Fluffy | 1995-05-15 | litter | 4 kittens, 3 female, 1 male |
| Buffy  | 1993-06-23 | litter | 5 puppies, 2 female, 3 male |
+--------+------------+--------+-----------------------------+

You can also use scripts from the mysql prompt by using the source command or \. command(# Don't terminate with semi-colon):
mysql> source /Users/utsav/Desktop/repos/SQLLearning/batch-file.sql
Database changed
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | F    | 1993-02-04 | NULL  |
| Claws  | Gwen   | cat     | M    | 1994-03-17 | NULL  |
+--------+--------+---------+------+------------+-------+
2 rows in set (0.00 sec)

+---------------------+
| Tables_in_menagerie |
+---------------------+
| event               |
| mytable             |
| pet                 |
+---------------------+
3 rows in set (0.00 sec)

+--------+------------+--------+-----------------------------+
| name   | date       | type   | remark                      |
+--------+------------+--------+-----------------------------+
| Fluffy | 1995-05-15 | litter | 4 kittens, 3 female, 1 male |
| Buffy  | 1993-06-23 | litter | 5 puppies, 2 female, 3 male |
+--------+------------+--------+-----------------------------+
2 rows in set (0.00 sec)

mysql> \. /Users/utsav/Desktop/repos/SQLLearning/batch-file.sql # Don't terminate with semi-colon
Database changed
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | F    | 1993-02-04 | NULL  |
| Claws  | Gwen   | cat     | M    | 1994-03-17 | NULL  |
+--------+--------+---------+------+------------+-------+
2 rows in set (0.00 sec)

+---------------------+
| Tables_in_menagerie |
+---------------------+
| event               |
| mytable             |
| pet                 |
+---------------------+
3 rows in set (0.00 sec)

+--------+------------+--------+-----------------------------+
| name   | date       | type   | remark                      |
+--------+------------+--------+-----------------------------+
| Fluffy | 1995-05-15 | litter | 4 kittens, 3 female, 1 male |
| Buffy  | 1993-06-23 | litter | 5 puppies, 2 female, 3 male |
+--------+------------+--------+-----------------------------+
2 rows in set (0.00 sec)

mysql> source filename;
mysql> \. filename
See Section 4.5.1.5, “Executing SQL Statements from a Text File”, for more information.

3.6 Examples of Common Queries
-------------------------------
Here are examples of how to solve some common problems with MySQL.

Some of the examples use the table shop to hold the price of each article (item number) for certain traders (dealers). Supposing that each trader has a single fixed price per article, then (article, dealer) is a primary key for the records.

Start the command-line tool mysql and select a database:
To create and populate the example table, use these statements:
create table shop(
	article INT UNSIGNED  DEFAULT '0000' NOT NULL,
    dealer  CHAR(20)      DEFAULT ''     NOT NULL,
    price   DECIMAL(16,2) DEFAULT '0.00' NOT NULL,
	PRIMARY KEY(article, dealer)
);

INSERT INTO shop
VALUES (1,'A',3.45),(1,'B',3.99),(2,'A',10.99),(3,'B',1.45),
	(3,'C',1.69),(3,'D',1.25),(4,'D',19.95);

After issuing the statements, the table should have the following contents:
mysql> select * from shop order by article;
+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|       1 | A      |  3.45 |
|       1 | B      |  3.99 |
|       2 | A      | 10.99 |
|       3 | B      |  1.45 |
|       3 | C      |  1.69 |
|       3 | D      |  1.25 |
|       4 | D      | 19.95 |
+---------+--------+-------+
7 rows in set (0.00 sec)

3.6.1 The Maximum Value for a Column

“What is the highest item number?”
mysql> select MAX(article) as article from shop;
+---------+
| article |
+---------+
|       4 |
+---------+
1 row in set (0.01 sec)

3.6.2 The Row Holding the Maximum of a Certain Column

Task: Find the number, dealer, and price of the most expensive article.
mysql> select * from shop where price=(select max(price) from shop);
+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|       4 | D      | 19.95 |
+---------+--------+-------+
1 row in set (0.00 sec)

mysql> select * from shop order by price desc limit 1;
+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|       4 | D      | 19.95 |
+---------+--------+-------+
1 row in set (0.00 sec)

mysql> select s1.article, s1.dealer, s1.price from shop s1 left join shop s2 on s1.price < s2.price where s2.article is null;
+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|       4 | D      | 19.95 |
+---------+--------+-------+
1 row in set (0.00 sec)

Note
If there were several most expensive articles, each with a price of 19.95, the LIMIT solution would show only one of them.

3.6.3 Maximum of Column per Group
Task: Find the highest price per article.
mysql> select article, max(price) as price from shop group by article order by article;
+---------+-------+
| article | price |
+---------+-------+
|       1 |  3.99 |
|       2 | 10.99 |
|       3 |  1.69 |
|       4 | 19.95 |
+---------+-------+
4 rows in set (0.00 sec)

3.6.4 The Rows Holding the Group-wise Maximum of a Certain Column
Task: For each article, find the dealer or dealers with the most expensive price.

mysql> select * from shop where price in (select max(price) as price from shop group by article);
+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|       1 | B      |  3.99 |
|       2 | A      | 10.99 |
|       3 | C      |  1.69 |
|       4 | D      | 19.95 |
+---------+--------+-------+
4 rows in set (0.00 sec)

select * from shop s1 where price = (select max(s2.price) from shop s2 where s1.article=s2.article) order by article;

The preceding example uses a correlated subquery, which can be inefficient (see Section 13.2.11.7, “Correlated Subqueries”). Other possibilities for solving the problem are to use an uncorrelated subquery in the FROM clause, a LEFT JOIN, or a common table expression with a window function.

Uncorrelated subquery:
select * from shop as s1
JOIN (select article, max(price) as price from shop group by article) as s2
on s1.article=s2.article AND s1.price=s2.price
order by s1.article;

LEFT JOIN
select s1.article, s1.dealer, s1.price, s2.article from shop s1
left join shop s2
on s1.price < s2.price AND s1.article = s2.article
where s2.article is null
order by s1.article;

The LEFT JOIN works on the basis that when s1.price is at its maximum value, there is no s2.price with a greater value and thus the corresponding s2.article value is NULL. See Section 13.2.10.2, “JOIN Clause”.

3.6.5 Using User-Defined Variables

You can employ MySQL user variables to remember results without having to store them in temporary variables in the client. (See Section 9.4, “User-Defined Variables”.)

For example, to find the articles with the highest and lowest price you can do this:
select @min_price:=MIN(price), @max_price:=MAX(price) FROM shop;
select * from shop where price=@min_price or price=@max_price;

Note
It is also possible to store the name of a database object such as a table or a column in a user variable and then to use this variable in an SQL statement; however, this requires the use of a prepared statement. See Section 13.5, “Prepared Statements”, for more information.

3.6.6 Using Foreign Keys
==========================
In MySQL, InnoDB tables support checking of foreign key constraints. See Chapter 15, The InnoDB Storage Engine, and Section 1.7.2.3, “FOREIGN KEY Constraint Differences”.
In MySQL, InnoDB tables support checking of foreign key constraints. See Chapter 15, The InnoDB Storage Engine, and Section 1.7.2.3, “FOREIGN KEY Constraint Differences”.

A foreign key constraint is not required merely to join two tables. For storage engines other than InnoDB, it is possible when defining a column to use a REFERENCES tbl_name(col_name) clause, which has no actual effect, and serves only as a memo or comment to you that the column which you are currently defining is intended to refer to a column in another table. It is extremely important to realize when using this syntax that:

MySQL does not perform any sort of check to make sure that col_name actually exists in tbl_name (or even that tbl_name itself exists).

MySQL does not perform any sort of action on tbl_name such as deleting rows in response to actions taken on rows in the table which you are defining; in other words, this syntax induces no ON DELETE or ON UPDATE behavior whatsoever. (Although you can write an ON DELETE or ON UPDATE clause as part of the REFERENCES clause, it is also ignored.)

This syntax creates a column; it does not create any sort of index or key.

create table person (
	id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    name VARCHAR(60) NOT NULL,
    PRIMARY KEY (id)
);

CREATE TABLE shirt(
	id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    style ENUM('t-shirt', 'polo', 'dress') NOT NULL,
    color ENUM('red', 'blue', 'orange', 'white', 'black') NOT NULL,
    owner SMALLINT UNSIGNED NOT NULL REFERENCES person(id),
    PRIMARY KEY (id)
);

INSERT INTO person VALUES(NULL,'Antonio Paz');
SELECT @last := LAST_INSERT_ID();

INSERT INTO shirt VALUES
(NULL, 'polo', 'blue', @last),
(NULL, 'dress', 'white', @last),
(NULL, 't-shirt', 'blue', @last);

INSERT INTO person VALUES(NULL,'Lilliana Angelovska');
SELECT @last := LAST_INSERT_ID();

INSERT INTO shirt VALUES
(NULL, 'dress', 'orange', @last),
(NULL, 'polo', 'red', @last),
(NULL, 'dress', 'blue', @last),
(NULL, 't-shirt', 'white', @last);

Fetch all rows from person and shirt table where name is Lilliana and color is not white.
select s.* from person p
join shirt s
on s.owner = p.id
where p.name like 'Lilliana%' and s.color <> 'white';

When used in this fashion, the REFERENCES clause is not displayed in the output of SHOW CREATE TABLE or DESCRIBE:
mysql> show create table shirt\G
*************************** 1. row ***************************
       Table: shirt
Create Table: CREATE TABLE `shirt` (
  `id` smallint(5) unsigned NOT NULL AUTO_INCREMENT,
  `style` enum('t-shirt','polo','dress') NOT NULL,
  `color` enum('red','blue','orange','white','black') NOT NULL,
  `owner` smallint(5) unsigned NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
1 row in set (0.00 sec)

mysql> show create table shirt;
+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table | Create Table                                                                                                                                                                                                                                                                                                                                     |
+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| shirt | CREATE TABLE `shirt` (
  `id` smallint(5) unsigned NOT NULL AUTO_INCREMENT,
  `style` enum('t-shirt','polo','dress') NOT NULL,
  `color` enum('red','blue','orange','white','black') NOT NULL,
  `owner` smallint(5) unsigned NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |
+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.01 sec)

The use of REFERENCES in this way as a comment or “reminder” in a column definition works with MyISAM tables.

Inorder to see REFERENCES in show create table, the table should be created as:
CREATE TABLE shirt(
	id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    style ENUM('t-shirt', 'polo', 'dress') NOT NULL,
    color ENUM('red', 'blue', 'orange', 'white', 'black') NOT NULL,
    owner SMALLINT UNSIGNED NOT NULL,
    PRIMARY KEY (id),
    FOREIGN KEY (owner) REFERENCES person(id) ON DELETE CASCADE
);

mysql> show create table shirt\G
*************************** 1. row ***************************
       Table: shirt
Create Table: CREATE TABLE `shirt` (
  `id` smallint(5) unsigned NOT NULL AUTO_INCREMENT,
  `style` enum('t-shirt','polo','dress') NOT NULL,
  `color` enum('red','blue','orange','white','black') NOT NULL,
  `owner` smallint(5) unsigned NOT NULL,
  PRIMARY KEY (`id`),
  KEY `owner` (`owner`),
  CONSTRAINT `shirt_ibfk_1` FOREIGN KEY (`owner`) REFERENCES `person` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
1 row in set (0.00 sec)

3.6.7 Searching on Two Keys
===========================
An OR using a single key is well optimized, as is the handling of AND.

The one tricky case is that of searching on two different keys combined with OR:

SELECT field1_index, field2_index FROM test_table
WHERE field1_index = '1' OR  field2_index = '1'
This case is optimized. See Section 8.2.1.3, “Index Merge Optimization”.

You can also solve the problem efficiently by using a UNION that combines the output of two separate SELECT statements. See Section 13.2.10.3, “UNION Clause”.

Each SELECT searches only one key and can be optimized:

SELECT field1_index, field2_index
    FROM test_table WHERE field1_index = '1'
UNION
SELECT field1_index, field2_index
    FROM test_table WHERE field2_index = '1';

OR query normally seems to be faster than UNION, tested on small table.

3.6.8 Calculating Visits Per Day
=================================
The following example shows how you can use the bit group functions to calculate the number of days per month a user has visited a Web page.
create table t1(
	year YEAR,
    month TINYINT UNSIGNED,
    day TINYINT UNSIGNED
);

INSERT INTO t1 VALUES(2000,1,1),(2000,1,20),(2000,1,30),(2000,2,2),
            (2000,2,23),(2000,2,23);

select * from t1;

The example table contains year-month-day values representing visits by users to the page. To determine how many different days in each month these visits occur, use this query:
mysql> select year, month, bit_count(BIT_OR(1<<day)) as days  from t1 group by year, month;
+------+-------+------+
| year | month | days |
+------+-------+------+
| 2000 |     1 |    3 |
| 2000 |     2 |    2 |
+------+-------+------+
2 rows in set (0.00 sec)

The query calculates how many different days appear in the table for each year/month combination, with automatic removal of duplicate entries.


3.6.9 Using AUTO_INCREMENT
===========================
The AUTO_INCREMENT attribute can be used to generate a unique identity for new rows:

CREATE TABLE animals (
     id MEDIUMINT NOT NULL AUTO_INCREMENT,
     name CHAR(30) NOT NULL,
     PRIMARY KEY (id)
);

INSERT INTO animals (name) VALUES
    ('dog'),('cat'),('penguin'),
    ('lax'),('whale'),('ostrich');

SELECT * FROM animals;

No value was specified for the AUTO_INCREMENT column, so MySQL assigned sequence numbers automatically. You can also explicitly assign 0 to the column to generate sequence numbers, unless the NO_AUTO_VALUE_ON_ZERO SQL mode is enabled. For example:
INSERT INTO animals (id,name) VALUES(0,'groundhog');

If the column is declared NOT NULL, it is also possible to assign NULL to the column to generate sequence numbers. For example
INSERT INTO animals (id,name) VALUES(NULL,'squirrel');

When you insert any other value into an AUTO_INCREMENT column, the column is set to that value and the sequence is reset so that the next automatically generated value follows sequentially from the largest column value. For example:

INSERT INTO animals (id,name) VALUES(100,'rabbit');
INSERT INTO animals (id,name) VALUES(NULL,'mouse');
SELECT * FROM animals;
+-----+-----------+
| id  | name      |
+-----+-----------+
|   1 | dog       |
|   2 | cat       |
|   3 | penguin   |
|   4 | lax       |
|   5 | whale     |
|   6 | ostrich   |
|   7 | groundhog |
|   8 | squirrel  |
| 100 | rabbit    |
| 101 | mouse     |
+-----+-----------+

Updating an existing AUTO_INCREMENT column value also resets the AUTO_INCREMENT sequence.

You can retrieve the most recent automatically generated AUTO_INCREMENT value with the LAST_INSERT_ID() SQL function or the mysql_insert_id() C API function. These functions are connection-specific, so their return values are not affected by another connection which is also performing inserts.

Use the smallest integer data type for the AUTO_INCREMENT column that is large enough to hold the maximum sequence value you require. When the column reaches the upper limit of the data type, the next attempt to generate a sequence number fails. Use the UNSIGNED attribute if possible to allow a greater range. For example, if you use TINYINT, the maximum permissible sequence number is 127. For TINYINT UNSIGNED, the maximum is 255. See Section 11.1.2, “Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT” for the ranges of all the integer types.


Note
For a multiple-row insert, LAST_INSERT_ID() and mysql_insert_id() actually return the AUTO_INCREMENT key from the first of the inserted rows. This enables multiple-row inserts to be reproduced correctly on other servers in a replication setup.

To start with an AUTO_INCREMENT value other than 1, set that value with CREATE TABLE or ALTER TABLE, like this:

mysql> ALTER TABLE tbl AUTO_INCREMENT = 100;

InnoDB Notes
For information about AUTO_INCREMENT usage specific to InnoDB, see Section 15.6.1.6, “AUTO_INCREMENT Handling in InnoDB”.

MyISAM Notes

For MyISAM tables, you can specify AUTO_INCREMENT on a secondary column in a multiple-column index. In this case, the generated value for the AUTO_INCREMENT column is calculated as MAX(auto_increment_column) + 1 WHERE prefix=given-prefix. This is useful when you want to put data into ordered groups.

CREATE TABLE animals (
    grp ENUM('fish','mammal','bird') NOT NULL,
    id MEDIUMINT NOT NULL AUTO_INCREMENT,
    name CHAR(30) NOT NULL,
    PRIMARY KEY (grp,id)
) ENGINE=MyISAM;

INSERT INTO animals (grp,name) VALUES
    ('mammal','dog'),('mammal','cat'),
    ('bird','penguin'),('fish','lax'),('mammal','whale'),
    ('bird','ostrich');

SELECT * FROM animals ORDER BY grp,id;
Which returns:

+--------+----+---------+
| grp    | id | name    |
+--------+----+---------+
| fish   |  1 | lax     |
| mammal |  1 | dog     |
| mammal |  2 | cat     |
| mammal |  3 | whale   |
| bird   |  1 | penguin |
| bird   |  2 | ostrich |
+--------+----+---------+

In this case (when the AUTO_INCREMENT column is part of a multiple-column index), AUTO_INCREMENT values are reused if you delete the row with the biggest AUTO_INCREMENT value in any group. This happens even for MyISAM tables, for which AUTO_INCREMENT values normally are not reused.

If the AUTO_INCREMENT column is part of multiple indexes, MySQL generates sequence values using the index that begins with the AUTO_INCREMENT column, if there is one. For example, if the animals table contained indexes PRIMARY KEY (grp, id) and INDEX (id), MySQL would ignore the PRIMARY KEY for generating sequence values. As a result, the table would contain a single sequence, not a sequence per grp value.

Further Reading

More information about AUTO_INCREMENT is available here:

How to assign the AUTO_INCREMENT attribute to a column: Section 13.1.20, “CREATE TABLE Statement”, and Section 13.1.9, “ALTER TABLE Statement”.

How AUTO_INCREMENT behaves depending on the NO_AUTO_VALUE_ON_ZERO SQL mode: Section 5.1.11, “Server SQL Modes”.

How to use the LAST_INSERT_ID() function to find the row that contains the most recent AUTO_INCREMENT value: Section 12.16, “Information Functions”.

Setting the AUTO_INCREMENT value to be used: Section 5.1.8, “Server System Variables”.

Section 15.6.1.6, “AUTO_INCREMENT Handling in InnoDB”

AUTO_INCREMENT and replication: Section 17.5.1.1, “Replication and AUTO_INCREMENT”.

Server-system variables related to AUTO_INCREMENT (auto_increment_increment and auto_increment_offset) that can be used for replication: Section 5.1.8, “Server System Variables”.


3.7 Using MySQL with Apache
============================
There are programs that let you authenticate your users from a MySQL database and also let you write your log files into a MySQL table.

You can change the Apache logging format to be easily readable by MySQL by putting the following into the Apache configuration file:

LogFormat \
        "\"%h\",%{%Y%m%d%H%M%S}t,%>s,\"%b\",\"%{Content-Type}o\",  \
        \"%U\",\"%{Referer}i\",\"%{User-Agent}i\""
To load a log file in that format into MySQL, you can use a statement something like this:

LOAD DATA INFILE '/local/access_log' INTO TABLE tbl_name
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' ESCAPED BY '\\'
The named table should be created to have columns that correspond to those that the LogFormat line writes to the log file.

Chapter 4 MySQL Programs
=========================
This chapter provides a brief overview of the MySQL command-line programs provided by Oracle Corporation. It also discusses the general syntax for specifying options when you run these programs. Most programs have options that are specific to their own operation, but the option syntax is similar for all of them. Finally, the chapter provides more detailed descriptions of individual programs, including which options they recognize.

4.2.2.1 Using Options on the Command Line
For a long option that takes a value, separate the option name and the value by an = sign. For a short option that takes a value, the option value can immediately follow the option letter, or there can be a space between: -hlocalhost and -h localhost are equivalent. An exception to this rule is the option for specifying your MySQL password. This option can be given in long form as --password=pass_val or as --password. In the latter case (with no password value given), the program interactively prompts you for the password. The password option also may be given in short form as -ppass_val or as -p. However, for the short form, if the password value is given, it must follow the option letter with no intervening space: If a space follows the option letter, the program has no way to tell whether a following argument is supposed to be the password value or some other kind of argument. Consequently, the following two commands have two completely different meanings:

mysql -ptest
mysql -p test
The first command instructs mysql to use a password value of test, but specifies no default database. The second instructs mysql to prompt for the password value and to use test as the default database.

Within option names, dash (-) and underscore (_) may be used interchangeably. For example, --skip-grant-tables and --skip_grant_tables are equivalent. (However, the leading dashes cannot be given as underscores.)

The MySQL server has certain command options that may be specified only at startup, and a set of system variables, some of which may be set at startup, at runtime, or both. System variable names use underscores rather than dashes, and when referenced at runtime (for example, using SET or SELECT statements), must be written using underscores:

SET GLOBAL general_log = ON;
SELECT @@GLOBAL.general_log;

At server startup, the syntax for system variables is the same as for command options, so within variable names, dashes and underscores may be used interchangeably. For example, --general_log=ON and --general-log=ON are equivalent. (This is also true for system variables set within option files.)

For options that take a numeric value, the value can be given with a suffix of K, M, or G to indicate a multiplier of 1024, 10242 or 10243. As of MySQL 8.0.14, a suffix can also be T, P, and E to indicate a multiplier of 10244, 10245 or 10246. Suffix letters can be uppercase or lowercase.

For example, the following command tells mysqladmin to ping the server 1024 times, sleeping 10 seconds between each ping:

mysqladmin --count=1K --sleep=10 ping
When specifying file names as option values, avoid the use of the ~ shell metacharacter. It might not be interpreted as you expect.

Option values that contain spaces must be quoted when given on the command line. For example, the --execute (or -e) option can be used with mysql to pass one or more semicolon-separated SQL statements to the server. When this option is used, mysql executes the statements in the option value and exits. The statements must be enclosed by quotation marks. For example:
(base) Utsavs-MacBook-Air:~ utsav$ mysql -u root -p --local-infile menagerie -e "SELECT VERSION(); SELECT NOW()"
Enter password:
+-----------+
| VERSION() |
+-----------+
| 8.0.18    |
+-----------+
+---------------------+
| NOW()               |
+---------------------+
| 2021-07-11 08:44:52 |
+---------------------+
(base) Utsavs-MacBook-Air:~ utsav$

Note
The long form (--execute) is followed by an equal sign (=).

To use quoted values within a statement, you must either escape the inner quotation marks, or use a different type of quotation marks within the statement from those used to quote the statement itself. The capabilities of your command processor dictate your choices for whether you can use single or double quotation marks and the syntax for escaping quote characters. For example, if your command processor supports quoting with single or double quotation marks, you can use double quotation marks around the statement, and single quotation marks for any quoted values within the statement.

mysql> select user();
+----------------+
| user()         |
+----------------+
| root@localhost |
+----------------+
1 row in set (0.00 sec)

Chapter 8 Optimization
======================
This chapter explains how to optimize MySQL performance and provides examples. Optimization involves configuring, tuning, and measuring performance, at several levels. Depending on your job role (developer, DBA, or a combination of both), you might optimize at the level of individual SQL statements, entire applications, a single database server, or multiple networked database servers. Sometimes you can be proactive and plan in advance for performance, while other times you might troubleshoot a configuration or code issue after a problem occurs. Optimizing CPU and memory usage can also improve scalability, allowing the database to handle more load without slowing down.

8.1 Optimization Overview

Database performance depends on several factors at the database level, such as tables, queries, and configuration settings. These software constructs result in CPU and I/O operations at the hardware level, which you must minimize and make as efficient as possible. As you work on database performance, you start by learning the high-level rules and guidelines for the software side, and measuring performance using wall-clock time. As you become an expert, you learn more about what happens internally, and start measuring things such as CPU cycles and I/O operations.

Typical users aim to get the best database performance out of their existing software and hardware configurations. Advanced users look for opportunities to improve the MySQL software itself, or develop their own storage engines and hardware appliances to expand the MySQL ecosystem.

Optimizing at the Database Level

Optimizing at the Hardware Level

Balancing Portability and Performance

Optimizing at the Database Level

The most important factor in making a database application fast is its basic design:

Are the tables structured properly? In particular, do the columns have the right data types, and does each table have the appropriate columns for the type of work? For example, applications that perform frequent updates often have many tables with few columns, while applications that analyze large amounts of data often have few tables with many columns.

Are the right indexes in place to make queries efficient?

Are you using the appropriate storage engine for each table, and taking advantage of the strengths and features of each storage engine you use? In particular, the choice of a transactional storage engine such as InnoDB or a nontransactional one such as MyISAM can be very important for performance and scalability.

Note
InnoDB is the default storage engine for new tables. In practice, the advanced InnoDB performance features mean that InnoDB tables often outperform the simpler MyISAM tables, especially for a busy database.

Does each table use an appropriate row format? This choice also depends on the storage engine used for the table. In particular, compressed tables use less disk space and so require less disk I/O to read and write the data. Compression is available for all kinds of workloads with InnoDB tables, and for read-only MyISAM tables.

Does the application use an appropriate locking strategy? For example, by allowing shared access when possible so that database operations can run concurrently, and requesting exclusive access when appropriate so that critical operations get top priority. Again, the choice of storage engine is significant. The InnoDB storage engine handles most locking issues without involvement from you, allowing for better concurrency in the database and reducing the amount of experimentation and tuning for your code.

Are all memory areas used for caching sized correctly? That is, large enough to hold frequently accessed data, but not so large that they overload physical memory and cause paging. The main memory areas to configure are the InnoDB buffer pool and the MyISAM key cache.

Optimizing at the Hardware Level

Any database application eventually hits hardware limits as the database becomes more and more busy. A DBA must evaluate whether it is possible to tune the application or reconfigure the server to avoid these bottlenecks, or whether more hardware resources are required. System bottlenecks typically arise from these sources:

Disk seeks. It takes time for the disk to find a piece of data. With modern disks, the mean time for this is usually lower than 10ms, so we can in theory do about 100 seeks a second. This time improves slowly with new disks and is very hard to optimize for a single table. The way to optimize seek time is to distribute the data onto more than one disk.

Disk reading and writing. When the disk is at the correct position, we need to read or write the data. With modern disks, one disk delivers at least 10–20MB/s throughput. This is easier to optimize than seeks because you can read in parallel from multiple disks.

CPU cycles. When the data is in main memory, we must process it to get our result. Having large tables compared to the amount of memory is the most common limiting factor. But with small tables, speed is usually not the problem.

Memory bandwidth. When the CPU needs more data than can fit in the CPU cache, main memory bandwidth becomes a bottleneck. This is an uncommon bottleneck for most systems, but one to be aware of.

Balancing Portability and Performance

To use performance-oriented SQL extensions in a portable MySQL program, you can wrap MySQL-specific keywords in a statement within /*! */ comment delimiters. Other SQL servers ignore the commented keywords. For information about writing comments, see Section 9.7, “Comments”.

8.2 Optimizing SQL Statements
-----------------------------
The core logic of a database application is performed through SQL statements, whether issued directly through an interpreter or submitted behind the scenes through an API. The tuning guidelines in this section help to speed up all kinds of MySQL applications. The guidelines cover SQL operations that read and write data, the behind-the-scenes overhead for SQL operations in general, and operations used in specific scenarios such as database monitoring.

8.2.1 Optimizing SELECT Statements
-----------------------------------
Queries, in the form of SELECT statements, perform all the lookup operations in the database. Tuning these statements is a top priority, whether to achieve sub-second response times for dynamic web pages, or to chop hours off the time to generate huge overnight reports.

Besides SELECT statements, the tuning techniques for queries also apply to constructs such as CREATE TABLE...AS SELECT, INSERT INTO...SELECT, and WHERE clauses in DELETE statements. Those statements have additional performance considerations because they combine write operations with the read-oriented query operations.

NDB Cluster supports a join pushdown optimization whereby a qualifying join is sent in its entirety to NDB Cluster data nodes, where it can be distributed among them and executed in parallel. For more information about this optimization, see Conditions for NDB pushdown joins.

The main considerations for optimizing queries are:

To make a slow SELECT ... WHERE query faster, the first thing to check is whether you can add an index. Set up indexes on columns used in the WHERE clause, to speed up evaluation, filtering, and the final retrieval of results. To avoid wasted disk space, construct a small set of indexes that speed up many related queries used in your application.

Indexes are especially important for queries that reference different tables, using features such as joins and foreign keys. You can use the EXPLAIN statement to determine which indexes are used for a SELECT. See Section 8.3.1, “How MySQL Uses Indexes” and Section 8.8.1, “Optimizing Queries with EXPLAIN”.

Isolate and tune any part of the query, such as a function call, that takes excessive time. Depending on how the query is structured, a function could be called once for every row in the result set, or even once for every row in the table, greatly magnifying any inefficiency.

Minimize the number of full table scans in your queries, particularly for big tables.

Keep table statistics up to date by using the ANALYZE TABLE statement periodically, so the optimizer has the information needed to construct an efficient execution plan.

Learn the tuning techniques, indexing techniques, and configuration parameters that are specific to the storage engine for each table. Both InnoDB and MyISAM have sets of guidelines for enabling and sustaining high performance in queries. For details, see Section 8.5.6, “Optimizing InnoDB Queries” and Section 8.6.1, “Optimizing MyISAM Queries”.

You can optimize single-query transactions for InnoDB tables, using the technique in Section 8.5.3, “Optimizing InnoDB Read-Only Transactions”.

Avoid transforming the query in ways that make it hard to understand, especially if the optimizer does some of the same transformations automatically.

If a performance issue is not easily solved by one of the basic guidelines, investigate the internal details of the specific query by reading the EXPLAIN plan and adjusting your indexes, WHERE clauses, join clauses, and so on. (When you reach a certain level of expertise, reading the EXPLAIN plan might be your first step for every query.)

Adjust the size and properties of the memory areas that MySQL uses for caching. With efficient use of the InnoDB buffer pool, MyISAM key cache, and the MySQL query cache, repeated queries run faster because the results are retrieved from memory the second and subsequent times.

Even for a query that runs fast using the cache memory areas, you might still optimize further so that they require less cache memory, making your application more scalable. Scalability means that your application can handle more simultaneous users, larger requests, and so on without experiencing a big drop in performance.

Deal with locking issues, where the speed of your query might be affected by other sessions accessing the tables at the same time.

INDEX
------
A data structure that provides a fast lookup capability for rows of a table, typically by forming a tree structure (B-tree) representing all the values of a particular column or set of columns.

InnoDB tables always have a clustered index representing the primary key. They can also have one or more secondary indexes defined on one or more columns. Depending on their structure, secondary indexes can be classified as partial, column, or composite indexes.

Indexes are a crucial aspect of query performance. Database architects design tables, queries, and indexes to allow fast lookups for data needed by applications. The ideal database design uses a covering index where practical; the query results are computed entirely from the index, without reading the actual table data. Each foreign key constraint also requires an index, to efficiently check whether values exist in both the parent and child tables.

Although a B-tree index is the most common, a different kind of data structure is used for hash indexes, as in the MEMORY storage engine and the InnoDB adaptive hash index. R-tree indexes are used for spatial indexing of multi-dimensional information.

B-tree
------
A tree data structure that is popular for use in database indexes. The structure is kept sorted at all times, enabling fast lookup for exact matches (equals operator) and ranges (for example, greater than, less than, and BETWEEN operators). This type of index is available for most storage engines, such as InnoDB and MyISAM.

Because B-tree nodes can have many children, a B-tree is not the same as a binary tree, which is limited to 2 children per node.

Contrast with hash index, which is only available in the MEMORY storage engine. The MEMORY storage engine can also use B-tree indexes, and you should choose B-tree indexes for MEMORY tables if some queries use range operators.

The use of the term B-tree is intended as a reference to the general class of index design. B-tree structures used by MySQL storage engines may be regarded as variants due to sophistications not present in a classic B-tree design. For related information, refer to the InnoDB Page Structure Fil Header section of the MySQL Internals Manual.


adaptive hash index
--------------------
An optimization for InnoDB tables that can speed up lookups using = and IN operators, by constructing a hash index in memory. MySQL monitors index searches for InnoDB tables, and if queries could benefit from a hash index, it builds one automatically for index pages that are frequently accessed. In a sense, the adaptive hash index configures MySQL at runtime to take advantage of ample main memory, coming closer to the architecture of main-memory databases. This feature is controlled by the innodb_adaptive_hash_index configuration option. Because this feature benefits some workloads and not others, and the memory used for the hash index is reserved in the buffer pool, typically you should benchmark with this feature both enabled and disabled.

The hash index is always built based on an existing B-tree index on the table. MySQL can build a hash index on a prefix of any length of the key defined for the B-tree, depending on the pattern of searches against the index. A hash index can be partial; the whole B-tree index does not need to be cached in the buffer pool.

In MySQL 5.6 and higher, another way to take advantage of fast single-value lookups with InnoDB tables is to use the InnoDB memcached plugin. See Section 15.20, “InnoDB memcached Plugin” for details.

hash index
----------
A type of index intended for queries that use equality operators, rather than range operators such as greater-than or BETWEEN. It is available for MEMORY tables. Although hash indexes are the default for MEMORY tables for historic reasons, that storage engine also supports B-tree indexes, which are often a better choice for general-purpose queries.

MySQL includes a variant of this index type, the adaptive hash index, that is constructed automatically for InnoDB tables if needed based on runtime conditions.

InnoDB
-------
A MySQL component that combines high performance with transactional capability for reliability, robustness, and concurrent access. It embodies the ACID design philosophy. Represented as a storage engine; it handles tables created or altered with the ENGINE=INNODB clause. See Chapter 15, The InnoDB Storage Engine for architectural details and administration procedures, and Section 8.5, “Optimizing for InnoDB Tables” for performance advice.

In MySQL 5.5 and higher, InnoDB is the default storage engine for new tables and the ENGINE=INNODB clause is not required.

InnoDB tables are ideally suited for hot backups. See Section 30.2, “MySQL Enterprise Backup Overview” for information about the MySQL Enterprise Backup product for backing up MySQL servers without interrupting normal processing.

ACID
----
An acronym standing for atomicity, consistency, isolation, and durability. These properties are all desirable in a database system, and are all closely tied to the notion of a transaction. The transactional features of InnoDB adhere to the ACID principles.

Transactions are atomic units of work that can be committed or rolled back. When a transaction makes multiple changes to the database, either all the changes succeed when the transaction is committed, or all the changes are undone when the transaction is rolled back.

The database remains in a consistent state at all times — after each commit or rollback, and while transactions are in progress. If related data is being updated across multiple tables, queries see either all old values or all new values, not a mix of old and new values.

Transactions are protected (isolated) from each other while they are in progress; they cannot interfere with each other or see each other's uncommitted data. This isolation is achieved through the locking mechanism. Experienced users can adjust the isolation level, trading off less protection in favor of increased performance and concurrency, when they can be sure that the transactions really do not interfere with each other.

The results of transactions are durable: once a commit operation succeeds, the changes made by that transaction are safe from power failures, system crashes, race conditions, or other potential dangers that many non-database applications are vulnerable to. Durability typically involves writing to disk storage, with a certain amount of redundancy to protect against power failures or software crashes during write operations. (In InnoDB, the doublewrite buffer assists with durability.)

atomic
-----
In the SQL context, transactions are units of work that either succeed entirely (when committed) or have no effect at all (when rolled back). The indivisible ("atomic") property of transactions is the “A” in the acronym ACID.

commit
-------
A SQL statement that ends a transaction, making permanent any changes made by the transaction. It is the opposite of rollback, which undoes any changes made in the transaction.

InnoDB uses an optimistic mechanism for commits, so that changes can be written to the data files before the commit actually occurs. This technique makes the commit itself faster, with the tradeoff that more work is required in case of a rollback.

By default, MySQL uses the autocommit setting, which automatically issues a commit following each SQL statement.

autocommit
-----------
A setting that causes a commit operation after each SQL statement. This mode is not recommended for working with InnoDB tables with transactions that span several statements. It can help performance for read-only transactions on InnoDB tables, where it minimizes overhead from locking and generation of undo data, especially in MySQL 5.6.4 and up. It is also appropriate for working with MyISAM tables, where transactions are not applicable.

optimistic
----------
A methodology that guides low-level implementation decisions for a relational database system. The requirements of performance and concurrency in a relational database mean that operations must be started or dispatched quickly. The requirements of consistency and referential integrity mean that any operation could fail: a transaction might be rolled back, a DML operation could violate a constraint, a request for a lock could cause a deadlock, a network error could cause a timeout. An optimistic strategy is one that assumes most requests or attempts succeed, so that relatively little work is done to prepare for the failure case. When this assumption is true, the database does little unnecessary work; when requests do fail, extra work must be done to clean up and undo changes.

InnoDB uses optimistic strategies for operations such as locking and commits. For example, data changed by a transaction can be written to the data files before the commit occurs, making the commit itself very fast, but requiring more work to undo the changes if the transaction is rolled back.

The opposite of an optimistic strategy is a pessimistic one, where a system is optimized to deal with operations that are unreliable and frequently unsuccessful. This methodology is rare in a database system, because so much care goes into choosing reliable hardware, networks, and algorithms.

concurrency
------------
The ability of multiple operations (in database terminology, transactions) to run simultaneously, without interfering with each other. Concurrency is also involved with performance, because ideally the protection for multiple simultaneous transactions works with a minimum of performance overhead, using efficient mechanisms for locking.

locking
-------
The system of protecting a transaction from seeing or changing data that is being queried or changed by other transactions. The locking strategy must balance reliability and consistency of database operations (the principles of the ACID philosophy) against the performance needed for good concurrency. Fine-tuning the locking strategy often involves choosing an isolation level and ensuring all your database operations are safe and reliable for that isolation level.

rollback
--------
A SQL statement that ends a transaction, undoing any changes made by the transaction. It is the opposite of commit, which makes permanent any changes made in the transaction.

By default, MySQL uses the autocommit setting, which automatically issues a commit following each SQL statement. You must change this setting before you can use the rollback technique.

transaction
------------
Transactions are atomic units of work that can be committed or rolled back. When a transaction makes multiple changes to the database, either all the changes succeed when the transaction is committed, or all the changes are undone when the transaction is rolled back.

Database transactions, as implemented by InnoDB, have properties that are collectively known by the acronym ACID, for atomicity, consistency, isolation, and durability.

8.2.1.1 WHERE Clause Optimization
----------------------------------
This section discusses optimizations that can be made for processing WHERE clauses. The examples use SELECT statements, but the same optimizations apply for WHERE clauses in DELETE and UPDATE statements.

You might be tempted to rewrite your queries to make arithmetic operations faster, while sacrificing readability. Because MySQL does similar optimizations automatically, you can often avoid this work, and leave the query in a more understandable and maintainable form. Some of the optimizations performed by MySQL follow:

Removal of unnecessary parentheses:
   ((a AND b) AND c OR (((a AND b) AND (c AND d))))
-> (a AND b AND c) OR (a AND b AND c AND d)

Constant folding:
   (a<b AND b=c) AND a=5
-> b>5 AND b=c AND a=5

Constant condition removal:
   (b>=5 AND b=5) OR (b=6 AND 5=5) OR (b=7 AND 5=6)
-> b=5 OR b=6

Constant expressions used by indexes are evaluated only once.

Beginning with MySQL 8.0.16, comparisons of columns of numeric types with constant values are checked and folded or removed for invalid or out-of-rage values:

Little knowledge of bit wise operators:
mysql> select 1 | 2, 1 << 2;
+-------+--------+
| 1 | 2 | 1 << 2 |
+-------+--------+
|     3 |      4 |
+-------+--------+
1 row in set (0.00 sec)

mysql> select 1 | 2, 1 << 2, BIT_COUNT(2);
+-------+--------+--------------+
| 1 | 2 | 1 << 2 | BIT_COUNT(2) |
+-------+--------+--------------+
|     3 |      4 |            1 |
+-------+--------+--------------+
1 row in set (0.00 sec)

mysql> select 1 | 2, 1 << 2, BIT_COUNT(3);
+-------+--------+--------------+
| 1 | 2 | 1 << 2 | BIT_COUNT(3) |
+-------+--------+--------------+
|     3 |      4 |            2 |
+-------+--------+--------------+
1 row in set (0.00 sec)

COUNT(*) on a single table without a WHERE is retrieved directly from the table information for MyISAM and MEMORY tables. This is also done for any NOT NULL expression when used with only one table.
Early detection of invalid constant expressions. MySQL quickly detects that some SELECT statements are impossible and returns no rows.
HAVING is merged with WHERE if you do not use GROUP BY or aggregate functions (COUNT(), MIN(), and so on).
For each table in a join, a simpler WHERE is constructed to get a fast WHERE evaluation for the table and also to skip rows as soon as possible.
 All constant tables are read first before any other tables in the query. A constant table is any of the following:
An empty table or a table with one row.
A table that is used with a WHERE clause on a PRIMARY KEY or a UNIQUE index, where all index parts are compared to constant expressions and are defined as NOT NULL.
All of the following tables are used as constant tables:

SELECT * FROM t WHERE primary_key=1;
SELECT * FROM t1,t2
  WHERE t1.primary_key=1 AND t2.primary_key=t1.id;

The best join combination for joining the tables is found by trying all possibilities. If all columns in ORDER BY and GROUP BY clauses come from the same table, that table is preferred first when joining.

If there is an ORDER BY clause and a different GROUP BY clause, or if the ORDER BY or GROUP BY contains columns from tables other than the first table in the join queue, a temporary table is created.

If you use the SQL_SMALL_RESULT modifier, MySQL uses an in-memory temporary table.

Each table index is queried, and the best index is used unless the optimizer believes that it is more efficient to use a table scan. At one time, a scan was used based on whether the best index spanned more than 30% of the table, but a fixed percentage no longer determines the choice between using an index or a scan. The optimizer now is more complex and bases its estimate on additional factors such as table size, number of rows, and I/O block size.

In some cases, MySQL can read rows from the index without even consulting the data file. If all columns used from the index are numeric, only the index tree is used to resolve the query.

Before each row is output, those that do not match the HAVING clause are skipped.

Some examples of queries that are very fast:


SELECT COUNT(*) FROM tbl_name;

SELECT MIN(key_part1),MAX(key_part1) FROM tbl_name;

SELECT MAX(key_part2) FROM tbl_name
  WHERE key_part1=constant;

SELECT ... FROM tbl_name
  ORDER BY key_part1,key_part2,... LIMIT 10;

SELECT ... FROM tbl_name
  ORDER BY key_part1 DESC, key_part2 DESC, ... LIMIT 10;

 MySQL resolves the following queries using only the index tree, assuming that the indexed columns are numeric:

  SELECT key_part1,key_part2 FROM tbl_name WHERE key_part1=val;

  SELECT COUNT(*) FROM tbl_name
    WHERE key_part1=val1 AND key_part2=val2;

  SELECT MAX(key_part2) FROM tbl_name GROUP BY key_part1;

The following queries use indexing to retrieve the rows in sorted order without a separate sorting pass:

SELECT ... FROM tbl_name
  ORDER BY key_part1,key_part2,... ;

SELECT ... FROM tbl_name
  ORDER BY key_part1 DESC, key_part2 DESC, ... ;

Chapter 9 Language Structure
==============================
This chapter discusses the rules for writing the following elements of SQL statements when using MySQL:
Literal values such as strings and numbers
Identifiers such as database, table, and column names
Keywords and reserved words
User-defined and system variables
Expressions
Query attributes
Comments

9.1 Literal Values
------------------
This section describes how to write literal values in MySQL. These include strings, numbers, hexadecimal and bit values, boolean values, and NULL. The section also covers various nuances that you may encounter when dealing with these basic types in MySQL.

9.1.1 String Literals
----------------------
A string is a sequence of bytes or characters, enclosed within either single quote (') or double quote (") characters. Examples:
'a string'
"another string"

Quoted strings placed next to each other are concatenated to a single string. The following lines are equivalent:
'a string'
'a' ' ' 'string'

mysql> select 'a string';
+----------+
| a string |
+----------+
| a string |
+----------+
1 row in set (0.00 sec)

mysql> select 'a string' 'concatenate string';
+----------------------------+
| a string                   |
+----------------------------+
| a stringconcatenate string |
+----------------------------+
1 row in set (0.00 sec)

mysql> select 'a string', 'concatenate string';
+----------+--------------------+
| a string | concatenate string |
+----------+--------------------+
| a string | concatenate string |
+----------+--------------------+
1 row in set (0.00 sec)

If the ANSI_QUOTES SQL mode is enabled, string literals can be quoted only within single quotation marks because a string quoted within double quotation marks is interpreted as an identifier.

A binary string is a string of bytes. Every binary string has a character set and collation named binary. A nonbinary string is a string of characters. It has a character set other than binary and a collation that is compatible with the character set.

For both types of strings, comparisons are based on the numeric values of the string unit. For binary strings, the unit is the byte; comparisons use numeric byte values. For nonbinary strings, the unit is the character and some character sets support multibyte characters; comparisons use numeric character code values. Character code ordering is a function of the string collation.

A character string literal may have an optional character set introducer and COLLATE clause, to designate it as a string that uses a particular character set and collation:

[_charset_name]'string' [COLLATE collation_name]

Within a string, certain sequences have special meaning unless the NO_BACKSLASH_ESCAPES SQL mode is enabled. Each of these sequences begins with a backslash (\), known as the escape character. MySQL recognizes the escape sequences shown in Table 9.1, “Special Character Escape Sequences”. For all other escape sequences, backslash is ignored. That is, the escaped character is interpreted as if it was not escaped. For example, \x is just x. These sequences are case-sensitive. For example, \b is interpreted as a backspace, but \B is interpreted as B. Escape processing is done according to the character set indicated by the character_set_connection system variable. This is true even for strings that are preceded by an introducer that indicates a different character set, as discussed in

Table 9.1 Special Character Escape Sequences

Escape Sequence	Character Represented by Sequence
\0	An ASCII NUL (X'00') character
\'	A single quote (') character
\"	A double quote (") character
\b	A backspace character
\n	A newline (linefeed) character
\r	A carriage return character
\t	A tab character
\Z	ASCII 26 (Control+Z); see note following the table
\\	A backslash (\) character
\%	A % character; see note following the table
\_	A _ character; see note following the table

The ASCII 26 character can be encoded as \Z to enable you to work around the problem that ASCII 26 stands for END-OF-FILE on Windows. ASCII 26 within a file causes problems if you try to use mysql db_name < file_name.

The \% and \_ sequences are used to search for literal instances of % and _ in pattern-matching contexts where they would otherwise be interpreted as wildcard characters. See the description of the LIKE operator in Section 12.8.1, “String Comparison Functions and Operators”. If you use \% or \_ outside of pattern-matching contexts, they evaluate to the strings \% and \_, not to % and _.

There are several ways to include quote characters within a string:

A ' inside a string quoted with ' may be written as ''.

A " inside a string quoted with " may be written as "".

Precede the quote character by an escape character (\).

A ' inside a string quoted with " needs no special treatment and need not be doubled or escaped. In the same way, " inside a string quoted with ' needs no special treatment.

The following SELECT statements demonstrate how quoting and escaping work:

mysql> SELECT 'hello', '"hello"', '""hello""', 'hel''lo', '\'hello';
+-------+---------+-----------+--------+--------+
| hello | "hello" | ""hello"" | hel'lo | 'hello |
+-------+---------+-----------+--------+--------+
| hello | "hello" | ""hello"" | hel'lo | 'hello |
+-------+---------+-----------+--------+--------+
1 row in set (0.00 sec)

mysql> SELECT 'hello', '"hello"', '""hello""', 'hel' 'lo', '\'hello';
+-------+---------+-----------+-------+--------+
| hello | "hello" | ""hello"" | hel   | 'hello |
+-------+---------+-----------+-------+--------+
| hello | "hello" | ""hello"" | hello | 'hello |
+-------+---------+-----------+-------+--------+
1 row in set (0.00 sec)

mysql> SELECT "hello", "'hello'", "''hello''", "hel""lo", "\"hello";
+-------+---------+-----------+--------+--------+
| hello | 'hello' | ''hello'' | hel"lo | "hello |
+-------+---------+-----------+--------+--------+

mysql> SELECT 'This\nIs\nFour\nLines';
+--------------------+
| This
Is
Four
Lines |
+--------------------+

mysql> SELECT 'disappearing\ backslash';
+------------------------+
| disappearing backslash |
+------------------------+

To insert binary data into a string column (such as a BLOB column), you should represent certain characters by escape sequences. Backslash (\) and the quote character used to quote the string must be escaped. In certain client environments, it may also be necessary to escape NUL or Control+Z. The mysql client truncates quoted strings containing NUL characters if they are not escaped, and Control+Z may be taken for END-OF-FILE on Windows if not escaped. For the escape sequences that represent each of these characters, see Table 9.1, “Special Character Escape Sequences”.

When writing application programs, any string that might contain any of these special characters must be properly escaped before the string is used as a data value in an SQL statement that is sent to the MySQL server. You can do this in two ways:

Process the string with a function that escapes the special characters. In a C program, you can use the mysql_real_escape_string_quote() C API function to escape characters. See mysql_real_escape_string_quote(). Within SQL statements that construct other SQL statements, you can use the QUOTE() function. The Perl DBI interface provides a quote method to convert special characters to the proper escape sequences. See Section 29.9, “MySQL Perl API”. Other language interfaces may provide a similar capability.

As an alternative to explicitly escaping special characters, many MySQL APIs provide a placeholder capability that enables you to insert special markers into a statement string, and then bind data values to them when you issue the statement. In this case, the API takes care of escaping special characters in the values for you.

9.1.2 Numeric Literals
----------------------
Number literals include exact-value (integer and DECIMAL) literals and approximate-value (floating-point) literals.

Integers are represented as a sequence of digits. Numbers may include . as a decimal separator. Numbers may be preceded by - or + to indicate a negative or positive value, respectively. Numbers represented in scientific notation with a mantissa and exponent are approximate-value numbers.

Exact-value numeric literals have an integer part or fractional part, or both. They may be signed. Examples: 1, .2, 3.4, -5, -6.78, +9.10.

Approximate-value numeric literals are represented in scientific notation with a mantissa and exponent. Either or both parts may be signed. Examples: 1.2E3, 1.2E-3, -1.2E3, -1.2E-3.

Two numbers that look similar may be treated differently. For example, 2.34 is an exact-value (fixed-point) number, whereas 2.34E0 is an approximate-value (floating-point) number.

The DECIMAL data type is a fixed-point type and calculations are exact. In MySQL, the DECIMAL type has several synonyms: NUMERIC, DEC, FIXED. The integer types also are exact-value types. For more information about exact-value calculations, see Section 12.25, “Precision Math”.

The FLOAT and DOUBLE data types are floating-point types and calculations are approximate. In MySQL, types that are synonymous with FLOAT or DOUBLE are DOUBLE PRECISION and REAL.

An integer may be used in floating-point context; it is interpreted as the equivalent floating-point number.

9.1.3 Date and Time Literals
------------------------------
Date and time values can be represented in several formats, such as quoted strings or as numbers, depending on the exact type of the value and other factors. For example, in contexts where MySQL expects a date, it interprets any of '2015-07-21', '20150721', and 20150721 as a date.

Date and time values can be represented in several formats, such as quoted strings or as numbers, depending on the exact type of the value and other factors. For example, in contexts where MySQL expects a date, it interprets any of '2015-07-21', '20150721', and 20150721 as a date.

This section describes the acceptable formats for date and time literals. For more information about the temporal data types, such as the range of permitted values.

Standard SQL and ODBC Date and Time Literals.  Standard SQL requires temporal literals to be specified using a type keyword and a string. The space between the keyword and string is optional.

DATE 'str'
TIME 'str'
TIMESTAMP 'str'

MySQL recognizes but, unlike standard SQL, does not require the type keyword. Applications that are to be standard-compliant should include the type keyword for temporal literals.

MySQL also recognizes the ODBC syntax corresponding to the standard SQL syntax:

{ d 'str' }
{ t 'str' }
{ ts 'str' }

MySQL uses the type keywords and the ODBC constructions to produce DATE, TIME, and DATETIME values, respectively, including a trailing fractional seconds part if specified. The TIMESTAMP syntax produces a DATETIME value in MySQL because DATETIME has a range that more closely corresponds to the standard SQL TIMESTAMP type, which has a year range from 0001 to 9999. (The MySQL TIMESTAMP year range is 1970 to 2038.)

String and Numeric Literals in Date and Time Context.  MySQL recognizes DATE values in these formats:

As a string in either 'YYYY-MM-DD' or 'YY-MM-DD' format. A “relaxed” syntax is permitted: Any punctuation character may be used as the delimiter between date parts. For example, '2012-12-31', '2012/12/31', '2012^12^31', and '2012@12@31' are equivalent.

As a string with no delimiters in either 'YYYYMMDD' or 'YYMMDD' format, provided that the string makes sense as a date. For example, '20070523' and '070523' are interpreted as '2007-05-23', but '071332' is illegal (it has nonsensical month and day parts) and becomes '0000-00-00'.

As a number in either YYYYMMDD or YYMMDD format, provided that the number makes sense as a date. For example, 19830905 and 830905 are interpreted as '1983-09-05'.

A DATETIME or TIMESTAMP value can include a trailing fractional seconds part in up to microseconds (6 digits) precision. The fractional part should always be separated from the rest of the time by a decimal point; no other fractional seconds delimiter is recognized. For information about fractional seconds support in MySQL, see Section 11.2.6, “Fractional Seconds in Time Values”.

Dates containing two-digit year values are ambiguous because the century is unknown. MySQL interprets two-digit year values using these rules:

Year values in the range 70-99 become 1970-1999.

Year values in the range 00-69 become 2000-2069.

See also Section 11.2.8, “2-Digit Years in Dates”.

For values specified as strings that include date part delimiters, it is unnecessary to specify two digits for month or day values that are less than 10. '2015-6-9' is the same as '2015-06-09'. Similarly, for values specified as strings that include time part delimiters, it is unnecessary to specify two digits for hour, minute, or second values that are less than 10. '2015-10-30 1:2:3' is the same as '2015-10-30 01:02:03'.

Values specified as numbers should be 6, 8, 12, or 14 digits long. If a number is 8 or 14 digits long, it is assumed to be in YYYYMMDD or YYYYMMDDhhmmss format and that the year is given by the first 4 digits. If the number is 6 or 12 digits long, it is assumed to be in YYMMDD or YYMMDDhhmmss format and that the year is given by the first 2 digits. Numbers that are not one of these lengths are interpreted as though padded with leading zeros to the closest length.

Values specified as nondelimited strings are interpreted according their length. For a string 8 or 14 characters long, the year is assumed to be given by the first 4 characters. Otherwise, the year is assumed to be given by the first 2 characters. The string is interpreted from left to right to find year, month, day, hour, minute, and second values, for as many parts as are present in the string. This means you should not use strings that have fewer than 6 characters. For example, if you specify '9903', thinking that represents March, 1999, MySQL converts it to the “zero” date value. This occurs because the year and month values are 99 and 03, but the day part is completely missing. However, you can explicitly specify a value of zero to represent missing month or day parts. For example, to insert the value '1999-03-00', use '990300'.

MySQL recognizes TIME values in these formats:

As a string in 'D hh:mm:ss' format. You can also use one of the following “relaxed” syntaxes: 'hh:mm:ss', 'hh:mm', 'D hh:mm', 'D hh', or 'ss'. Here D represents days and can have a value from 0 to 34.

As a string with no delimiters in 'hhmmss' format, provided that it makes sense as a time. For example, '101112' is understood as '10:11:12', but '109712' is illegal (it has a nonsensical minute part) and becomes '00:00:00'.

As a number in hhmmss format, provided that it makes sense as a time. For example, 101112 is understood as '10:11:12'. The following alternative formats are also understood: ss, mmss, or hhmmss.

A trailing fractional seconds part is recognized in the 'D hh:mm:ss.fraction', 'hh:mm:ss.fraction', 'hhmmss.fraction', and hhmmss.fraction time formats, where fraction is the fractional part in up to microseconds (6 digits) precision. The fractional part should always be separated from the rest of the time by a decimal point; no other fractional seconds delimiter is recognized. For information about fractional seconds support in MySQL, see Section 11.2.6, “Fractional Seconds in Time Values”.

For TIME values specified as strings that include a time part delimiter, it is unnecessary to specify two digits for hours, minutes, or seconds values that are less than 10. '8:3:2' is the same as '08:03:02'.

Beginning with MySQL 8.0.19, you can specify a time zone offset when inserting TIMESTAMP and DATETIME values into a table. The offset is appended to the time part of a datetime literal, with no intravening spaces, and uses the same format used for setting the time_zone system variable, with the following exceptions:

For hour values less than than 10, a leading zero is required.

The value '-00:00' is rejected.

Time zone names such as 'EET' and 'Asia/Shanghai' cannot be used; 'SYSTEM' also cannot be used in this context.

The value inserted must not have a zero for the month part, the day part, or both parts. This is enforced beginning with MySQL 8.0.22, regardless of the server SQL mode setting.

This example illustrates inserting datetime values with time zone offsets into TIMESTAMP and DATETIME columns using different time_zone settings, and then retrieving them:

mysql> CREATE TABLE ts (
    ->     id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,
    ->     col TIMESTAMP NOT NULL
    -> ) AUTO_INCREMENT = 1;

mysql> CREATE TABLE dt (
    ->     id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    ->     col DATETIME NOT NULL
    -> ) AUTO_INCREMENT = 1;

mysql> SET @@time_zone = 'SYSTEM';

mysql> INSERT INTO ts (col) VALUES ('2020-01-01 10:10:10'),
    ->     ('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00');

mysql> SET @@time_zone = '+00:00';

mysql> INSERT INTO ts (col) VALUES ('2020-01-01 10:10:10'),
    ->     ('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00');

mysql> SET @@time_zone = 'SYSTEM';

mysql> INSERT INTO dt (col) VALUES ('2020-01-01 10:10:10'),
    ->     ('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00');

mysql> SET @@time_zone = '+00:00';

mysql> INSERT INTO dt (col) VALUES ('2020-01-01 10:10:10'),
    ->     ('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00');

mysql> SET @@time_zone = 'SYSTEM';

mysql> SELECT @@system_time_zone;
+--------------------+
| @@system_time_zone |
+--------------------+
| EST                |
+--------------------+

mysql> SELECT col, UNIX_TIMESTAMP(col) FROM dt ORDER BY id;
+---------------------+---------------------+
| col                 | UNIX_TIMESTAMP(col) |
+---------------------+---------------------+
| 2020-01-01 10:10:10 |          1577891410 |
| 2019-12-31 23:40:10 |          1577853610 |
| 2020-01-01 13:10:10 |          1577902210 |
| 2020-01-01 10:10:10 |          1577891410 |
| 2020-01-01 04:40:10 |          1577871610 |
| 2020-01-01 18:10:10 |          1577920210 |
+---------------------+---------------------+

mysql> SELECT col, UNIX_TIMESTAMP(col) FROM ts ORDER BY id;
+---------------------+---------------------+
| col                 | UNIX_TIMESTAMP(col) |
+---------------------+---------------------+
| 2020-01-01 10:10:10 |          1577891410 |
| 2019-12-31 23:40:10 |          1577853610 |
| 2020-01-01 13:10:10 |          1577902210 |
| 2020-01-01 05:10:10 |          1577873410 |
| 2019-12-31 23:40:10 |          1577853610 |
| 2020-01-01 13:10:10 |          1577902210 |
+---------------------+---------------------+

The offset is not displayed when selecting a datetime value, even if one was used when inserting it.
The range of supported offset values is -13:59 to +14:00, inclusive.
Datetime literals that include time zone offsets are accepted as parameter values by prepared statements.

9.1.4 Hexadecimal Literals
---------------------------
Hexadecimal literal values are written using X'val' or 0xval notation, where val contains hexadecimal digits (0..9, A..F). Lettercase of the digits and of any leading X does not matter. A leading 0x is case-sensitive and cannot be written as 0X.

Legal hexadecimal literals:
X'01AF'
X'01af'
x'01AF'
x'01af'
0x01AF
0x01af

Illegal hexadecimal literals:

X'0G'   (G is not a hexadecimal digit)
0X01AF  (0X must be written as 0x)
Values written using X'val' notation must contain an even number of digits or a syntax error occurs. To correct the problem, pad the value with a leading zero:

mysql> SET @s = X'FFF';
ERROR 1064 (42000): You have an error in your SQL syntax;
check the manual that corresponds to your MySQL server
version for the right syntax to use near 'X'FFF''

mysql> SET @s = X'0FFF';
Query OK, 0 rows affected (0.00 sec)
Values written using 0xval notation that contain an odd number of digits are treated as having an extra leading 0. For example, 0xaaa is interpreted as 0x0aaa.

By default, a hexadecimal literal is a binary string, where each pair of hexadecimal digits represents a character:

mysql> SELECT X'4D7953514C', CHARSET(X'4D7953514C');
+---------------+------------------------+
| X'4D7953514C' | CHARSET(X'4D7953514C') |
+---------------+------------------------+
| MySQL         | binary                 |
+---------------+------------------------+
mysql> SELECT 0x5461626c65, CHARSET(0x5461626c65);
+--------------+-----------------------+
| 0x5461626c65 | CHARSET(0x5461626c65) |
+--------------+-----------------------+
| Table        | binary                |
+--------------+-----------------------+
A hexadecimal literal may have an optional character set introducer and COLLATE clause, to designate it as a string that uses a particular character set and collation:

[_charset_name] X'val' [COLLATE collation_name]
Examples:

SELECT _latin1 X'4D7953514C';
SELECT _utf8 0x4D7953514C COLLATE utf8_danish_ci;
The examples use X'val' notation, but 0xval notation permits introducers as well. For information about introducers, see Section 10.3.8, “Character Set Introducers”.

In numeric contexts, MySQL treats a hexadecimal literal like a BIGINT UNSIGNED (64-bit unsigned integer). To ensure numeric treatment of a hexadecimal literal, use it in numeric context. Ways to do this include adding 0 or using CAST(... AS UNSIGNED). For example, a hexadecimal literal assigned to a user-defined variable is a binary string by default. To assign the value as a number, use it in numeric context:

mysql> SET @v1 = X'41';
mysql> SET @v2 = X'41'+0;
mysql> SET @v3 = CAST(X'41' AS UNSIGNED);
mysql> SELECT @v1, @v2, @v3;
+------+------+------+
| @v1  | @v2  | @v3  |
+------+------+------+
| A    |   65 |   65 |
+------+------+------+
An empty hexadecimal value (X'') evaluates to a zero-length binary string. Converted to a number, it produces 0:

mysql> SELECT CHARSET(X''), LENGTH(X'');
+--------------+-------------+
| CHARSET(X'') | LENGTH(X'') |
+--------------+-------------+
| binary       |           0 |
+--------------+-------------+
mysql> SELECT X''+0;
+-------+
| X''+0 |
+-------+
|     0 |
+-------+
The X'val' notation is based on standard SQL. The 0x notation is based on ODBC, for which hexadecimal strings are often used to supply values for BLOB columns.

To convert a string or a number to a string in hexadecimal format, use the HEX() function:

mysql> SELECT HEX('cat');
+------------+
| HEX('cat') |
+------------+
| 636174     |
+------------+
mysql> SELECT X'636174';
+-----------+
| X'636174' |
+-----------+
| cat       |
+-----------+
For hexadecimal literals, bit operations are considered numeric context, but bit operations permit numeric or binary string arguments in MySQL 8.0 and higher. To explicitly specify binary string context for hexadecimal literals, use a _binary introducer for at least one of the arguments:

mysql> SET @v1 = X'000D' | X'0BC0';
mysql> SET @v2 = _binary X'000D' | X'0BC0';
mysql> SELECT HEX(@v1), HEX(@v2);
+----------+----------+
| HEX(@v1) | HEX(@v2) |
+----------+----------+
| BCD      | 0BCD     |
+----------+----------+
The displayed result appears similar for both bit operations, but the result without _binary is a BIGINT value, whereas the result with _binary is a binary string. Due to the difference in result types, the displayed values differ: High-order 0 digits are not displayed for the numeric result.

mysql> select LENGTH('Ramesh');
+------------------+
| LENGTH('Ramesh') |
+------------------+
|                6 |
+------------------+
1 row in set (0.01 sec)

mysql> select CHARSET(''), CHARSET(X'');
+-------------+--------------+
| CHARSET('') | CHARSET(X'') |
+-------------+--------------+
| utf8mb4     | binary       |
+-------------+--------------+
1 row in set (0.00 sec)


9.1.5 Bit-Value Literals
------------------------
Bit-value literals are written using b'val' or 0bval notation. val is a binary value written using zeros and ones. Lettercase of any leading b does not matter. A leading 0b is case-sensitive and cannot be written as 0B.

Legal bit-value literals:
b'01'
B'01'
0b01

Illegal bit-value literals:
b'2'    (2 is not a binary digit)
0B01    (0B must be written as 0b)

By default, a bit-value literal is a binary string:
mysql> SELECT b'1000001', CHARSET(b'1000001');
+------------+---------------------+
| b'1000001' | CHARSET(b'1000001') |
+------------+---------------------+
| A          | binary              |
+------------+---------------------+

mysql> SELECT 0b1100001, CHARSET(0b1100001);
+-----------+--------------------+
| 0b1100001 | CHARSET(0b1100001) |
+-----------+--------------------+
| a         | binary             |
+-----------+--------------------+

A bit-value literal may have an optional character set introducer and COLLATE clause, to designate it as a string that uses a particular character set and collation:
[_charset_name] b'val' [COLLATE collation_name]

mysql> select _latin1 0b1000001;
+-------------------+
| _latin1 0b1000001 |
+-------------------+
| A                 |
+-------------------+
1 row in set (0.00 sec)

mysql> select _utf8 0b1000001;
+-----------------+
| _utf8 0b1000001 |
+-----------------+
| A               |
+-----------------+
1 row in set, 1 warning (0.00 sec)

mysql> select _utf8 0b1000001 COLLATE utf8_danish_ci;
+----------------------------------------+
| _utf8 0b1000001 COLLATE utf8_danish_ci |
+----------------------------------------+
| A                                      |
+----------------------------------------+

The examples use b'val' notation, but 0bval notation permits introducers as well. For information about introducers, see Section 10.3.8, “Character Set Introducers”.

In numeric contexts, MySQL treats a bit literal like an integer. To ensure numeric treatment of a bit literal, use it in numeric context. Ways to do this include adding 0 or using CAST(... AS UNSIGNED). For example, a bit literal assigned to a user-defined variable is a binary string by default. To assign the value as a number, use it in numeric context:

mysql> set @v1 = b'1000001';
Query OK, 0 rows affected (0.00 sec)

mysql> set @v2 = b'1000001' + 1;
Query OK, 0 rows affected (0.00 sec)

mysql> set @v3 = CAST(b'1000001' AS UNSIGNED);
Query OK, 0 rows affected (0.00 sec)

mysql> select @v1, @v2, @v3;
+------+------+------+
| @v1  | @v2  | @v3  |
+------+------+------+
| A    |   66 |   65 |
+------+------+------+
1 row in set (0.00 sec)

An empty bit value (b'') evaluates to a zero-length binary string. Converted to a number, it produces 0:


mysql> SELECT CHARSET(b''), LENGTH(b'');
+--------------+-------------+
| CHARSET(b'') | LENGTH(b'') |
+--------------+-------------+
| binary       |           0 |
+--------------+-------------+
mysql> SELECT b''+0;
+-------+
| b''+0 |
+-------+
|     0 |
+-------+

Bit-value notation is convenient for specifying values to be assigned to BIT columns:
mysql> create table t (b BIT(8));
Query OK, 0 rows affected (0.03 sec)

mysql> insert into t set b = b'11111111';
Query OK, 1 row affected (0.01 sec)

mysql> insert into t set b = b'1010';
Query OK, 1 row affected (0.00 sec)

mysql> insert into t set b = b'0101';
Query OK, 1 row affected (0.00 sec)

Bit values in result sets are returned as binary values, which may not display well. To convert a bit value to printable form, use it in numeric context or use a conversion function such as BIN() or HEX(). High-order 0 digits are not displayed in the converted value.
mysql> SELECT b+0, BIN(b), OCT(b), HEX(b) FROM t;
+------+----------+--------+--------+
| b+0  | BIN(b)   | OCT(b) | HEX(b) |
+------+----------+--------+--------+
|  255 | 11111111 | 377    | FF     |
|   10 | 1010     | 12     | A      |
|    5 | 101      | 5      | 5      |
+------+----------+--------+--------+

For bit literals, bit operations are considered numeric context, but bit operations permit numeric or binary string arguments in MySQL 8.0 and higher. To explicitly specify binary string context for bit literals, use a _binary introducer for at least one of the arguments:

mysql> set @v1 = b'000010101' | b'000101010';
Query OK, 0 rows affected (0.00 sec)

mysql> set @v2 = _binary b'000010101' | _binary b'000101010';
Query OK, 0 rows affected (0.00 sec)

mysql> select @v1, @v2;
+------+------+
| @v1  | @v2  |
+------+------+
|   63 |  ?   |
+------+------+
1 row in set (0.00 sec)

mysql> select HEX(@v1), HEX(@v2);
+----------+----------+
| HEX(@v1) | HEX(@v2) |
+----------+----------+
| 3F       | 003F     |
+----------+----------+
1 row in set (0.00 sec)

The displayed result appears similar for both bit operations, but the result without _binary is a BIGINT value, whereas the result with _binary is a binary string. Due to the difference in result types, the displayed values differ: High-order 0 digits are not displayed for the numeric result.

9.1.6 Boolean Literals
-----------------------
The constants TRUE and FALSE evaluate to 1 and 0, respectively. The constant names can be written in any lettercase.

mysql> select True, true, TRUE, False, false, FALSE;
+------+------+------+-------+-------+-------+
| True | true | TRUE | False | false | FALSE |
+------+------+------+-------+-------+-------+
|    1 |    1 |    1 |     0 |     0 |     0 |
+------+------+------+-------+-------+-------+

9.1.7 NULL Values
==================
The NULL value means “no data.” NULL can be written in any lettercase.

Be aware that the NULL value is different from values such as 0 for numeric types or the empty string for string types. For more information, see Section B.3.4.3, “Problems with NULL Values”.

For text file import or export operations performed with LOAD DATA or SELECT ... INTO OUTFILE, NULL is represented by the \N sequence. See Section 13.2.7, “LOAD DATA Statement”.

For sorting with ORDER BY, NULL values sort before other values for ascending sorts, after other values for descending sorts.

9.2 Schema Object Names
------------------------
Certain objects within MySQL, including database, table, index, column, alias, view, stored procedure, partition, tablespace, resource group and other object names are known as identifiers. This section describes the permissible syntax for identifiers in MySQL. Section 9.2.1, “Identifier Length Limits”, indicates the maximum length of each type of identifier. Section 9.2.3, “Identifier Case Sensitivity”, describes which types of identifiers are case-sensitive and under what conditions.

An identifier may be quoted or unquoted. If an identifier contains special characters or is a reserved word, you must quote it whenever you refer to it. (Exception: A reserved word that follows a period in a qualified name must be an identifier, so it need not be quoted.) Reserved words are listed at Section 9.3, “Keywords and Reserved Words”.

Internally, identifiers are converted to and are stored as Unicode (UTF-8). The permissible Unicode characters in identifiers are those in the Basic Multilingual Plane (BMP). Supplementary characters are not permitted. Identifiers thus may contain these characters:

Permitted characters in unquoted identifiers:

ASCII: [0-9,a-z,A-Z$_] (basic Latin letters, digits 0-9, dollar, underscore)

Extended: U+0080 .. U+FFFF

Permitted characters in quoted identifiers include the full Unicode Basic Multilingual Plane (BMP), except U+0000:

ASCII: U+0001 .. U+007F

Extended: U+0080 .. U+FFFF

ASCII NUL (U+0000) and supplementary characters (U+10000 and higher) are not permitted in quoted or unquoted identifiers.

Identifiers may begin with a digit but unless quoted may not consist solely of digits.

Database, table, and column names cannot end with space characters.

The identifier quote character is the backtick (`):

mysql> SELECT * FROM `select` WHERE `select`.id > 100;
If the ANSI_QUOTES SQL mode is enabled, it is also permissible to quote identifiers within double quotation marks:

mysql> CREATE TABLE "test" (col INT);
ERROR 1064: You have an error in your SQL syntax...
mysql> SET sql_mode='ANSI_QUOTES';
mysql> CREATE TABLE "test" (col INT);
Query OK, 0 rows affected (0.00 sec)
The ANSI_QUOTES mode causes the server to interpret double-quoted strings as identifiers. Consequently, when this mode is enabled, string literals must be enclosed within single quotation marks. They cannot be enclosed within double quotation marks. The server SQL mode is controlled as described in Section 5.1.11, “Server SQL Modes”.

Identifier quote characters can be included within an identifier if you quote the identifier. If the character to be included within the identifier is the same as that used to quote the identifier itself, then you need to double the character. The following statement creates a table named a`b that contains a column named c"d:

mysql> CREATE TABLE `a``b` (`c"d` INT);
In the select list of a query, a quoted column alias can be specified using identifier or string quoting characters:

mysql> SELECT 1 AS `one`, 2 AS 'two';
+-----+-----+
| one | two |
+-----+-----+
|   1 |   2 |
+-----+-----+
Elsewhere in the statement, quoted references to the alias must use identifier quoting or the reference is treated as a string literal.

It is recommended that you do not use names that begin with Me or MeN, where M and N are integers. For example, avoid using 1e as an identifier, because an expression such as 1e+3 is ambiguous. Depending on context, it might be interpreted as the expression 1e + 3 or as the number 1e+3.

Be careful when using MD5() to produce table names because it can produce names in illegal or ambiguous formats such as those just described.

A user variable cannot be used directly in an SQL statement as an identifier or as part of an identifier. See Section 9.4, “User-Defined Variables”, for more information and examples of workarounds.

Special characters in database and table names are encoded in the corresponding file system names as described in Section 9.2.4, “Mapping of Identifiers to File Names”.


9.2.2 Identifier Qualifiers
===========================
Object names may be unqualified or qualified. An unqualified name is permitted in contexts where interpretation of the name is unambiguous. A qualified name includes at least one qualifier to clarify the interpretive context by overriding a default context or providing missing context.

For example, this statement creates a table using the unqualified name t1:

CREATE TABLE t1 (i INT);
Because t1 includes no qualifier to specify a database, the statement creates the table in the default database. If there is no default database, an error occurs.

This statement creates a table using the qualified name db1.t1:

CREATE TABLE db1.t1 (i INT);
Because db1.t1 includes a database qualifier db1, the statement creates t1 in the database named db1, regardless of the default database. The qualifier must be specified if there is no default database. The qualifier may be specified if there is a default database, to specify a database different from the default, or to make the database explicit if the default is the same as the one specified.

Qualifiers have these characteristics:

An unqualified name consists of a single identifier. A qualified name consists of multiple identifiers.

The components of a multiple-part name must be separated by period (.) characters. The initial parts of a multiple-part name act as qualifiers that affect the context within which to interpret the final identifier.

The qualifier character is a separate token and need not be contiguous with the associated identifiers. For example, tbl_name.col_name and tbl_name . col_name are equivalent.

If any components of a multiple-part name require quoting, quote them individually rather than quoting the name as a whole. For example, write `my-table`.`my-column`, not `my-table.my-column`.

A reserved word that follows a period in a qualified name must be an identifier, so in that context it need not be quoted.

The permitted qualifiers for object names depend on the object type:

A database name is fully qualified and takes no qualifier:

CREATE DATABASE db1;
A table, view, or stored program name may be given a database-name qualifier. Examples of unqualified and qualified names in CREATE statements:

CREATE TABLE mytable ...;
CREATE VIEW myview ...;
CREATE PROCEDURE myproc ...;
CREATE FUNCTION myfunc ...;
CREATE EVENT myevent ...;

CREATE TABLE mydb.mytable ...;
CREATE VIEW mydb.myview ...;
CREATE PROCEDURE mydb.myproc ...;
CREATE FUNCTION mydb.myfunc ...;
CREATE EVENT mydb.myevent ...;
A trigger is associated with a table, so any qualifier applies to the table name:

CREATE TRIGGER mytrigger ... ON mytable ...;

CREATE TRIGGER mytrigger ... ON mydb.mytable ...;
A column name may be given multiple qualifiers to indicate context in statements that reference it, as shown in the following table.

Column Reference	Meaning
col_name	Column col_name from whichever table used in the statement contains a column of that name
tbl_name.col_name	Column col_name from table tbl_name of the default database
db_name.tbl_name.col_name	Column col_name from table tbl_name of the database db_name
In other words, a column name may be given a table-name qualifier, which itself may be given a database-name qualifier. Examples of unqualified and qualified column references in SELECT statements:

SELECT c1 FROM mytable
WHERE c2 > 100;

SELECT mytable.c1 FROM mytable
WHERE mytable.c2 > 100;

SELECT mydb.mytable.c1 FROM mydb.mytable
WHERE mydb.mytable.c2 > 100;
You need not specify a qualifier for an object reference in a statement unless the unqualified reference is ambiguous. Suppose that column c1 occurs only in table t1, c2 only in t2, and c in both t1 and t2. Any unqualified reference to c is ambiguous in a statement that refers to both tables and must be qualified as t1.c or t2.c to indicate which table you mean:

SELECT c1, c2, t1.c FROM t1 INNER JOIN t2
WHERE t2.c > 100;
Similarly, to retrieve from a table t in database db1 and from a table t in database db2 in the same statement, you must qualify the table references: For references to columns in those tables, qualifiers are required only for column names that appear in both tables. Suppose that column c1 occurs only in table db1.t, c2 only in db2.t, and c in both db1.t and db2.t. In this case, c is ambiguous and must be qualified but c1 and c2 need not be:

SELECT c1, c2, db1.t.c FROM db1.t INNER JOIN db2.t
WHERE db2.t.c > 100;
Table aliases enable qualified column references to be written more simply:


SELECT c1, c2, t1.c FROM db1.t AS t1 INNER JOIN db2.t AS t2
WHERE t2.c > 100;

9.2.3 Identifier Case Sensitivity
---------------------------------
In MySQL, databases correspond to directories within the data directory. Each table within a database corresponds to at least one file within the database directory (and possibly more, depending on the storage engine). Triggers also correspond to files. Consequently, the case sensitivity of the underlying operating system plays a part in the case sensitivity of database, table, and trigger names. This means such names are not case-sensitive in Windows, but are case-sensitive in most varieties of Unix. One notable exception is macOS, which is Unix-based but uses a default file system type (HFS+) that is not case-sensitive. However, macOS also supports UFS volumes, which are case-sensitive just as on any Unix. See Section 1.7.1, “MySQL Extensions to Standard SQL”. The lower_case_table_names system variable also affects how the server handles identifier case sensitivity, as described later in this section.

Note
Although database, table, and trigger names are not case-sensitive on some platforms, you should not refer to one of these using different cases within the same statement. The following statement would not work because it refers to a table both as my_table and as MY_TABLE:

mysql> SELECT * FROM my_table WHERE MY_TABLE.col=1;
Partition, subpartition, column, index, stored routine, event, and resource group names are not case-sensitive on any platform, nor are column aliases.

However, names of logfile groups are case-sensitive. This differs from standard SQL.

By default, table aliases are case-sensitive on Unix, but not so on Windows or macOS. The following statement would not work on Unix, because it refers to the alias both as a and as A:

mysql> SELECT col_name FROM tbl_name AS a
       WHERE a.col_name = 1 OR A.col_name = 2;
However, this same statement is permitted on Windows. To avoid problems caused by such differences, it is best to adopt a consistent convention, such as always creating and referring to databases and tables using lowercase names. This convention is recommended for maximum portability and ease of use.

How table and database names are stored on disk and used in MySQL is affected by the lower_case_table_names system variable. lower_case_table_names can take the values shown in the following table. This variable does not affect case sensitivity of trigger identifiers. On Unix, the default value of lower_case_table_names is 0. On Windows, the default value is 1. On macOS, the default value is 2.

lower_case_table_names can only be configured when initializing the server. Changing the lower_case_table_names setting after the server is initialized is prohibited.


9.3 Keywords and Reserved Words
================================
Keywords are words that have significance in SQL. Certain keywords, such as SELECT, DELETE, or BIGINT, are reserved and require special treatment for use as identifiers such as table and column names. This may also be true for the names of built-in functions.

Nonreserved keywords are permitted as identifiers without quoting. Reserved words are permitted as identifiers if you quote them as described in Section 9.2, “Schema Object Names”:

mysql> CREATE TABLE interval (begin INT, end INT);
ERROR 1064 (42000): You have an error in your SQL syntax ...
near 'interval (begin INT, end INT)'
BEGIN and END are keywords but not reserved, so their use as identifiers does not require quoting. INTERVAL is a reserved keyword and must be quoted to be used as an identifier:

mysql> CREATE TABLE `interval` (begin INT, end INT);
Query OK, 0 rows affected (0.01 sec)
Exception: A word that follows a period in a qualified name must be an identifier, so it need not be quoted even if it is reserved:

mysql> CREATE TABLE mydb.interval (begin INT, end INT);
Query OK, 0 rows affected (0.01 sec)

Names of built-in functions are permitted as identifiers but may require care to be used as such. For example, COUNT is acceptable as a column name. However, by default, no whitespace is permitted in function invocations between the function name and the following ( character. This requirement enables the parser to distinguish whether the name is used in a function call or in nonfunction context. For further details on recognition of function names
mysql> select count(*) from pet;
+----------+
| count(*) |
+----------+
|        9 |
+----------+
1 row in set (0.01 sec)

mysql> select count (*) from pet;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '*) from pet' at line 1

The INFORMATION_SCHEMA.KEYWORDS table lists the words considered keywords by MySQL and indicates whether they are reserved
mysql> select * from INFORMATION_SCHEMA.KEYWORDS;
+-------------------------------+----------+
| WORD                          | RESERVED |
+-------------------------------+----------+
| ACCESSIBLE                    |        1 |
| ACCOUNT                       |        0 |
| ACTION                        |        0 |
| ACTIVE                        |        0 |

mysql> select * from INFORMATION_SCHEMA.KEYWORDS where word='FIRST';
+-------+----------+
| WORD  | RESERVED |
+-------+----------+
| FIRST |        0 |
+-------+----------+
1 row in set (0.01 sec)

mysql> select * from INFORMATION_SCHEMA.KEYWORDS where word='first';
+-------+----------+
| WORD  | RESERVED |
+-------+----------+
| FIRST |        0 |
+-------+----------+
1 row in set (0.01 sec)

9.4 User-Defined Variables
---------------------------
You can store a value in a user-defined variable in one statement and refer to it later in another statement. This enables you to pass values from one statement to another.

User variables are written as @var_name, where the variable name var_name consists of alphanumeric characters, ., _, and $. A user variable name can contain other characters if you quote it as a string or identifier (for example, @'my-var', @"my-var", or @`my-var`).

User-defined variables are session specific. A user variable defined by one client cannot be seen or used by other clients. (Exception: A user with access to the Performance Schema user_variables_by_thread table can see all user variables for all sessions.) All variables for a given client session are automatically freed when that client exits.

User variable names are not case-sensitive. Names have a maximum length of 64 characters.

One way to set a user-defined variable is by issuing a SET statement:

SET @var_name = expr [, @var_name = expr] ...
For SET, either = or := can be used as the assignment operator.

User variables can be assigned a value from a limited set of data types: integer, decimal, floating-point, binary or nonbinary string, or NULL value. Assignment of decimal and real values does not preserve the precision or scale of the value. A value of a type other than one of the permissible types is converted to a permissible type. For example, a value having a temporal or spatial data type is converted to a binary string. A value having the JSON data type is converted to a string with a character set of utf8mb4 and a collation of utf8mb4_bin.

If a user variable is assigned a nonbinary (character) string value, it has the same character set and collation as the string. The coercibility of user variables is implicit. (This is the same coercibility as for table column values.)

Hexadecimal or bit values assigned to user variables are treated as binary strings. To assign a hexadecimal or bit value as a number to a user variable, use it in numeric context. For example, add 0 or use CAST(... AS UNSIGNED):

mysql> set @v1 := X'41';
Query OK, 0 rows affected (0.00 sec)

mysql> set @v2 = X'41'+0;
Query OK, 0 rows affected (0.00 sec)

mysql> set @v3 = CAST(X'41' AS UNSIGNED);
Query OK, 0 rows affected (0.00 sec)

mysql> select @v1, @v2, @v3;
+------+------+------+
| @v1  | @v2  | @v3  |
+------+------+------+
| A    |   65 |   65 |
+------+------+------+
1 row in set (0.00 sec)

mysql> set @v1 = b'1000001';
Query OK, 0 rows affected (0.00 sec)

mysql> set @v2 = b'1000001'+0;
Query OK, 0 rows affected (0.00 sec)

mysql> set @v3 = CAST(b'1000001' AS UNSIGNED);
Query OK, 0 rows affected (0.00 sec)

mysql> set @v4 = CAST(b'1000001' AS SIGNED);
Query OK, 0 rows affected (0.00 sec)

mysql> select @v1, @v2, @v3, @v4;
+------+------+------+------+
| @v1  | @v2  | @v3  | @v4  |
+------+------+------+------+
| A    |   65 |   65 |   65 |
+------+------+------+------+
1 row in set (0.00 sec)

User variables are intended to provide data values. They cannot be used directly in an SQL statement as an identifier or as part of an identifier, such as in contexts where a table or database name is expected, or as a reserved word such as SELECT. This is true even if the variable is quoted, as shown in the following example:

mysql> select name from pet limit 2;
+--------+
| name   |
+--------+
| Fluffy |
| Claws  |
+--------+
2 rows in set (0.00 sec)

mysql> set @col = 'name';
Query OK, 0 rows affected (0.00 sec)

mysql> select @col from pet limit 2;
+------+
| @col |
+------+
| name |
| name |
+------+
2 rows in set (0.00 sec)

mysql> select `@col` from pet limit 2;
ERROR 1054 (42S22): Unknown column '@col' in 'field list'
mysql> set @col = "`c1`";
Query OK, 0 rows affected (0.00 sec)

mysql> select @col from pet limit 2;
+------+
| @col |
+------+
| `c1` |
| `c1` |
+------+
2 rows in set (0.00 sec)

An exception to this principle that user variables cannot be used to provide identifiers, is when you are constructing a string for use as a prepared statement to execute later. In this case, user variables can be used to provide any part of the statement. The following example illustrates how this can be done:
mysql> set @c = "name";
Query OK, 0 rows affected (0.00 sec)

mysql> set @s = CONCAT("SELECT ", @c, " FROM pet LIMIT 2");
Query OK, 0 rows affected (0.01 sec)

mysql> PREPARE stmt from @s;
Query OK, 0 rows affected (0.00 sec)
Statement prepared

mysql> EXECUTE stmt;
+--------+
| name   |
+--------+
| Fluffy |
| Claws  |
+--------+
2 rows in set (0.00 sec)
mysql> DEALLOCATE PREPARE stmt;
Query OK, 0 rows affected (0.00 sec)

9.5 Expressions
----------------
The following grammar rules define expression syntax in MySQL.
expr:
    expr OR expr
  | expr || expr
  | expr XOR expr
  | expr AND expr
  | expr && expr
  | NOT expr
  | ! expr
  | boolean_primary IS [NOT] {TRUE | FALSE | UNKNOWN}
  | boolean_primary

boolean_primary:
    boolean_primary IS [NOT] NULL
  | boolean_primary <=> predicate
  | boolean_primary comparison_operator predicate
  | boolean_primary comparison_operator {ALL | ANY} (subquery)
  | predicate

comparison_operator: = | >= | > | <= | < | <> | !=

predicate:
    bit_expr [NOT] IN (subquery)
  | bit_expr [NOT] IN (expr [, expr] ...)
  | bit_expr [NOT] BETWEEN bit_expr AND predicate
  | bit_expr SOUNDS LIKE bit_expr
  | bit_expr [NOT] LIKE simple_expr [ESCAPE simple_expr]
  | bit_expr [NOT] REGEXP bit_expr
  | bit_expr

bit_expr:
    bit_expr | bit_expr
  | bit_expr & bit_expr
  | bit_expr << bit_expr
  | bit_expr >> bit_expr
  | bit_expr + bit_expr
  | bit_expr - bit_expr
  | bit_expr * bit_expr
  | bit_expr / bit_expr
  | bit_expr DIV bit_expr
  | bit_expr MOD bit_expr
  | bit_expr % bit_expr
  | bit_expr ^ bit_expr
  | bit_expr + interval_expr
  | bit_expr - interval_expr
  | simple_expr

simple_expr:
    literal
  | identifier
  | function_call
  | simple_expr COLLATE collation_name
  | param_marker
  | variable
  | simple_expr || simple_expr
  | + simple_expr
  | - simple_expr
  | ~ simple_expr
  | ! simple_expr
  | BINARY simple_expr
  | (expr [, expr] ...)
  | ROW (expr, expr [, expr] ...)
  | (subquery)
  | EXISTS (subquery)
  | {identifier expr}
  | match_expr
  | case_expr
  | interval_expr

Example -
mysql> select B'0101' << 1;
+--------------+
| B'0101' << 1 |
+--------------+
|           10 |
+--------------+
1 row in set (0.00 sec)

mysql> select 10 << 1;
+---------+
| 10 << 1 |
+---------+
|      20 |
+---------+
1 row in set (0.00 sec)

For operator precedence, see Section 12.4.1, “Operator Precedence”. The precedence and meaning of some operators depends on the SQL mode:
By default, || is a logical OR operator. With PIPES_AS_CONCAT enabled, || is string concatenation, with a precedence between ^ and the unary operators.
By default, ! has a higher precedence than NOT. With HIGH_NOT_PRECEDENCE enabled, ! and NOT have the same precedence.

param_marker is ? as used in prepared statements for placeholders. See Section 13.5.1, “PREPARE Statement”.

(subquery) indicates a subquery that returns a single value; that is, a scalar subquery. See Section 13.2.11.1, “The Subquery as Scalar Operand”.

{identifier expr} is ODBC escape syntax and is accepted for ODBC compatibility. The value is expr. The { and } curly braces in the syntax should be written literally; they are not metasyntax as used elsewhere in syntax descriptions.

match_expr indicates a MATCH expression. See Section 12.10, “Full-Text Search Functions”.

case_expr indicates a CASE expression. See Section 12.5, “Flow Control Functions”.

interval_expr represents a temporal interval. See Temporal Intervals.

Temporal Intervals
-------------------
interval_expr in expressions represents a temporal interval. Intervals have this syntax:
INTERVAL expr unit

expr represents a quantity. unit represents the unit for interpreting the quantity; it is a specifier such as HOUR, DAY, or WEEK. The INTERVAL keyword and the unit specifier are not case-sensitive.

The following table shows the expected form of the expr argument for each unit value.
Table 9.2 Temporal Interval Expression and Unit Arguments

unit Value	                        Expected expr Format
MICROSECOND	                        MICROSECONDS
SECOND	                            SECONDS
MINUTE	                            MINUTES
HOUR	                            HOURS
DAY	                                DAYS
WEEK	                            WEEKS
MONTH	                            MONTHS
QUARTER	                            QUARTERS
YEAR	                            YEARS
SECOND_MICROSECOND	                'SECONDS.MICROSECONDS'
MINUTE_MICROSECOND	                'MINUTES:SECONDS.MICROSECONDS'
MINUTE_SECOND	                    'MINUTES:SECONDS'
HOUR_MICROSECOND	                'HOURS:MINUTES:SECONDS.MICROSECONDS'
HOUR_SECOND	                        'HOURS:MINUTES:SECONDS'
HOUR_MINUTE	                        'HOURS:MINUTES'
DAY_MICROSECOND	                    'DAYS HOURS:MINUTES:SECONDS.MICROSECONDS'
DAY_SECOND	                        'DAYS HOURS:MINUTES:SECONDS'
DAY_MINUTE	                        'DAYS HOURS:MINUTES'
DAY_HOUR	                        'DAYS HOURS'
YEAR_MONTH	                        'YEARS-MONTHS'

MySQL permits any punctuation delimiter in the expr format. Those shown in the table are the suggested delimiters.
Temporal intervals are used for certain functions, such as DATE_ADD() and DATE_SUB():

mysql> select DATE_ADD('2021-05-01', INTERVAL 1 DAY);
+----------------------------------------+
| DATE_ADD('2021-05-01', INTERVAL 1 DAY) |
+----------------------------------------+
| 2021-05-02                             |
+----------------------------------------+
1 row in set (0.00 sec)

mysql> select DATE_ADD('2021-05-01', INTERVAL 1 WEEK);
+-----------------------------------------+
| DATE_ADD('2021-05-01', INTERVAL 1 WEEK) |
+-----------------------------------------+
| 2021-05-08                              |
+-----------------------------------------+
1 row in set (0.00 sec)

mysql> select DATE_ADD('2021-05-01', INTERVAL 1 MONTH);
+------------------------------------------+
| DATE_ADD('2021-05-01', INTERVAL 1 MONTH) |
+------------------------------------------+
| 2021-06-01                               |
+------------------------------------------+
1 row in set (0.00 sec)

mysql> select DATE_ADD('2021-05-01', INTERVAL 1 YEAR);
+-----------------------------------------+
| DATE_ADD('2021-05-01', INTERVAL 1 YEAR) |
+-----------------------------------------+
| 2022-05-01                              |
+-----------------------------------------+
1 row in set (0.00 sec)

mysql> select DATE_SUB('2021-05-01', INTERVAL 1 DAY);
+----------------------------------------+
| DATE_SUB('2021-05-01', INTERVAL 1 DAY) |
+----------------------------------------+
| 2021-04-30                             |
+----------------------------------------+
1 row in set (0.01 sec)

mysql> select DATE_SUB('2021-05-01', INTERVAL 1 WEEK);
+-----------------------------------------+
| DATE_SUB('2021-05-01', INTERVAL 1 WEEK) |
+-----------------------------------------+
| 2021-04-24                              |
+-----------------------------------------+
1 row in set (0.00 sec)

mysql> select DATE_SUB('2021-05-01', INTERVAL 1 MONTH);
+------------------------------------------+
| DATE_SUB('2021-05-01', INTERVAL 1 MONTH) |
+------------------------------------------+
| 2021-04-01                               |
+------------------------------------------+
1 row in set (0.00 sec)

mysql> select DATE_SUB('2021-05-01', INTERVAL 1 YEAR);
+-----------------------------------------+
| DATE_SUB('2021-05-01', INTERVAL 1 YEAR) |
+-----------------------------------------+
| 2020-05-01                              |
+-----------------------------------------+
1 row in set (0.00 sec)

mysql> select date_add('2021-12-31 23:59:59', INTERVAL 1 SECOND);
+----------------------------------------------------+
| date_add('2021-12-31 23:59:59', INTERVAL 1 SECOND) |
+----------------------------------------------------+
| 2022-01-01 00:00:00                                |
+----------------------------------------------------+
1 row in set (0.00 sec)

mysql> select date_add('2021-12-31 23:59:59', INTERVAL 1 DAY);
+-------------------------------------------------+
| date_add('2021-12-31 23:59:59', INTERVAL 1 DAY) |
+-------------------------------------------------+
| 2022-01-01 23:59:59                             |
+-------------------------------------------------+
1 row in set (0.00 sec)

mysql> select date_add('2021-12-31 23:59:59', INTERVAL '1:1' MINUTE_SECOND);
+---------------------------------------------------------------+
| date_add('2021-12-31 23:59:59', INTERVAL '1:1' MINUTE_SECOND) |
+---------------------------------------------------------------+
| 2022-01-01 00:01:00                                           |
+---------------------------------------------------------------+
1 row in set (0.00 sec)

mysql> select date_add('2021-12-31 23:59:59', INTERVAL '1 1:1:1' DAY_SECOND);
+----------------------------------------------------------------+
| date_add('2021-12-31 23:59:59', INTERVAL '1 1:1:1' DAY_SECOND) |
+----------------------------------------------------------------+
| 2022-01-02 01:01:00                                            |
+----------------------------------------------------------------+
1 row in set (0.00 sec)

mysql> select date_add('2021-12-31 23:59:59', INTERVAL '-1 1:1:1' DAY_SECOND);
+-----------------------------------------------------------------+
| date_add('2021-12-31 23:59:59', INTERVAL '-1 1:1:1' DAY_SECOND) |
+-----------------------------------------------------------------+
| 2021-12-30 22:58:58                                             |
+-----------------------------------------------------------------+
1 row in set (0.00 sec)

mysql> select date_add('2021-12-31 23:59:59', INTERVAL '-1 10' DAY_HOUR);
+------------------------------------------------------------+
| date_add('2021-12-31 23:59:59', INTERVAL '-1 10' DAY_HOUR) |
+------------------------------------------------------------+
| 2021-12-30 13:59:59                                        |
+------------------------------------------------------------+
1 row in set (0.00 sec)

mysql> select date_add('2021-12-31 23:59:58.000001', INTERVAL '1.999999' SECOND_MICROSECOND);
+--------------------------------------------------------------------------------+
| date_add('2021-12-31 23:59:58.000001', INTERVAL '1.999999' SECOND_MICROSECOND) |
+--------------------------------------------------------------------------------+
| 2022-01-01 00:00:00                                                            |
+--------------------------------------------------------------------------------+
1 row in set (0.00 sec)

Temporal arithmetic also can be performed in expressions using INTERVAL together with the + or - operator:

date + INTERVAL expr unit
date - INTERVAL expr unit
INTERVAL expr unit is permitted on either side of the + operator if the expression on the other side is a date or datetime value. For the - operator, INTERVAL expr unit is permitted only on the right side, because it makes no sense to subtract a date or datetime value from an interval.

mysql> select '2021-12-31 23:59:59' + INTERVAL 1 SECOND;
+-------------------------------------------+
| '2021-12-31 23:59:59' + INTERVAL 1 SECOND |
+-------------------------------------------+
| 2022-01-01 00:00:00                       |
+-------------------------------------------+
1 row in set (0.00 sec)

mysql> select INTERVAL 1 DAY + '2021-12-31 23:59:59';
+----------------------------------------+
| INTERVAL 1 DAY + '2021-12-31 23:59:59' |
+----------------------------------------+
| 2022-01-01 23:59:59                    |
+----------------------------------------+
1 row in set (0.00 sec)

mysql> select '2021-12-31 23:59:59' - INTERVAL 1 HOUR;
+-----------------------------------------+
| '2021-12-31 23:59:59' - INTERVAL 1 HOUR |
+-----------------------------------------+
| 2021-12-31 22:59:59                     |
+-----------------------------------------+
1 row in set (0.00 sec)

TESTING TEMPORAL WITH BINARY -
mysql> select '2021-12-31 23:59:59' >> 1;
+----------------------------+
| '2021-12-31 23:59:59' >> 1 |
+----------------------------+
|                       1010 |
+----------------------------+
1 row in set, 1 warning (0.00 sec)

mysql> SHOW WARNINGS;
+---------+------+----------------------------------------------------------+
| Level   | Code | Message                                                  |
+---------+------+----------------------------------------------------------+
| Warning | 1292 | Truncated incorrect INTEGER value: '2021-12-31 23:59:59' |
+---------+------+----------------------------------------------------------+
1 row in set (0.00 sec)

The EXTRACT() function uses the same kinds of unit specifiers as DATE_ADD() or DATE_SUB(), but extracts parts from the date rather than performing date arithmetic:
mysql> select extract(year from '2019-08-08');
+---------------------------------+
| extract(year from '2019-08-08') |
+---------------------------------+
|                            2019 |
+---------------------------------+
1 row in set (0.00 sec)

mysql> select extract(year_month from '2019-08-08');
+---------------------------------------+
| extract(year_month from '2019-08-08') |
+---------------------------------------+
|                                201908 |
+---------------------------------------+
1 row in set (0.00 sec)

Temporal intervals can be used in CREATE EVENT statements:
CREATE EVENT myevent
    ON SCHEDULE AT CURRENT_TIMESTAMP + INTERVAL 1 HOUR
    DO
      UPDATE myschema.mytable SET mycol = mycol + 1;

Example -
mysql> create event myevent
    -> on schedule at current_timestamp + INTERVAL 2 minute
    -> do
    -> update pet set owner = 'Raja' where name='Bruzo';

mysql> select * from pet;
+----------+--------+---------+------+------------+------------+
| name     | owner  | species | sex  | birth      | death      |
+----------+--------+---------+------+------------+------------+
| Fluffy   | Harold | cat     | F    | 1993-02-04 | NULL       |
| Claws    | Gwen   | cat     | M    | 1994-03-17 | NULL       |
| Buffy    | Harold | dog     | F    | 1989-05-13 | NULL       |
| Fang     | Benny  | dog     | M    | 1990-08-27 | NULL       |
| Bowser   | Diane  | dog     | M    | 1989-08-31 | 1995-07-29 |
| Chirpy   | Gwen   | bird    | F    | 1998-09-11 | NULL       |
| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |
| Slim     | Benny  | snake   | M    | 1996-04-29 | NULL       |
| bruzo    | Raja   | dog     | M    | 2019-01-04 | NULL       |
+----------+--------+---------+------+------------+------------+

If you specify an interval value that is too short (does not include all the interval parts that would be expected from the unit keyword), MySQL assumes that you have left out the leftmost parts of the interval value. For example, if you specify a unit of DAY_SECOND, the value of expr is expected to have days, hours, minutes, and seconds parts. If you specify a value like '1:10', MySQL assumes that the days and hours parts are missing and the value represents minutes and seconds. In other words, '1:10' DAY_SECOND is interpreted in such a way that it is equivalent to '1:10' MINUTE_SECOND. This is analogous to the way that MySQL interprets TIME values as representing elapsed time rather than as a time of day.

expr is treated as a string, so be careful if you specify a nonstring value with INTERVAL. For example, with an interval specifier of HOUR_MINUTE, '6/4' is treated as 6 hours, four minutes, whereas 6/4 evaluates to 1.5000 and is treated as 1 hour, 5000 minutes:

mysql> select date_Add('2020.01.01', INTERVAL '6/4' HOUR_MINUTE);
+----------------------------------------------------+
| date_Add('2020.01.01', INTERVAL '6/4' HOUR_MINUTE) |
+----------------------------------------------------+
| 2020-01-01 06:04:00                                |
+----------------------------------------------------+
1 row in set (0.00 sec)

mysql> select date_add('2021.01.01', INTERVAL 6/4 HOUR_MINUTE);
+--------------------------------------------------+
| date_add('2021.01.01', INTERVAL 6/4 HOUR_MINUTE) |
+--------------------------------------------------+
| 2021-01-04 12:20:00                              |
+--------------------------------------------------+

To ensure interpretation of the interval value as you expect, a CAST() operation may be used. To treat 6/4 as 1 hour, 5 minutes, cast it to a DECIMAL value with a single fractional digit:
mysql> select cast(6/4 as decimal(3,1));
+---------------------------+
| cast(6/4 as decimal(3,1)) |
+---------------------------+
|                       1.5 |
+---------------------------+
1 row in set (0.00 sec)

mysql> select date_Add('2020.01.01 12:00:00', INTERVAL CAST(6/4 AS DECIMAL(3,1)) HOUR_MINUTE);
+---------------------------------------------------------------------------------+
| date_Add('2020.01.01 12:00:00', INTERVAL CAST(6/4 AS DECIMAL(3,1)) HOUR_MINUTE) |
+---------------------------------------------------------------------------------+
| 2020-01-01 13:05:00                                                             |
+---------------------------------------------------------------------------------+
1 row in set (0.00 sec)

f you add to or subtract from a date value something that contains a time part, the result is automatically converted to a datetime value:

mysql> SELECT DATE_ADD('2023-01-01', INTERVAL 1 DAY);
        -> '2023-01-02'
mysql> SELECT DATE_ADD('2023-01-01', INTERVAL 1 HOUR);
        -> '2023-01-01 01:00:00'

If you add MONTH, YEAR_MONTH, or YEAR and the resulting date has a day that is larger than the maximum day for the new month, the day is adjusted to the maximum days in the new month:
mysql> SELECT DATE_ADD('2019-01-30', INTERVAL 1 MONTH);
        -> '2019-02-28'

Date arithmetic operations require complete dates and do not work with incomplete dates such as '2016-07-00' or badly malformed dates:
mysql> SELECT DATE_ADD('2016-07-00', INTERVAL 1 DAY);
        -> NULL
mysql> SELECT '2005-03-32' + INTERVAL 1 MONTH;
        -> NULL

TEST:
mysql> select date_Add('2020.01.01', INTERVAL '-1 1:1' DAY_MINUTE);
+------------------------------------------------------+
| date_Add('2020.01.01', INTERVAL '-1 1:1' DAY_MINUTE) |
+------------------------------------------------------+
| 2019-12-30 22:59:00                                  |
+------------------------------------------------------+
1 row in set (0.00 sec)

9.6 Query Attributes - https://dev.mysql.com/doc/refman/8.0/en/query-attributes.html
Support from MySQL 8.0.23

9.7 Comments
-------------
MySQL Server supports three comment styles:
From a # character to the end of the line.
From a --  sequence to the end of the line. In MySQL, the --  (double-dash) comment style requires the second dash to be followed by at least one whitespace or control character (such as a space, tab, newline, and so on). This syntax differs slightly from standard SQL comment syntax, as discussed in Section 1.7.2.4, “'--' as the Start of a Comment”.
From a /* sequence to the following */ sequence, as in the C programming language. This syntax enables a comment to extend over multiple lines because the beginning and closing sequences need not be on the same line.


Chapter 11 Data Types
=======================
MySQL supports SQL data types in several categories: numeric types, date and time types, string (character and byte) types, spatial types, and the JSON data type. This chapter provides an overview and more detailed description of the properties of the types in each category, and a summary of the data type storage requirements. The initial overviews are intentionally brief. Consult the more detailed descriptions for additional information about particular data types, such as the permissible formats in which you can specify values.

Data type descriptions use these conventions:

For integer types, M indicates the maximum display width. For floating-point and fixed-point types, M is the total number of digits that can be stored (the precision). For string types, M is the maximum length. The maximum permissible value of M depends on the data type.

 D applies to floating-point and fixed-point types and indicates the number of digits following the decimal point (the scale). The maximum possible value is 30, but should be no greater than M−2.

fsp applies to the TIME, DATETIME, and TIMESTAMP types and represents fractional seconds precision; that is, the number of digits following the decimal point for fractional parts of seconds. The fsp value, if given, must be in the range 0 to 6. A value of 0 signifies that there is no fractional part. If omitted, the default precision is 0. (This differs from the standard SQL default of 6, for compatibility with previous MySQL versions.)

Square brackets ([ and ]) indicate optional parts of type definitions.

MySQL supports all standard SQL numeric data types. These types include the exact numeric data types (INTEGER, SMALLINT, DECIMAL, and NUMERIC), as well as the approximate numeric data types (FLOAT, REAL, and DOUBLE PRECISION). The keyword INT is a synonym for INTEGER, and the keywords DEC and FIXED are synonyms for DECIMAL. MySQL treats DOUBLE as a synonym for DOUBLE PRECISION (a nonstandard extension). MySQL also treats REAL as a synonym for DOUBLE PRECISION (a nonstandard variation), unless the REAL_AS_FLOAT SQL mode is enabled.

The BIT data type stores bit values and is supported for MyISAM, MEMORY, InnoDB, and NDB tables.

11.1.1 Numeric Data Type Syntax
--------------------------------
For integer data types, M indicates the maximum display width. The maximum display width is 255. Display width is unrelated to the range of values a type can store

For floating-point and fixed-point data types, M is the total number of digits that can be stored.

As of MySQL 8.0.17, the display width attribute is deprecated for integer data types; you should expect support for it to be removed in a future version of MySQL.

If you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column.

As of MySQL 8.0.17, the ZEROFILL attribute is deprecated for numeric data types; you should expect support for it to be removed in a future version of MySQL. Consider using an alternative means of producing the effect of this attribute. For example, applications could use the LPAD() function to zero-pad numbers up to the desired width, or they could store the formatted numbers in CHAR columns.

SERIAL is an alias for BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE.

SERIAL DEFAULT VALUE in the definition of an integer column is an alias for NOT NULL AUTO_INCREMENT UNIQUE.

Warning
When you use subtraction between integer values where one is of type UNSIGNED, the result is unsigned unless the NO_UNSIGNED_SUBTRACTION SQL mode is enabled

 BIT[(M)]

A bit-value type. M indicates the number of bits per value, from 1 to 64. The default is 1 if M is omitted.

 TINYINT[(M)] [UNSIGNED] [ZEROFILL]

A very small integer. The signed range is -128 to 127. The unsigned range is 0 to 255.

 BOOL, BOOLEAN

These types are synonyms for TINYINT(1). A value of zero is considered false. Nonzero values are considered true:

mysql> select IF(0, 'TRUE', 'False');
+------------------------+
| IF(0, 'TRUE', 'False') |
+------------------------+
| False                  |
+------------------------+
1 row in set (0.00 sec)

mysql> select IF(1, 'TRUE', 'False');
+------------------------+
| IF(1, 'TRUE', 'False') |
+------------------------+
| TRUE                   |
+------------------------+
1 row in set (0.01 sec)

mysql> select IF(2, 'TRUE', 'False');
+------------------------+
| IF(2, 'TRUE', 'False') |
+------------------------+
| TRUE                   |
+------------------------+
1 row in set (0.00 sec)

However, the values TRUE and FALSE are merely aliases for 1 and 0, respectively, as shown here:
mysql> select if(0=false, True, False);
+--------------------------+
| if(0=false, True, False) |
+--------------------------+
|                        1 |
+--------------------------+
1 row in set (0.01 sec)

mysql> select if(1=false, True, False);
+--------------------------+
| if(1=false, True, False) |
+--------------------------+
|                        0 |
+--------------------------+
1 row in set (0.00 sec)

mysql> select if(1=True, True, False);
+-------------------------+
| if(1=True, True, False) |
+-------------------------+
|                       1 |
+-------------------------+
1 row in set (0.00 sec)

mysql> select if(2=True, True, False);
+-------------------------+
| if(2=True, True, False) |
+-------------------------+
|                       0 |
+-------------------------+
1 row in set (0.00 sec)

mysql> select if(2=False, True, False);
+--------------------------+
| if(2=False, True, False) |
+--------------------------+
|                        0 |
+--------------------------+
1 row in set (0.00 sec)
The last two statements display the results shown because 2 is equal to neither 1 nor 0.

 SMALLINT[(M)] [UNSIGNED] [ZEROFILL]

A small integer. The signed range is -32768 to 32767. The unsigned range is 0 to 65535.

 MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL]

A medium-sized integer. The signed range is -8388608 to 8388607. The unsigned range is 0 to 16777215.

 INT[(M)] [UNSIGNED] [ZEROFILL]

A normal-size integer. The signed range is -2147483648 to 2147483647. The unsigned range is 0 to 4294967295.

 INTEGER[(M)] [UNSIGNED] [ZEROFILL]

This type is a synonym for INT.

 BIGINT[(M)] [UNSIGNED] [ZEROFILL]

A large integer. The signed range is -9223372036854775808 to 9223372036854775807. The unsigned range is 0 to 18446744073709551615.

SERIAL is an alias for BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE.

NOTE - Get more details from Udemy.txt


11.1.3 Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC
----------------------------------------------------------
In this example, 5 is the precision and 2 is the scale. The precision represents the number of significant digits that are stored for values, and the scale represents the number of digits that can be stored following the decimal point.

Standard SQL requires that DECIMAL(5,2) be able to store any value with five digits and two decimals, so values that can be stored in the salary column range from -999.99 to 999.99.

In standard SQL, the syntax DECIMAL(M) is equivalent to DECIMAL(M,0). Similarly, the syntax DECIMAL is equivalent to DECIMAL(M,0), where the implementation is permitted to decide the value of M. MySQL supports both of these variant forms of DECIMAL syntax. The default value of M is 10.

If the scale is 0, DECIMAL values contain no decimal point or fractional part.

The maximum number of digits for DECIMAL is 65, but the actual range for a given DECIMAL column can be constrained by the precision or scale for a given column. When such a column is assigned a value with more digits following the decimal point than are permitted by the specified scale, the value is converted to that scale. (The precise behavior is operating system-specific, but generally the effect is truncation to the permissible number of digits.)

11.1.4 Floating-Point Types (Approximate Value) - FLOAT, DOUBLE
----------------------------------------------------------------
The FLOAT and DOUBLE types represent approximate numeric data values. MySQL uses four bytes for single-precision values and eight bytes for double-precision values.

For FLOAT, the SQL standard permits an optional specification of the precision (but not the range of the exponent) in bits following the keyword FLOAT in parentheses; ; that is, FLOAT(p). MySQL also supports this optional precision specification, but the precision value in FLOAT(p) is used only to determine storage size. A precision from 0 to 23 results in a 4-byte single-precision FLOAT column. A precision from 24 to 53 results in an 8-byte double-precision DOUBLE column.

MySQL permits a nonstandard syntax: FLOAT(M,D) or REAL(M,D) or DOUBLE PRECISION(M,D). Here, (M,D) means than values can be stored with up to M digits in total, of which D digits may be after the decimal point. For example, a column defined as FLOAT(7,4) is displayed as -999.9999. MySQL performs rounding when storing values, so if you insert 999.00009 into a FLOAT(7,4) column, the approximate result is 999.0001.

As of MySQL 8.0.17, the nonstandard FLOAT(M,D) and DOUBLE(M,D) syntax is deprecated and you should expect support for it to be removed in a future version of MySQL.

Because floating-point values are approximate and not stored as exact values, attempts to treat them as exact in comparisons may lead to problems. They are also subject to platform or implementation dependencies. For more information, see Section B.3.4.8, “Problems with Floating-Point Values”

For maximum portability, code requiring storage of approximate numeric data values should use FLOAT or DOUBLE PRECISION with no specification of precision or number of digits.

11.1.5 Bit-Value Type - BIT
----------------------------
The BIT data type is used to store bit values. A type of BIT(M) enables storage of M-bit values. M can range from 1 to 64.

To specify bit values, b'value' notation can be used. value is a binary value written using zeros and ones. For example, b'111' and b'10000000' represent 7 and 128, respectively. See Section 9.1.5, “Bit-Value Literals”.

If you assign a value to a BIT(M) column that is less than M bits long, the value is padded on the left with zeros. For example, assigning a value of b'101' to a BIT(6) column is, in effect, the same as assigning b'000101'.

NDB Cluster.  The maximum combined size of all BIT columns used in a given NDB table must not exceed 4096 bits.

11.1.7 Out-of-Range and Overflow Handling
-----------------------------------------
When MySQL stores a value in a numeric column that is outside the permissible range of the column data type, the result depends on the SQL mode in effect at the time:

If strict SQL mode is enabled, MySQL rejects the out-of-range value with an error, and the insert fails, in accordance with the SQL standard.

If no restrictive modes are enabled, MySQL clips the value to the appropriate endpoint of the column data type range and stores the resulting value instead.

When an out-of-range value is assigned to an integer column, MySQL stores the value representing the corresponding endpoint of the column data type range.

When a floating-point or fixed-point column is assigned a value that exceeds the range implied by the specified (or default) precision and scale, MySQL stores the value representing the corresponding endpoint of that range.

Suppose that a table t1 has this definition:
mysql> create table t1 (i1 TINYINT, i2 TINYINT UNSIGNED);
Query OK, 0 rows affected (0.01 sec)

With strict SQL mode enabled, an out of range error occurs:
mysql> set sql_mode = 'Traditional';
Query OK, 0 rows affected (0.00 sec)

mysql> insert into t1(i1, i2) values(256, 256);
ERROR 1264 (22003): Out of range value for column 'i1' at row 1
mysql> select * from t1;
Empty set (0.00 sec)

With strict SQL mode not enabled, clipping with warnings occurs:
mysql> set sql_mode = '';
Query OK, 0 rows affected (0.00 sec)

mysql> insert into t1(i1, i2) values(256, 256);
Query OK, 1 row affected, 2 warnings (0.00 sec)

mysql> show warnings;
+---------+------+---------------------------------------------+
| Level   | Code | Message                                     |
+---------+------+---------------------------------------------+
| Warning | 1264 | Out of range value for column 'i1' at row 1 |
| Warning | 1264 | Out of range value for column 'i2' at row 1 |
+---------+------+---------------------------------------------+
2 rows in set (0.00 sec)

mysql> select * from t1;
+------+------+
| i1   | i2   |
+------+------+
|  127 |  255 |
+------+------+
1 row in set (0.00 sec)

When strict SQL mode is not enabled, column-assignment conversions that occur due to clipping are reported as warnings for ALTER TABLE, LOAD DATA, UPDATE, and multiple-row INSERT statements. In strict mode, these statements fail, and some or all the values are not inserted or changed, depending on whether the table is a transactional table and other factors.

Overflow during numeric expression evaluation results in an error. For example, the largest signed BIGINT value is 9223372036854775807, so the following expression produces an error:
mysql> SELECT 9223372036854775807 + 1;
ERROR 1690 (22003): BIGINT value is out of range in '(9223372036854775807 + 1)'

To enable the operation to succeed in this case, convert the value to unsigned;
mysql> SELECT CAST(9223372036854775807 AS UNSIGNED) + 1;
+-------------------------------------------+
| CAST(9223372036854775807 AS UNSIGNED) + 1 |
+-------------------------------------------+
|                       9223372036854775808 |
+-------------------------------------------+
1 row in set (0.00 sec)

Whether overflow occurs depends on the range of the operands, so another way to handle the preceding expression is to use exact-value arithmetic because DECIMAL values have a larger range than integers:
mysql> SELECT 9223372036854775807.0 + 1;
+---------------------------+
| 9223372036854775807.0 + 1 |
+---------------------------+
|     9223372036854775808.0 |
+---------------------------+
1 row in set (0.00 sec)

Subtraction between integer values, where one is of type UNSIGNED, produces an unsigned result by default. If the result would otherwise have been negative, an error results:
mysql> select sql_mode = '';
ERROR 1054 (42S22): Unknown column 'sql_mode' in 'field list'
mysql> set sql_mode = '';
Query OK, 0 rows affected (0.00 sec)

mysql> select cast(0 as unsigned) - 1;
ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in '(cast(0 as unsigned) - 1)'

Addition works
mysql> select cast(0 as unsigned) + 1;
+-------------------------+
| cast(0 as unsigned) + 1 |
+-------------------------+
|                       1 |
+-------------------------+
1 row in set (0.00 sec)

mysql> SET sql_mode = 'NO_UNSIGNED_SUBTRACTION';
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT CAST(0 AS UNSIGNED) - 1;
+-------------------------+
| CAST(0 AS UNSIGNED) - 1 |
+-------------------------+
|                      -1 |
+-------------------------+
1 row in set (0.00 sec)

If the result of such an operation is used to update an UNSIGNED integer column, the result is clipped to the maximum value for the column type, or clipped to 0 if NO_UNSIGNED_SUBTRACTION is enabled. If strict SQL mode is enabled, an error occurs and the column remains unchanged.

11.2 Date and Time Data Types
-----------------------------
The date and time data types for representing temporal values are DATE, TIME, DATETIME, TIMESTAMP, and YEAR. Each temporal type has a range of valid values, as well as a “zero” value that may be used when you specify an invalid value that MySQL cannot represent. The TIMESTAMP and DATETIME types have special automatic updating behavior.
MySQL retrieves values for a given date or time type in a standard output format, but it attempts to interpret a variety of formats for input values that you supply (for example, when you specify a value to be assigned to or compared to a date or time type). For a description of the permitted formats for date and time types.It is expected that you supply valid values. Unpredictable results may occur if you use values in other formats.
Although MySQL tries to interpret values in several formats, date parts must always be given in year-month-day order (for example, '98-09-04'), rather than in the month-day-year or day-month-year orders commonly used elsewhere (for example, '09-04-98', '04-09-98'). To convert strings in other orders to year-month-day order, the STR_TO_DATE() function may be useful.

Dates containing 2-digit year values are ambiguous because the century is unknown. MySQL interprets 2-digit year values using these rules:
Year values in the range 70-99 become 1970-1999.
Year values in the range 00-69 become 2000-2069.

MySQL automatically converts a date or time value to a number if the value is used in numeric context and vice versa.
By default, when MySQL encounters a value for a date or time type that is out of range or otherwise invalid for the type, it converts the value to the “zero” value for that type. The exception is that out-of-range TIME values are clipped to the appropriate endpoint of the TIME range.

11.2.1 Date and Time Data Type Syntax
--------------------------------------
The date and time data types for representing temporal values are DATE, TIME, DATETIME, TIMESTAMP, and YEAR. Each temporal type has a range of valid values, as well as a “zero” value that may be used when you specify an invalid value that MySQL cannot represent. The TIMESTAMP and DATETIME types have special automatic updating behavior, described in Section 11.2.5, “Automatic Initialization and Updating for TIMESTAMP and DATETIME”.

For information about storage requirements of the temporal data types, see Section 11.7, “Data Type Storage Requirements”.

For descriptions of functions that operate on temporal values, see Section 12.7, “Date and Time Functions”.

Keep in mind these general considerations when working with date and time types:

MySQL retrieves values for a given date or time type in a standard output format, but it attempts to interpret a variety of formats for input values that you supply (for example, when you specify a value to be assigned to or compared to a date or time type). For a description of the permitted formats for date and time types, see Section 9.1.3, “Date and Time Literals”. It is expected that you supply valid values. Unpredictable results may occur if you use values in other formats.

Although MySQL tries to interpret values in several formats, date parts must always be given in year-month-day order (for example, '98-09-04'), rather than in the month-day-year or day-month-year orders commonly used elsewhere (for example, '09-04-98', '04-09-98'). To convert strings in other orders to year-month-day order, the STR_TO_DATE() function may be useful.

Dates containing 2-digit year values are ambiguous because the century is unknown. MySQL interprets 2-digit year values using these rules:

Year values in the range 70-99 become 1970-1999.

Year values in the range 00-69 become 2000-2069.

See also Section 11.2.8, “2-Digit Years in Dates”.

Conversion of values from one temporal type to another occurs according to the rules in Section 11.2.7, “Conversion Between Date and Time Types”.

MySQL automatically converts a date or time value to a number if the value is used in numeric context and vice versa.

By default, when MySQL encounters a value for a date or time type that is out of range or otherwise invalid for the type, it converts the value to the “zero” value for that type. The exception is that out-of-range TIME values are clipped to the appropriate endpoint of the TIME range.

By setting the SQL mode to the appropriate value, you can specify more exactly what kind of dates you want MySQL to support. (See Section 5.1.11, “Server SQL Modes”.) You can get MySQL to accept certain dates, such as '2009-11-31', by enabling the ALLOW_INVALID_DATES SQL mode. This is useful when you want to store a “possibly wrong” value which the user has specified (for example, in a web form) in the database for future processing. Under this mode, MySQL verifies only that the month is in the range from 1 to 12 and that the day is in the range from 1 to 31.

MySQL permits you to store dates where the day or month and day are zero in a DATE or DATETIME column. This is useful for applications that need to store birthdates for which you may not know the exact date. In this case, you simply store the date as '2009-00-00' or '2009-01-00'. However, with dates such as these, you should not expect to get correct results for functions such as DATE_SUB() or DATE_ADD() that require complete dates. To disallow zero month or day parts in dates, enable the NO_ZERO_IN_DATE mode.

MySQL permits you to store a “zero” value of '0000-00-00' as a “dummy date.” In some cases, this is more convenient than using NULL values, and uses less data and index space. To disallow '0000-00-00', enable the NO_ZERO_DATE mode.

“Zero” date or time values used through Connector/ODBC are converted automatically to NULL because ODBC cannot handle such values.

The following table shows the format of the “zero” value for each type. The “zero” values are special, but you can store or refer to them explicitly using the values shown in the table. You can also do this using the values '0' or 0, which are easier to write. For temporal types that include a date part (DATE, DATETIME, and TIMESTAMP), use of these values may produce warning or errors. The precise behavior depends on which, if any, of the strict and NO_ZERO_DATE SQL modes are enabled; see Section 5.1.11, “Server SQL Modes”.

Data Type	“Zero” Value
DATE	    '0000-00-00'
TIME	    '00:00:00'
DATETIME	'0000-00-00 00:00:00'
TIMESTAMP	'0000-00-00 00:00:00'
YEAR	    0000

11.2.1 Date and Time Data Type Syntax
--------------------------------------
The date and time data types for representing temporal values are DATE, TIME, DATETIME, TIMESTAMP, and YEAR.

For the DATE and DATETIME range descriptions, “supported” means that although earlier values might work, there is no guarantee.

MySQL permits fractional seconds for TIME, DATETIME, and TIMESTAMP values, with up to microseconds (6 digits) precision. To define a column that includes a fractional seconds part, use the syntax type_name(fsp), where type_name is TIME, DATETIME, or TIMESTAMP, and fsp is the fractional seconds precision. For example:
mysql> create table t1(t TIME(3), dt DATETIME(6), ts TIMESTAMP(0));
The fsp value, if given, must be in the range 0 to 6. A value of 0 signifies that there is no fractional part. If omitted, the default precision is 0. (This differs from the standard SQL default of 6, for compatibility with previous MySQL versions.)

Any TIMESTAMP or DATETIME column in a table can have automatic initialization and updating properties;
DATE
=====
A date. The supported range is '1000-01-01' to '9999-12-31'. MySQL displays DATE values in 'YYYY-MM-DD' format, but permits assignment of values to DATE columns using either strings or numbers.

 DATETIME[(fsp)]
================
A date and time combination. The supported range is '1000-01-01 00:00:00.000000' to '9999-12-31 23:59:59.999999'. MySQL displays DATETIME values in 'YYYY-MM-DD hh:mm:ss[.fraction]' format, but permits assignment of values to DATETIME columns using either strings or numbers.

An optional fsp value in the range from 0 to 6 may be given to specify fractional seconds precision. A value of 0 signifies that there is no fractional part. If omitted, the default precision is 0.

Automatic initialization and updating to the current date and time for DATETIME columns can be specified using DEFAULT and ON UPDATE column definition clauses

 TIMESTAMP[(fsp)]
=================
A timestamp. The range is '1970-01-01 00:00:01.000000' UTC to '2038-01-19 03:14:07.999999' UTC. TIMESTAMP values are stored as the number of seconds since the epoch ('1970-01-01 00:00:00' UTC). A TIMESTAMP cannot represent the value '1970-01-01 00:00:00' because that is equivalent to 0 seconds from the epoch and the value 0 is reserved for representing '0000-00-00 00:00:00', the “zero” TIMESTAMP value.

An optional fsp value in the range from 0 to 6 may be given to specify fractional seconds precision. A value of 0 signifies that there is no fractional part. If omitted, the default precision is 0.

The way the server handles TIMESTAMP definitions depends on the value of the explicit_defaults_for_timestamp system variable (see Section 5.1.8, “Server System Variables”).

If explicit_defaults_for_timestamp is enabled, there is no automatic assignment of the DEFAULT CURRENT_TIMESTAMP or ON UPDATE CURRENT_TIMESTAMP attributes to any TIMESTAMP column. They must be included explicitly in the column definition. Also, any TIMESTAMP not explicitly declared as NOT NULL permits NULL values.

If explicit_defaults_for_timestamp is disabled, the server handles TIMESTAMP as follows:

Unless specified otherwise, the first TIMESTAMP column in a table is defined to be automatically set to the date and time of the most recent modification if not explicitly assigned a value. This makes TIMESTAMP useful for recording the timestamp of an INSERT or UPDATE operation. You can also set any TIMESTAMP column to the current date and time by assigning it a NULL value, unless it has been defined with the NULL attribute to permit NULL values.

Automatic initialization and updating to the current date and time can be specified using DEFAULT CURRENT_TIMESTAMP and ON UPDATE CURRENT_TIMESTAMP column definition clauses. By default, the first TIMESTAMP column has these properties, as previously noted. However, any TIMESTAMP column in a table can be defined to have these properties.


 TIME[(fsp)]
=============
A time. The range is '-838:59:59.000000' to '838:59:59.000000'. MySQL displays TIME values in 'hh:mm:ss[.fraction]' format, but permits assignment of values to TIME columns using either strings or numbers.

An optional fsp value in the range from 0 to 6 may be given to specify fractional seconds precision. A value of 0 signifies that there is no fractional part. If omitted, the default precision is 0.

 YEAR[(4)]
==========
A year in 4-digit format. MySQL displays YEAR values in YYYY format, but permits assignment of values to YEAR columns using either strings or numbers. Values display as 1901 to 2155, or 0000.

For additional information about YEAR display format and interpretation of input values,

Note
As of MySQL 8.0.19, the YEAR(4) data type with an explicit display width is deprecated; you should expect support for it to be removed in a future version of MySQL. Instead, use YEAR without a display width, which has the same meaning.

MySQL 8.0 does not support the 2-digit YEAR(2) data type permitted in older versions of MySQL. For instructions on converting to 4-digit YEAR, see 2-Digit YEAR(2) Limitations and Migrating to 4-Digit YEAR, in MySQL 5.7 Reference Manual.

mysql> insert into t1 value (
    -> '10:11:12.123', '2021-01-02 10:11:12.123456', '2021-01-02 10:11:12');
Query OK, 1 row affected (0.01 sec)

mysql> select * from T1;
+--------------+----------------------------+---------------------+
| t            | dt                         | ts                  |
+--------------+----------------------------+---------------------+
| 10:11:12.123 | 2021-01-02 10:11:12.123456 | 2021-01-02 10:11:12 |
+--------------+----------------------------+---------------------+
1 row in set (0.00 sec)

mysql> insert into t1 value ( '10:11:13.123', '2021-01-02 10:11:13.123456', '2021-01-02 10:11:13.123456');
Query OK, 1 row affected (0.00 sec)

mysql> select * from T1;
+--------------+----------------------------+---------------------+
| t            | dt                         | ts                  |
+--------------+----------------------------+---------------------+
| 10:11:12.123 | 2021-01-02 10:11:12.123456 | 2021-01-02 10:11:12 |
| 10:11:13.123 | 2021-01-02 10:11:13.123456 | 2021-01-02 10:11:13 |
+--------------+----------------------------+---------------------+

The SUM() and AVG() aggregate functions do not work with temporal values. (They convert the values to numbers, losing everything after the first nonnumeric character.) To work around this problem, convert to numeric units, perform the aggregate operation, and convert back to a temporal value. Examples:
Disection of
SELECT SEC_TO_TIME(SUM(TIME_TO_SEC(time_col))) FROM tbl_name;


mysql> select TIME_TO_SEC(t) from t1;
+----------------+
| TIME_TO_SEC(t) |
+----------------+
|          36672 |
|          36673 |
+----------------+
2 rows in set (0.00 sec)

mysql> select sum(TIME_TO_SEC(t)) from t1;
+---------------------+
| sum(TIME_TO_SEC(t)) |
+---------------------+
|               73345 |
+---------------------+
1 row in set (0.01 sec)

mysql> select SEC_TO_TIME(sum(TIME_TO_SEC(t))) from t1;
+----------------------------------+
| SEC_TO_TIME(sum(TIME_TO_SEC(t))) |
+----------------------------------+
| 20:22:25                         |
+----------------------------------+
1 row in set (0.00 sec)


Disection of - SELECT FROM_DAYS(SUM(TO_DAYS(date_col))) FROM tbl_name;
mysql> select TO_DAYS(dt) from t1;
+-------------+
| TO_DAYS(dt) |
+-------------+
|      738157 |
|      738157 |
+-------------+
2 rows in set (0.01 sec)

mysql> select sum(TO_DAYS(dt)) from t1;
+------------------+
| sum(TO_DAYS(dt)) |
+------------------+
|          1476314 |
+------------------+
1 row in set (0.00 sec)

mysql> select FROM_DAYS(sum(TO_DAYS(dt))) from t1;
+-----------------------------+
| FROM_DAYS(sum(TO_DAYS(dt))) |
+-----------------------------+
| 4042-01-04                  |
+-----------------------------+
1 row in set (0.00 sec)


11.2.2 The DATE, DATETIME, and TIMESTAMP Types
-----------------------------------------------
The DATE, DATETIME, and TIMESTAMP types are related. This section describes their characteristics, how they are similar, and how they differ. MySQL recognizes DATE, DATETIME, and TIMESTAMP values in several formats, described in Section 9.1.3, “Date and Time Literals”. For the DATE and DATETIME range descriptions, “supported” means that although earlier values might work, there is no guarantee.

The DATE type is used for values with a date part but no time part. MySQL retrieves and displays DATE values in 'YYYY-MM-DD' format. The supported range is '1000-01-01' to '9999-12-31'.

The DATETIME type is used for values that contain both date and time parts. MySQL retrieves and displays DATETIME values in 'YYYY-MM-DD hh:mm:ss' format. The supported range is '1000-01-01 00:00:00' to '9999-12-31 23:59:59'.

The TIMESTAMP data type is used for values that contain both date and time parts. TIMESTAMP has a range of '1970-01-01 00:00:01' UTC to '2038-01-19 03:14:07' UTC.

A DATETIME or TIMESTAMP value can include a trailing fractional seconds part in up to microseconds (6 digits) precision. In particular, any fractional part in a value inserted into a DATETIME or TIMESTAMP column is stored rather than discarded. With the fractional part included, the format for these values is 'YYYY-MM-DD hh:mm:ss[.fraction]', the range for DATETIME values is '1000-01-01 00:00:00.000000' to '9999-12-31 23:59:59.999999', and the range for TIMESTAMP values is '1970-01-01 00:00:01.000000' to '2038-01-19 03:14:07.999999'. The fractional part should always be separated from the rest of the time by a decimal point; no other fractional seconds delimiter is recognized. For information about fractional seconds support in MySQL, see Section 11.2.6, “Fractional Seconds in Time Values”.

The TIMESTAMP and DATETIME data types offer automatic initialization and updating to the current date and time. For more information, see Section 11.2.5, “Automatic Initialization and Updating for TIMESTAMP and DATETIME”.

MySQL converts TIMESTAMP values from the current time zone to UTC for storage, and back from UTC to the current time zone for retrieval. (This does not occur for other types such as DATETIME.) By default, the current time zone for each connection is the server's time. The time zone can be set on a per-connection basis. As long as the time zone setting remains constant, you get back the same value you store. If you store a TIMESTAMP value, and then change the time zone and retrieve the value, the retrieved value is different from the value you stored. This occurs because the same time zone was not used for conversion in both directions. The current time zone is available as the value of the time_zone system variable. For more information, see Section 5.1.15, “MySQL Server Time Zone Support”.

In MySQL 8.0.19 and later, you can specify a time zone offset when inserting a TIMESTAMP or DATETIME value into a table. See Section 9.1.3, “Date and Time Literals”, for more information and examples.

Invalid DATE, DATETIME, or TIMESTAMP values are converted to the “zero” value of the appropriate type ('0000-00-00' or '0000-00-00 00:00:00'), if the SQL mode permits this conversion. The precise behavior depends on which if any of strict SQL mode and the NO_ZERO_DATE SQL mode are enabled;

In MySQL 8.0.22 and later, you can convert TIMESTAMP values to UTC DATETIME values when retrieving them using CAST() with the AT TIME ZONE operator, as shown here:
mysql> SELECT col,
     >     CAST(col AT TIME ZONE INTERVAL '+00:00' AS DATETIME) AS ut
     >     FROM ts ORDER BY id;
+---------------------+---------------------+
| col                 | ut                  |
+---------------------+---------------------+
| 2020-01-01 10:10:10 | 2020-01-01 15:10:10 |
| 2019-12-31 23:40:10 | 2020-01-01 04:40:10 |
| 2020-01-01 13:10:10 | 2020-01-01 18:10:10 |
| 2020-01-01 10:10:10 | 2020-01-01 15:10:10 |
| 2020-01-01 04:40:10 | 2020-01-01 09:40:10 |
| 2020-01-01 18:10:10 | 2020-01-01 23:10:10 |
+---------------------+---------------------+

For complete information regarding syntax and additional examples, see the description of the CAST() function.

Be aware of certain properties of date value interpretation in MySQL:

MySQL permits a “relaxed” format for values specified as strings, in which any punctuation character may be used as the delimiter between date parts or time parts. In some cases, this syntax can be deceiving. For example, a value such as '10:11:12' might look like a time value because of the :, but is interpreted as the year '2010-11-12' if used in date context. The value '10:45:15' is converted to '0000-00-00' because '45' is not a valid month.

The only delimiter recognized between a date and time part and a fractional seconds part is the decimal point.

The server requires that month and day values be valid, and not merely in the range 1 to 12 and 1 to 31, respectively. With strict mode disabled, invalid dates such as '2004-04-31' are converted to '0000-00-00' and a warning is generated. With strict mode enabled, invalid dates generate an error. To permit such dates, enable ALLOW_INVALID_DATES. See Section 5.1.11, “Server SQL Modes”, for more information.

MySQL does not accept TIMESTAMP values that include a zero in the day or month column or values that are not a valid date. The sole exception to this rule is the special “zero” value '0000-00-00 00:00:00', if the SQL mode permits this value. The precise behavior depends on which if any of strict SQL mode and the NO_ZERO_DATE SQL mode are enabled; see Section 5.1.11, “Server SQL Modes”.

Dates containing 2-digit year values are ambiguous because the century is unknown. MySQL interprets 2-digit year values using these rules:

Year values in the range 00-69 become 2000-2069.

Year values in the range 70-99 become 1970-1999.

mysql> alter table t1
    -> add dat date;
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> insert into t1 value ( '10:11:13.123', '2021-01-02 10:11:13.123456', curtime(), '2021-05-17');
Query OK, 1 row affected (0.00 sec)

mysql> select * from t1;
+--------------+----------------------------+---------------------+------------+
| t            | dt                         | ts                  | dat        |
+--------------+----------------------------+---------------------+------------+
| 10:11:12.123 | 2021-01-02 10:11:12.123456 | 2021-01-02 10:11:12 | NULL       |
| 10:11:13.123 | 2021-01-02 10:11:13.123456 | 2021-01-02 10:11:13 | NULL       |
| 10:11:13.123 | 2021-01-02 10:11:13.123456 | 2021-07-17 17:47:10 | NULL       |
| 10:11:13.123 | 2021-01-02 10:11:13.123456 | 2021-07-17 19:25:40 | 2021-05-17 |
+--------------+----------------------------+---------------------+------------+

11.2.3 The TIME Type
-------------------
MySQL retrieves and displays TIME values in 'hh:mm:ss' format (or 'hhh:mm:ss' format for large hours values). TIME values may range from '-838:59:59' to '838:59:59'. The hours part may be so large because the TIME type can be used not only to represent a time of day (which must be less than 24 hours), but also elapsed time or a time interval between two events (which may be much greater than 24 hours, or even negative).

MySQL recognizes TIME values in several formats, some of which can include a trailing fractional seconds part in up to microseconds (6 digits) precision. See Section 9.1.3, “Date and Time Literals”. For information about fractional seconds support in MySQL, see Section 11.2.6, “Fractional Seconds in Time Values”. In particular, any fractional part in a value inserted into a TIME column is stored rather than discarded. With the fractional part included, the range for TIME values is '-838:59:59.000000' to '838:59:59.000000'.

Be careful about assigning abbreviated values to a TIME column. MySQL interprets abbreviated TIME values with colons as time of the day. That is, '11:12' means '11:12:00', not '00:11:12'. MySQL interprets abbreviated values without colons using the assumption that the two rightmost digits represent seconds (that is, as elapsed time rather than as time of day). For example, you might think of '1112' and 1112 as meaning '11:12:00' (12 minutes after 11 o'clock), but MySQL interprets them as '00:11:12' (11 minutes, 12 seconds). Similarly, '12' and 12 are interpreted as '00:00:12'.

The only delimiter recognized between a time part and a fractional seconds part is the decimal point.

By default, values that lie outside the TIME range but are otherwise valid are clipped to the closest endpoint of the range. For example, '-850:00:00' and '850:00:00' are converted to '-838:59:59' and '838:59:59'. Invalid TIME values are converted to '00:00:00'. Note that because '00:00:00' is itself a valid TIME value, there is no way to tell, from a value of '00:00:00' stored in a table, whether the original value was specified as '00:00:00' or whether it was invalid.

For more restrictive treatment of invalid TIME values, enable strict SQL mode to cause errors to occur.

11.2.4 The YEAR Type
--------------------
The YEAR type is a 1-byte type used to represent year values. It can be declared as YEAR with an implicit display width of 4 characters, or equivalently as YEAR(4) with an explicit display width.

Note
As of MySQL 8.0.19, the YEAR(4) data type with an explicit display width is deprecated and you should expect support for it to be removed in a future version of MySQL. Instead, use YEAR without a display width, which has the same meaning.

MySQL 8.0 does not support the 2-digit YEAR(2) data type permitted in older versions of MySQL. For instructions on converting to 4-digit YEAR, see 2-Digit YEAR(2) Limitations and Migrating to 4-Digit YEAR, in MySQL 5.7 Reference Manual.

MySQL displays YEAR values in YYYY format, with a range of 1901 to 2155, and 0000.

YEAR accepts input values in a variety of formats:

As 4-digit strings in the range '1901' to '2155'.

As 4-digit numbers in the range 1901 to 2155.

As 1- or 2-digit strings in the range '0' to '99'. MySQL converts values in the ranges '0' to '69' and '70' to '99' to YEAR values in the ranges 2000 to 2069 and 1970 to 1999.

As 1- or 2-digit numbers in the range 0 to 99. MySQL converts values in the ranges 1 to 69 and 70 to 99 to YEAR values in the ranges 2001 to 2069 and 1970 to 1999.

The result of inserting a numeric 0 has a display value of 0000 and an internal value of 0000. To insert zero and have it be interpreted as 2000, specify it as a string '0' or '00'.

As the result of functions that return a value that is acceptable in YEAR context, such as NOW().

If strict SQL mode is not enabled, MySQL converts invalid YEAR values to 0000. In strict SQL mode, attempting to insert an invalid YEAR value produces an error.

11.2.5 Automatic Initialization and Updating for TIMESTAMP and DATETIME
========================================================================
TIMESTAMP and DATETIME columns can be automatically initializated and updated to the current date and time (that is, the current timestamp).

For any TIMESTAMP or DATETIME column in a table, you can assign the current timestamp as the default value, the auto-update value, or both:

An auto-initialized column is set to the current timestamp for inserted rows that specify no value for the column.

An auto-updated column is automatically updated to the current timestamp when the value of any other column in the row is changed from its current value. An auto-updated column remains unchanged if all other columns are set to their current values. To prevent an auto-updated column from updating when other columns change, explicitly set it to its current value. To update an auto-updated column even when other columns do not change, explicitly set it to the value it should have (for example, set it to CURRENT_TIMESTAMP).

In addition, if the explicit_defaults_for_timestamp system variable is disabled, you can initialize or update any TIMESTAMP (but not DATETIME) column to the current date and time by assigning it a NULL value, unless it has been defined with the NULL attribute to permit NULL values.

To specify automatic properties, use the DEFAULT CURRENT_TIMESTAMP and ON UPDATE CURRENT_TIMESTAMP clauses in column definitions. The order of the clauses does not matter. If both are present in a column definition, either can occur first. Any of the synonyms for CURRENT_TIMESTAMP have the same meaning as CURRENT_TIMESTAMP. These are CURRENT_TIMESTAMP(), NOW(), LOCALTIME, LOCALTIME(), LOCALTIMESTAMP, and LOCALTIMESTAMP().

Use of DEFAULT CURRENT_TIMESTAMP and ON UPDATE CURRENT_TIMESTAMP is specific to TIMESTAMP and DATETIME. The DEFAULT clause also can be used to specify a constant (nonautomatic) default value (for example, DEFAULT 0 or DEFAULT '2000-01-01 00:00:00').

Note
The following examples use DEFAULT 0, a default that can produce warnings or errors depending on whether strict SQL mode or the NO_ZERO_DATE SQL mode is enabled. Be aware that the TRADITIONAL SQL mode includes strict mode and NO_ZERO_DATE. See Section 5.1.11, “Server SQL Modes”.

TIMESTAMP or DATETIME column definitions can specify the current timestamp for both the default and auto-update values, for one but not the other, or for neither. Different columns can have different combinations of automatic properties. The following rules describe the possibilities:

With both DEFAULT CURRENT_TIMESTAMP and ON UPDATE CURRENT_TIMESTAMP, the column has the current timestamp for its default value and is automatically updated to the current timestamp.

CREATE TABLE t1 (
  ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  dt DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
With a DEFAULT clause but no ON UPDATE CURRENT_TIMESTAMP clause, the column has the given default value and is not automatically updated to the current timestamp.

The default depends on whether the DEFAULT clause specifies CURRENT_TIMESTAMP or a constant value. With CURRENT_TIMESTAMP, the default is the current timestamp.

CREATE TABLE t1 (
  ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  dt DATETIME DEFAULT CURRENT_TIMESTAMP
);
With a constant, the default is the given value. In this case, the column has no automatic properties at all.

CREATE TABLE t1 (
  ts TIMESTAMP DEFAULT 0,
  dt DATETIME DEFAULT 0
);
With an ON UPDATE CURRENT_TIMESTAMP clause and a constant DEFAULT clause, the column is automatically updated to the current timestamp and has the given constant default value.

CREATE TABLE t1 (
  ts TIMESTAMP DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP,
  dt DATETIME DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP
);
With an ON UPDATE CURRENT_TIMESTAMP clause but no DEFAULT clause, the column is automatically updated to the current timestamp but does not have the current timestamp for its default value.

The default in this case is type dependent. TIMESTAMP has a default of 0 unless defined with the NULL attribute, in which case the default is NULL.

CREATE TABLE t1 (
  ts1 TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,     -- default 0
  ts2 TIMESTAMP NULL ON UPDATE CURRENT_TIMESTAMP -- default NULL
);
DATETIME has a default of NULL unless defined with the NOT NULL attribute, in which case the default is 0.

CREATE TABLE t1 (
  dt1 DATETIME ON UPDATE CURRENT_TIMESTAMP,         -- default NULL
  dt2 DATETIME NOT NULL ON UPDATE CURRENT_TIMESTAMP -- default 0
);
TIMESTAMP and DATETIME columns have no automatic properties unless they are specified explicitly, with this exception: If the explicit_defaults_for_timestamp system variable is disabled, the first TIMESTAMP column has both DEFAULT CURRENT_TIMESTAMP and ON UPDATE CURRENT_TIMESTAMP if neither is specified explicitly. To suppress automatic properties for the first TIMESTAMP column, use one of these strategies:

Enable the explicit_defaults_for_timestamp system variable. In this case, the DEFAULT CURRENT_TIMESTAMP and ON UPDATE CURRENT_TIMESTAMP clauses that specify automatic initialization and updating are available, but are not assigned to any TIMESTAMP column unless explicitly included in the column definition.

Alternatively, if explicit_defaults_for_timestamp is disabled, do either of the following:

Define the column with a DEFAULT clause that specifies a constant default value.

Specify the NULL attribute. This also causes the column to permit NULL values, which means that you cannot assign the current timestamp by setting the column to NULL. Assigning NULL sets the column to NULL, not the current timestamp. To assign the current timestamp, set the column to CURRENT_TIMESTAMP or a synonym such as NOW().

Consider these table definitions:

CREATE TABLE t1 (
  ts1 TIMESTAMP DEFAULT 0,
  ts2 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                ON UPDATE CURRENT_TIMESTAMP);
CREATE TABLE t2 (
  ts1 TIMESTAMP NULL,
  ts2 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                ON UPDATE CURRENT_TIMESTAMP);
CREATE TABLE t3 (
  ts1 TIMESTAMP NULL DEFAULT 0,
  ts2 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                ON UPDATE CURRENT_TIMESTAMP);
The tables have these properties:

In each table definition, the first TIMESTAMP column has no automatic initialization or updating.

The tables differ in how the ts1 column handles NULL values. For t1, ts1 is NOT NULL and assigning it a value of NULL sets it to the current timestamp. For t2 and t3, ts1 permits NULL and assigning it a value of NULL sets it to NULL.

t2 and t3 differ in the default value for ts1. For t2, ts1 is defined to permit NULL, so the default is also NULL in the absence of an explicit DEFAULT clause. For t3, ts1 permits NULL but has an explicit default of 0.

If a TIMESTAMP or DATETIME column definition includes an explicit fractional seconds precision value anywhere, the same value must be used throughout the column definition. This is permitted:

CREATE TABLE t1 (
  ts TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6)
);
This is not permitted:

CREATE TABLE t1 (
  ts TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP(3)
);
TIMESTAMP Initialization and the NULL Attribute

If the explicit_defaults_for_timestamp system variable is disabled, TIMESTAMP columns by default are NOT NULL, cannot contain NULL values, and assigning NULL assigns the current timestamp. To permit a TIMESTAMP column to contain NULL, explicitly declare it with the NULL attribute. In this case, the default value also becomes NULL unless overridden with a DEFAULT clause that specifies a different default value. DEFAULT NULL can be used to explicitly specify NULL as the default value. (For a TIMESTAMP column not declared with the NULL attribute, DEFAULT NULL is invalid.) If a TIMESTAMP column permits NULL values, assigning NULL sets it to NULL, not to the current timestamp.

The following table contains several TIMESTAMP columns that permit NULL values:

CREATE TABLE t
(
  ts1 TIMESTAMP NULL DEFAULT NULL,
  ts2 TIMESTAMP NULL DEFAULT 0,
  ts3 TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP
);
A TIMESTAMP column that permits NULL values does not take on the current timestamp at insert time except under one of the following conditions:

Its default value is defined as CURRENT_TIMESTAMP and no value is specified for the column

CURRENT_TIMESTAMP or any of its synonyms such as NOW() is explicitly inserted into the column

In other words, a TIMESTAMP column defined to permit NULL values auto-initializes only if its definition includes DEFAULT CURRENT_TIMESTAMP:

CREATE TABLE t (ts TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP);
If the TIMESTAMP column permits NULL values but its definition does not include DEFAULT CURRENT_TIMESTAMP, you must explicitly insert a value corresponding to the current date and time. Suppose that tables t1 and t2 have these definitions:

CREATE TABLE t1 (ts TIMESTAMP NULL DEFAULT '0000-00-00 00:00:00');
CREATE TABLE t2 (ts TIMESTAMP NULL DEFAULT NULL);
To set the TIMESTAMP column in either table to the current timestamp at insert time, explicitly assign it that value. For example:

INSERT INTO t2 VALUES (CURRENT_TIMESTAMP);
INSERT INTO t1 VALUES (NOW());
If the explicit_defaults_for_timestamp system variable is enabled, TIMESTAMP columns permit NULL values only if declared with the NULL attribute. Also, TIMESTAMP columns do not permit assigning NULL to assign the current timestamp, whether declared with the NULL or NOT NULL attribute. To assign the current timestamp, set the column to CURRENT_TIMESTAMP or a synonym such as NOW().

11.2.6 Fractional Seconds in Time Values

MySQL has fractional seconds support for TIME, DATETIME, and TIMESTAMP values, with up to microseconds (6 digits) precision:

To define a column that includes a fractional seconds part, use the syntax type_name(fsp), where type_name is TIME, DATETIME, or TIMESTAMP, and fsp is the fractional seconds precision. For example:

CREATE TABLE t1 (t TIME(3), dt DATETIME(6));
The fsp value, if given, must be in the range 0 to 6. A value of 0 signifies that there is no fractional part. If omitted, the default precision is 0. (This differs from the standard SQL default of 6, for compatibility with previous MySQL versions.)

Inserting a TIME, DATE, or TIMESTAMP value with a fractional seconds part into a column of the same type but having fewer fractional digits results in rounding. Consider a table created and populated as follows:

CREATE TABLE fractest( c1 TIME(2), c2 DATETIME(2), c3 TIMESTAMP(2) );
INSERT INTO fractest VALUES
('17:51:04.777', '2018-09-08 17:51:04.777', '2018-09-08 17:51:04.777');
The temporal values are inserted into the table with rounding:

mysql> SELECT * FROM fractest;
+-------------+------------------------+------------------------+
| c1          | c2                     | c3                     |
+-------------+------------------------+------------------------+
| 17:51:04.78 | 2018-09-08 17:51:04.78 | 2018-09-08 17:51:04.78 |
+-------------+------------------------+------------------------+
No warning or error is given when such rounding occurs. This behavior follows the SQL standard.

To insert the values with truncation instead, enable the TIME_TRUNCATE_FRACTIONAL SQL mode:

SET @@sql_mode = sys.list_add(@@sql_mode, 'TIME_TRUNCATE_FRACTIONAL');
With that SQL mode enabled, the temporal values are inserted with truncation:

mysql> SELECT * FROM fractest;
+-------------+------------------------+------------------------+
| c1          | c2                     | c3                     |
+-------------+------------------------+------------------------+
| 17:51:04.77 | 2018-09-08 17:51:04.77 | 2018-09-08 17:51:04.77 |
+-------------+------------------------+------------------------+
Functions that take temporal arguments accept values with fractional seconds. Return values from temporal functions include fractional seconds as appropriate. For example, NOW() with no argument returns the current date and time with no fractional part, but takes an optional argument from 0 to 6 to specify that the return value includes a fractional seconds part of that many digits.

Syntax for temporal literals produces temporal values: DATE 'str', TIME 'str', and TIMESTAMP 'str', and the ODBC-syntax equivalents. The resulting value includes a trailing fractional seconds part if specified. Previously, the temporal type keyword was ignored and these constructs produced the string value

11.2.7 Conversion Between Date and Time Types

To some extent, you can convert a value from one temporal type to another. However, there may be some alteration of the value or loss of information. In all cases, conversion between temporal types is subject to the range of valid values for the resulting type. For example, although DATE, DATETIME, and TIMESTAMP values all can be specified using the same set of formats, the types do not all have the same range of values. TIMESTAMP values cannot be earlier than 1970 UTC or later than '2038-01-19 03:14:07' UTC. This means that a date such as '1968-01-01', while valid as a DATE or DATETIME value, is not valid as a TIMESTAMP value and is converted to 0.

Conversion of DATE values:

Conversion to a DATETIME or TIMESTAMP value adds a time part of '00:00:00' because the DATE value contains no time information.

Conversion to a TIME value is not useful; the result is '00:00:00'.

Conversion of DATETIME and TIMESTAMP values:

Conversion to a DATE value takes fractional seconds into account and rounds the time part. For example, '1999-12-31 23:59:59.499' becomes '1999-12-31', whereas '1999-12-31 23:59:59.500' becomes '2000-01-01'.

Conversion to a TIME value discards the date part because the TIME type contains no date information.

For conversion of TIME values to other temporal types, the value of CURRENT_DATE() is used for the date part. The TIME is interpreted as elapsed time (not time of day) and added to the date. This means that the date part of the result differs from the current date if the time value is outside the range from '00:00:00' to '23:59:59'.

Suppose that the current date is '2012-01-01'. TIME values of '12:00:00', '24:00:00', and '-12:00:00', when converted to DATETIME or TIMESTAMP values, result in '2012-01-01 12:00:00', '2012-01-02 00:00:00', and '2011-12-31 12:00:00', respectively.

Conversion of TIME to DATE is similar but discards the time part from the result: '2012-01-01', '2012-01-02', and '2011-12-31', respectively.

Explicit conversion can be used to override implicit conversion. For example, in comparison of DATE and DATETIME values, the DATE value is coerced to the DATETIME type by adding a time part of '00:00:00'. To perform the comparison by ignoring the time part of the DATETIME value instead, use the CAST() function in the following way:

date_col = CAST(datetime_col AS DATE)
Conversion of TIME and DATETIME values to numeric form (for example, by adding +0) depends on whether the value contains a fractional seconds part. TIME(N) or DATETIME(N) is converted to integer when N is 0 (or omitted) and to a DECIMAL value with N decimal digits when N is greater than 0:


mysql> SELECT CURTIME(), CURTIME()+0, CURTIME(3)+0;
+-----------+-------------+--------------+
| CURTIME() | CURTIME()+0 | CURTIME(3)+0 |
+-----------+-------------+--------------+
| 09:28:00  |       92800 |    92800.887 |
+-----------+-------------+--------------+
mysql> SELECT NOW(), NOW()+0, NOW(3)+0;
+---------------------+----------------+--------------------+
| NOW()               | NOW()+0        | NOW(3)+0           |
+---------------------+----------------+--------------------+
| 2012-08-15 09:28:00 | 20120815092800 | 20120815092800.889 |
+---------------------+----------------+--------------------+

11.2.8 2-Digit Years in Dates
=============================
Date values with 2-digit years are ambiguous because the century is unknown. Such values must be interpreted into 4-digit form because MySQL stores years internally using 4 digits.

For DATETIME, DATE, and TIMESTAMP types, MySQL interprets dates specified with ambiguous year values using these rules:

Year values in the range 00-69 become 2000-2069.

Year values in the range 70-99 become 1970-1999.

For YEAR, the rules are the same, with this exception: A numeric 00 inserted into YEAR results in 0000 rather than 2000. To specify zero for YEAR and have it be interpreted as 2000, specify it as a string '0' or '00'.

Remember that these rules are only heuristics that provide reasonable guesses as to what your data values mean. If the rules used by MySQL do not produce the values you require, you must provide unambiguous input containing 4-digit year values.

ORDER BY properly sorts YEAR values that have 2-digit years.

Some functions like MIN() and MAX() convert a YEAR to a number. This means that a value with a 2-digit year does not work properly with these functions. The fix in this case is to convert the YEAR to 4-digit year format.

Revision -
--------
Numerical Datatypes - TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT
FLOAT, REAL, DECIMAL, DOUBLE

Temporal Datatypes - DATE, TIME, DATETIME, TIMESTAMP, YEAR

STRING DATA TYPES:
------------------
The string data types are CHAR, VARCHAR, BINARY, VARBINARY, BLOB, TEXT, ENUM, and SET.

For definitions of character string columns (CHAR, VARCHAR, and the TEXT types), MySQL interprets length specifications in character units.
For definitions of binary string columns (BINARY, VARBINARY, and the BLOB types), MySQL interprets length specifications in byte units.

Column definitions for character string data types CHAR, VARCHAR, the TEXT types, ENUM, SET, and any synonyms) can specify the column character set and collation:
CHARACTER SET specifies the character set. If desired, a collation for the character set can be specified with the COLLATE attribute, along with any other attributes. For example:
mysql> create table t( c1 varchar(20) character set utf8, c2 text character set latin1 collate latin1_general_cs );


This table definition creates a column named c1 that has a character set of utf8 with the default collation for that character set, and a column named c2 that has a character set of latin1 and a case-sensitive (_cs) collation.

Specifying the CHARACTER SET binary attribute for a character string data type causes the column to be created as the corresponding binary string data type: CHAR becomes BINARY, VARCHAR becomes VARBINARY, and TEXT becomes BLOB. For the ENUM and SET data types, this does not occur; they are created as declared. Suppose that you specify a table using this definition:

CREATE TABLE t
(
  c1 VARCHAR(10) CHARACTER SET binary,
  c2 TEXT CHARACTER SET binary,
  c3 ENUM('a','b','c') CHARACTER SET binary
);

The resulting table has this definition:

CREATE TABLE t
(
  c1 VARBINARY(10),
  c2 BLOB,
  c3 ENUM('a','b','c') CHARACTER SET binary
);

The BINARY attribute is a nonstandard MySQL extension that is shorthand for specifying the binary (_bin) collation of the column character set (or of the table default character set if no column character set is specified). In this case, comparison and sorting are based on numeric character code values. Suppose that you specify a table using this definition:

CREATE TABLE t
(
  c1 VARCHAR(10) CHARACTER SET latin1 BINARY,
  c2 TEXT BINARY
) CHARACTER SET utf8mb4

The resulting table has this definition:

CREATE TABLE t (
  c1 VARCHAR(10) CHARACTER SET latin1 COLLATE latin1_bin,
  c2 TEXT CHARACTER SET utf8mb4 COLLATE utf8mb4_bin
) CHARACTER SET utf8mb4;

In MySQL 8.0, this nonstandard use of the BINARY attribute is ambiguous because the utf8mb4 character set has multiple _bin collations. As of MySQL 8.0.17, the BINARY attribute is deprecated and you should expect support for it to be removed in a future version of MySQL. Applications should be adjusted to use an explicit _bin collation instead.

The use of BINARY to specify a data type or character set remains unchanged.

The ASCII attribute is shorthand for CHARACTER SET latin1.

The UNICODE attribute is shorthand for CHARACTER SET ucs2.

11.3.2 The CHAR and VARCHAR Types
----------------------------------
The CHAR and VARCHAR types are similar, but differ in the way they are stored and retrieved. They also differ in maximum length and in whether trailing spaces are retained.

The CHAR and VARCHAR types are declared with a length that indicates the maximum number of characters you want to store. For example, CHAR(30) can hold up to 30 characters.

The length of a CHAR column is fixed to the length that you declare when you create the table. The length can be any value from 0 to 255. When CHAR values are stored, they are right-padded with spaces to the specified length. When CHAR values are retrieved, trailing spaces are removed unless the PAD_CHAR_TO_FULL_LENGTH SQL mode is enabled.

Values in VARCHAR columns are variable-length strings. The length can be specified as a value from 0 to 65,535. The effective maximum length of a VARCHAR is subject to the maximum row size (65,535 bytes, which is shared among all columns) and the character set used. See Section 8.4.7, “Limits on Table Column Count and Row Size”.

In contrast to CHAR, VARCHAR values are stored as a 1-byte or 2-byte length prefix plus data. The length prefix indicates the number of bytes in the value. A column uses one length byte if values require no more than 255 bytes, two length bytes if values may require more than 255 bytes.

If strict SQL mode is not enabled and you assign a value to a CHAR or VARCHAR column that exceeds the column's maximum length, the value is truncated to fit and a warning is generated. For truncation of nonspace characters, you can cause an error to occur (rather than a warning) and suppress insertion of the value by using strict SQL mode. See Section 5.1.11, “Server SQL Modes”.

For VARCHAR columns, trailing spaces in excess of the column length are truncated prior to insertion and a warning is generated, regardless of the SQL mode in use. For CHAR columns, truncation of excess trailing spaces from inserted values is performed silently regardless of the SQL mode.
mysql> CREATE TABLE vc (v VARCHAR(4), c CHAR(4));
Query OK, 0 rows affected (0.01 sec)

mysql> INSERT INTO vc VALUES ('ab  ', 'ab  ');
Query OK, 1 row affected (0.00 sec)

mysql> SELECT CONCAT('(', v, ')'), CONCAT('(', c, ')') FROM vc;
+---------------------+---------------------+
| CONCAT('(', v, ')') | CONCAT('(', c, ')') |
+---------------------+---------------------+
| (ab  )              | (ab)                |
+---------------------+---------------------+
1 row in set (0.06 sec)


11.3.3 The BINARY and VARBINARY Types
The BINARY and VARBINARY types are similar to CHAR and VARCHAR, except that they store binary strings rather than nonbinary strings. That is, they store byte strings rather than character strings. This means they have the binary character set and collation, and comparison and sorting are based on the numeric values of the bytes in the values.

The permissible maximum length is the same for BINARY and VARBINARY as it is for CHAR and VARCHAR, except that the length for BINARY and VARBINARY is measured in bytes rather than characters.


11.3.4 The BLOB and TEXT Types
A BLOB is a binary large object that can hold a variable amount of data. The four BLOB types are TINYBLOB, BLOB, MEDIUMBLOB, and LONGBLOB. These differ only in the maximum length of the values they can hold. The four TEXT types are TINYTEXT, TEXT, MEDIUMTEXT, and LONGTEXT.


11.3.5 The ENUM Type

An ENUM is a string object with a value chosen from a list of permitted values that are enumerated explicitly in the column specification at table creation time.

See Section 11.3.1, “String Data Type Syntax” for ENUM type syntax and length limits.

The ENUM type has these advantages:

Compact data storage in situations where a column has a limited set of possible values. The strings you specify as input values are automatically encoded as numbers. See Section 11.7, “Data Type Storage Requirements” for storage requirements for the ENUM type.

Readable queries and output. The numbers are translated back to the corresponding strings in query results.

mysql> create table t3 (a INT, b ENUM('M','F'));
Query OK, 0 rows affected (0.02 sec)

mysql> insert into t3 values (1, 'M');
Query OK, 1 row affected (0.01 sec)

mysql> select * from T3;
+------+------+
| a    | b    |
+------+------+
|    1 | M    |
+------+------+
1 row in set (0.01 sec)

mysql> insert into t3 values (1, 'S');
ERROR 1265 (01000): Data truncated for column 'b' at row 1
mysql> select * from T3;
+------+------+
| a    | b    |
+------+------+
|    1 | M    |
+------+------+
1 row in set (0.00 sec)

Enum can be considered similar to symbol type in kdb.

SET:
A SET is a string object that can have zero or more values, each of which must be chosen from a list of permitted values specified when the table is created. SET column values that consist of multiple set members are specified with members separated by commas (,). A consequence of this is that SET member values should not themselves contain commas.

For example, a column specified as SET('one', 'two') NOT NULL can have any of these values:

mysql> CREATE TABLE myset (col SET('a', 'b', 'c', 'd'));
Query OK, 0 rows affected (0.02 sec)

mysql> INSERT INTO myset (col) VALUES ('a,d'), ('d,a'), ('a,d,a'), ('a,d,d'), ('d,a,d');
Query OK, 5 rows affected (0.01 sec)
Records: 5  Duplicates: 0  Warnings: 0

mysql> select * from myset;
+------+
| col  |
+------+
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
+------+
5 rows in set (0.00 sec)

Difference between set and enum -
enum can have comma separated values or values other then specified values.
mysql> CREATE TABLE myenum (col Enum('a', 'b', 'c', 'd'));
Query OK, 0 rows affected (0.02 sec)

mysql> INSERT INTO myenum (col) VALUES ('a,d'), ('d,a'), ('a,d,a'), ('a,d,d'), ('d,a,d');
ERROR 1265 (01000): Data truncated for column 'col' at row 1
mysql> INSERT INTO myenum (col) VALUES ('a,d'), ('b'), ('c'), ('a'), ('d');
ERROR 1265 (01000): Data truncated for column 'col' at row 1
mysql> INSERT INTO myenum (col) VALUES ('a'), ('b'), ('c'), ('a'), ('d');
Query OK, 5 rows affected (0.00 sec)
Records: 5  Duplicates: 0  Warnings: 0

mysql> select * from myenum;
+------+
| col  |
+------+
| a    |
| b    |
| c    |
| a    |
| d    |
+------+
5 rows in set (0.00 sec)


Chapter 12 Functions and Operators
-----------------------------------
Expressions can be used at several points in SQL statements, such as in the ORDER BY or HAVING clauses of SELECT statements, in the WHERE clause of a SELECT, DELETE, or UPDATE statement, or in SET statements. Expressions can be written using values from several sources, such as literal values, column values, NULL, variables, built-in functions and operators, loadable functions, and stored functions (a type of stored object).

This chapter describes the built-in functions and operators that are permitted for writing expressions in MySQL. For information about loadable functions and stored functions, see Section 5.7, “MySQL Server Loadable Functions”, and Section 25.2, “Using Stored Routines”. For the rules describing how the server interprets references to different kinds of functions, see Section 9.2.5, “Function Name Parsing and Resolution”.

An expression that contains NULL always produces a NULL value unless otherwise indicated in the documentation for a particular function or operator.

Note
By default, there must be no whitespace between a function name and the parenthesis following it. This helps the MySQL parser distinguish between function calls and references to tables or columns that happen to have the same name as a function. However, spaces around function arguments are permitted.

To tell the MySQL server to accept spaces after function names by starting it with the --sql-mode=IGNORE_SPACE option. (See Section 5.1.11, “Server SQL Modes”.) Individual client programs can request this behavior by using the CLIENT_IGNORE_SPACE option for mysql_real_connect(). In either case, all function names become reserved words.

mysql> select MOD(29,9);
+-----------+
| MOD(29,9) |
+-----------+
|         2 |
+-----------+
1 row in set (0.00 sec)

12.1 Built-In Function and Operator Reference - https://dev.mysql.com/doc/refman/8.0/en/built-in-function-reference.html
---------------------------------------------
Sample -

Name	Description
&	    Bitwise AND
>	    Greater than operator
>>	    Right shift
>=	    Greater than or equal operator
<	    Less than operator
<>, !=	Not equal operator
<<	    Left shift
<=	    Less than or equal operator
<=>	    NULL-safe equal to operator
%,      MOD	Modulo operator
*	    Multiplication operator
+	    Addition operator
-	    Minus operator
-	    Change the sign of the argument

Examples of Left shift operator:
mysql> select 1 << 1;
+--------+
| 1 << 1 |
+--------+
|      2 |
+--------+
1 row in set (0.00 sec)

mysql> select 1 << 2;
+--------+
| 1 << 2 |
+--------+
|      4 |
+--------+
1 row in set (0.00 sec)

mysql> select 1 << 3;
+--------+
| 1 << 3 |
+--------+
|      8 |
+--------+
1 row in set (0.00 sec)

12.2 Loadable Function Reference - https://dev.mysql.com/doc/refman/8.0/en/loadable-function-reference.html

12.3 Type Conversion in Expression Evaluation
----------------------------------------------
When an operator is used with operands of different types, type conversion occurs to make the operands compatible. Some conversions occur implicitly. For example, MySQL automatically converts strings to numbers as necessary, and vice versa.
mysql> select 1+'1';
+-------+
| 1+'1' |
+-------+
|     2 |
+-------+
1 row in set (0.00 sec)

mysql> select '1'+1;
+-------+
| '1'+1 |
+-------+
|     2 |
+-------+
1 row in set (0.00 sec)

mysql> select concat(2, ' test');
+--------------------+
| concat(2, ' test') |
+--------------------+
| 2 test             |
+--------------------+
1 row in set (0.00 sec)

It is also possible to convert a number to a string explicitly using the CAST() function. Conversion occurs implicitly with the CONCAT() function because it expects string arguments.
mysql> select 38.8, cast(38.8 as char);
+------+--------------------+
| 38.8 | cast(38.8 as char) |
+------+--------------------+
| 38.8 | 38.8               |
+------+--------------------+
1 row in set (0.00 sec)

mysql> select 38.8, concat(38.8);
+------+--------------+
| 38.8 | concat(38.8) |
+------+--------------+
| 38.8 | 38.8         |
+------+--------------+
1 row in set (0.00 sec)

12.5 Flow Control Functions
---------------------------
Name	    Description
CASE	    Case operator
IF()	    If/else construct
IFNULL()	Null if/else construct
NULLIF()	Return NULL if expr1 = expr2

12.20 Aggregate Functions
-------------------------
Table 12.25 Aggregate Functions

Name	            Description
AVG()	            Return the average value of the argument
BIT_AND()	        Return bitwise AND
BIT_OR()	        Return bitwise OR
BIT_XOR()	        Return bitwise XOR
COUNT()	            Return a count of the number of rows returned
COUNT(DISTINCT)	    Return the count of a number of different values
GROUP_CONCAT()	    Return a concatenated string
JSON_ARRAYAGG()	    Return result set as a single JSON array
JSON_OBJECTAGG()	Return result set as a single JSON object
MAX()	            Return the maximum value
MIN()	            Return the minimum value
STD()	            Return the population standard deviation
STDDEV()	        Return the population standard deviation
STDDEV_POP()	    Return the population standard deviation
STDDEV_SAMP()	    Return the sample standard deviation
SUM()	            Return the sum
VAR_POP()	        Return the population standard variance
VAR_SAMP()	        Return the sample variance
VARIANCE()	        Return the population standard variance

12.20.2 GROUP BY Modifiers
---------------------------
The GROUP BY clause permits a WITH ROLLUP modifier that causes summary output to include extra rows that represent higher-level (that is, super-aggregate) summary operations. ROLLUP thus enables you to answer questions at multiple levels of analysis with a single query. For example, ROLLUP can be used to provide support for OLAP (Online Analytical Processing) operations.

Suppose that a sales table has year, country, product, and profit columns for recording sales profitability:
mysql> create table sales
    -> (
    -> year INT,
    -> country VARCHAR(20),
    -> product VARCHAR(20),
    -> profit INT
    -> );
Query OK, 0 rows affected (0.04 sec)

mysql> insert into sales values (2000, 'IN', 'CHAI', 10000), (2001, 'IN','MASALA', 20000), (2000,'USA','COFFEE',100000);
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> select * from sales;
+------+---------+---------+--------+
| year | country | product | profit |
+------+---------+---------+--------+
| 2000 | IN      | CHAI    |  10000 |
| 2001 | IN      | MASALA  |  20000 |
| 2000 | USA     | COFFEE  | 100000 |
+------+---------+---------+--------+
3 rows in set (0.00 sec)

To summarize table contents per year, use a simple GROUP BY like this:

mysql> select year, sum(profit) as profit
    -> from sales
    -> group by year;
+------+--------+
| year | profit |
+------+--------+
| 2000 | 110000 |
| 2001 |  20000 |
+------+--------+
2 rows in set (0.00 sec)

The output shows the total (aggregate) profit for each year. To also determine the total profit summed over all years, you must add up the individual values yourself or run an additional query. Or you can use ROLLUP, which provides both levels of analysis with a single query. Adding a WITH ROLLUP modifier to the GROUP BY clause causes the query to produce another (super-aggregate) row that shows the grand total over all year values:

mysql> select year, sum(profit) as profit from sales group by year WITH ROLLUP;
+------+--------+
| year | profit |
+------+--------+
| 2000 | 110000 |
| 2001 |  20000 |
| NULL | 130000 |
+------+--------+
3 rows in set (0.00 sec)

ROLLUP has a more complex effect when there are multiple GROUP BY columns. In this case, each time there is a change in value in any but the last grouping column, the query produces an extra super-aggregate summary row.

For example, without ROLLUP, a summary of the sales table based on year, country, and product might look like this, where the output indicates summary values only at the year/country/product level of analysis:
and next example consists with ROLLUP.

mysql> select * from sales;
+------+---------+---------+--------+
| year | country | product | profit |
+------+---------+---------+--------+
| 2000 | IN      | CHAI    |  10000 |
| 2001 | IN      | MASALA  |  20000 |
| 2000 | USA     | COFFEE  | 100000 |
| 2001 | US      | MASALA  |    100 |
| 2000 | IN      | COFFEE  |  20000 |
| 2001 | US      | MASALA  |   2500 |
| 2000 | IN      | COFFEE  |   2500 |
+------+---------+---------+--------+
7 rows in set (0.00 sec)

mysql> select year, country, product, sum(profit) as profit from sales group by year, country, product;
+------+---------+---------+--------+
| year | country | product | profit |
+------+---------+---------+--------+
| 2000 | IN      | CHAI    |  10000 |
| 2001 | IN      | MASALA  |  20000 |
| 2000 | USA     | COFFEE  | 100000 |
| 2001 | US      | MASALA  |   2600 |
| 2000 | IN      | COFFEE  |  22500 |
+------+---------+---------+--------+
5 rows in set (0.00 sec)

mysql> select year, country, product, sum(profit) as profit from sales group by year, country, product with rollup;
+------+---------+---------+--------+
| year | country | product | profit |
+------+---------+---------+--------+
| 2000 | IN      | CHAI    |  10000 |
| 2000 | IN      | COFFEE  |  22500 |
| 2000 | IN      | NULL    |  32500 |
| 2000 | USA     | COFFEE  | 100000 |
| 2000 | USA     | NULL    | 100000 |
| 2000 | NULL    | NULL    | 132500 |
| 2001 | IN      | MASALA  |  20000 |
| 2001 | IN      | NULL    |  20000 |
| 2001 | US      | MASALA  |   2600 |
| 2001 | US      | NULL    |   2600 |
| 2001 | NULL    | NULL    |  22600 |
| NULL | NULL    | NULL    | 155100 |
+------+---------+---------+--------+
12 rows in set (0.00 sec)

Now the output includes summary information at four levels of analysis, not just one:

Following each set of product rows for a given year and country, an extra super-aggregate summary row appears showing the total for all products. These rows have the product column set to NULL.

Following each set of rows for a given year, an extra super-aggregate summary row appears showing the total for all countries and products. These rows have the country and products columns set to NULL.

Finally, following all other rows, an extra super-aggregate summary row appears showing the grand total for all years, countries, and products. This row has the year, country, and products columns set to NULL.

The NULL indicators in each super-aggregate row are produced when the row is sent to the client. The server looks at the columns named in the GROUP BY clause following the leftmost one that has changed value. For any column in the result set with a name that matches any of those names, its value is set to NULL. (If you specify grouping columns by column position, the server identifies which columns to set to NULL by position.)

Because the NULL values in the super-aggregate rows are placed into the result set at such a late stage in query processing, you can test them as NULL values only in the select list or HAVING clause. You cannot test them as NULL values in join conditions or the WHERE clause to determine which rows to select. For example, you cannot add WHERE product IS NULL to the query to eliminate from the output all but the super-aggregate rows.

The NULL values do appear as NULL on the client side and can be tested as such using any MySQL client programming interface. However, at this point, you cannot distinguish whether a NULL represents a regular grouped value or a super-aggregate value. To test the distinction, use the GROUPING() function, described later.

Previously, MySQL did not allow the use of DISTINCT or ORDER BY in a query having a WITH ROLLUP option. This restriction is lifted in MySQL 8.0.12 and later. (Bug #87450, Bug #86311, Bug #26640100, Bug #26073513)

For GROUP BY ... WITH ROLLUP queries, to test whether NULL values in the result represent super-aggregate values, the GROUPING() function is available for use in the select list, HAVING clause, and (as of MySQL 8.0.12) ORDER BY clause. For example, GROUPING(year) returns 1 when NULL in the year column occurs in a super-aggregate row, and 0 otherwise. Similarly, GROUPING(country) and GROUPING(product) return 1 for super-aggregate NULL values in the country and product columns, respectively:

mysql> select year, country, product, sum(profit) as profit,
    -> GROUPING(year) as grp_year,
    -> GROUPING(country) as grp_country,
    -> GROUPING(product) as grp_product
    -> from sales
    -> GROUP BY year, country, product WITH ROLLUP;
+------+---------+---------+--------+----------+-------------+-------------+
| year | country | product | profit | grp_year | grp_country | grp_product |
+------+---------+---------+--------+----------+-------------+-------------+
| 2000 | IN      | CHAI    |  10000 |        0 |           0 |           0 |
| 2000 | IN      | COFFEE  |  22500 |        0 |           0 |           0 |
| 2000 | IN      | NULL    |  32500 |        0 |           0 |           1 |
| 2000 | USA     | COFFEE  | 100000 |        0 |           0 |           0 |
| 2000 | USA     | NULL    | 100000 |        0 |           0 |           1 |
| 2000 | NULL    | NULL    | 132500 |        0 |           1 |           1 |
| 2001 | IN      | MASALA  |  20000 |        0 |           0 |           0 |
| 2001 | IN      | NULL    |  20000 |        0 |           0 |           1 |
| 2001 | US      | MASALA  |   2600 |        0 |           0 |           0 |
| 2001 | US      | NULL    |   2600 |        0 |           0 |           1 |
| 2001 | NULL    | NULL    |  22600 |        0 |           1 |           1 |
| NULL | NULL    | NULL    | 155100 |        1 |           1 |           1 |
+------+---------+---------+--------+----------+-------------+-------------+

Instead of displaying the GROUPING() results directly, you can use GROUPING() to substitute labels for super-aggregate NULL values:

mysql> SELECT
    -> IF(GROUPING(year),'All Years', year) AS year,
    -> IF(GROUPING(country),'All countries', country) AS country,
    -> IF(GROUPING(product),'All products', product) AS product,
    -> SUM(profit) as profit
    -> FROM sales
    -> GROUP BY year, country, product WITH ROLLUP;
+-----------+---------------+--------------+--------+
| year      | country       | product      | profit |
+-----------+---------------+--------------+--------+
| 2000      | IN            | CHAI         |  10000 |
| 2000      | IN            | COFFEE       |  22500 |
| 2000      | IN            | All products |  32500 |
| 2000      | USA           | COFFEE       | 100000 |
| 2000      | USA           | All products | 100000 |
| 2000      | All countries | All products | 132500 |
| 2001      | IN            | MASALA       |  20000 |
| 2001      | IN            | All products |  20000 |
| 2001      | US            | MASALA       |   2600 |
| 2001      | US            | All products |   2600 |
| 2001      | All countries | All products |  22600 |
| All Years | All countries | All products | 155100 |
+-----------+---------------+--------------+--------+
12 rows in set, 3 warnings (0.01 sec)

NOTE - ABOVE statment is somewhat similar to np.where.

With multiple expression arguments, GROUPING() returns a result representing a bitmask the combines the results for each expression, with the lowest-order bit corresponding to the result for the rightmost expression. For example, GROUPING(year, country, product) is evaluated like this:

  result for GROUPING(product)
+ result for GROUPING(country) << 1
+ result for GROUPING(year) << 2

The result of such a GROUPING() is nonzero if any of the expressions represents a super-aggregate NULL, so you can return only the super-aggregate rows and filter out the regular grouped rows like this:

mysql> select year, country, product, sum(profit) as profit
    -> from sales
    -> group by year, country, product with rollup
    -> having grouping(year, country, product) <> 0;
+------+---------+---------+--------+
| year | country | product | profit |
+------+---------+---------+--------+
| 2000 | IN      | NULL    |  32500 |
| 2000 | USA     | NULL    | 100000 |
| 2000 | NULL    | NULL    | 132500 |
| 2001 | IN      | NULL    |  20000 |
| 2001 | US      | NULL    |   2600 |
| 2001 | NULL    | NULL    |  22600 |
| NULL | NULL    | NULL    | 155100 |
+------+---------+---------+--------+


The sales table contains no NULL values, so all NULL values in a ROLLUP result represent super-aggregate values. When the data set contains NULL values, ROLLUP summaries may contain NULL values not only in super-aggregate rows, but also in regular grouped rows. GROUPING() enables these to be distinguished. Suppose that table t1 contains a simple data set with two grouping factors for a set of quantity values, where NULL indicates something like “other” or “unknown”:

A simple ROLLUP operation produces these results, in which it is not so easy to distinguish NULL values in super-aggregate rows from NULL values in regular grouped rows:

Using GROUPING() to substitute labels for the super-aggregate NULL values makes the result easier to interpret:

Other Considerations When using ROLLUP

The following discussion lists some behaviors specific to the MySQL implementation of ROLLUP.

Prior to MySQL 8.0.12, when you use ROLLUP, you cannot also use an ORDER BY clause to sort the results. In other words, ROLLUP and ORDER BY were mutually exclusive in MySQL. However, you still have some control over sort order. To work around the restriction that prevents using ROLLUP with ORDER BY and achieve a specific sort order of grouped results, generate the grouped result set as a derived table and apply ORDER BY to it. For example:

After 8.0.12
mysql> select year, sum(profit) as profit from sales group by year with rollup order by year desc;
+------+--------+
| year | profit |
+------+--------+
| 2001 |  22600 |
| 2000 | 132500 |
| NULL | 155100 |
+------+--------+
3 rows in set (0.00 sec)

OR
mysql> select year, sum(profit) as profit from sales group by year with rollup order by grouping(year) desc;
+------+--------+
| year | profit |
+------+--------+
| NULL | 155100 |
| 2000 | 132500 |
| 2001 |  22600 |
+------+--------+
3 rows in set (0.00 sec)

LIMIT can be used to restrict the number of rows returned to the client. LIMIT is applied after ROLLUP, so the limit applies against the extra rows added by ROLLUP. For example:

Using LIMIT with ROLLUP may produce results that are more difficult to interpret, because there is less context for understanding the super-aggregate rows.

mysql> select year, country, product, sum(profit) as profit
    -> from sales
    -> group by year, country, product with rollup
    -> limit 5;
+------+---------+---------+--------+
| year | country | product | profit |
+------+---------+---------+--------+
| 2000 | IN      | CHAI    |  10000 |
| 2000 | IN      | COFFEE  |  22500 |
| 2000 | IN      | NULL    |  32500 |
| 2000 | USA     | COFFEE  | 100000 |
| 2000 | USA     | NULL    | 100000 |
+------+---------+---------+--------+

A MySQL extension permits a column that does not appear in the GROUP BY list to be named in the select list. (For information about nonaggregated columns and GROUP BY, see Section 12.20.3, “MySQL Handling of GROUP BY”.) In this case, the server is free to choose any value from this nonaggregated column in summary rows, and this includes the extra rows added by WITH ROLLUP. For example, in the following query, country is a nonaggregated column that does not appear in the GROUP BY list and values chosen for this column are nondeterministic:

mysql> SET sql_mode=(SELECT REPLACE(@@sql_mode,'ONLY_FULL_GROUP_BY',''));
Query OK, 0 rows affected (0.00 sec)

mysql> select year, country, sum(profit) as profit from sales group by year with rollup;
+------+---------+--------+
| year | country | profit |
+------+---------+--------+
| 2000 | IN      | 132500 |
| 2001 | IN      |  22600 |
| NULL | IN      | 155100 |
+------+---------+--------+
3 rows in set (0.00 sec)

This behavior is permitted when the ONLY_FULL_GROUP_BY SQL mode is not enabled. If that mode is enabled, the server rejects the query as illegal because country is not listed in the GROUP BY clause. With ONLY_FULL_GROUP_BY enabled, you can still execute the query by using the ANY_VALUE() function for nondeterministic-value columns:

mysql> select year, ANY_VALUE(country) as country, sum(profit) as profit from sales group by year with rollup;
+------+---------+--------+
| year | country | profit |
+------+---------+--------+
| 2000 | IN      | 132500 |
| 2001 | IN      |  22600 |
| NULL | IN      | 155100 |
+------+---------+--------+
3 rows in set (0.00 sec)

Why is grouping required?
Say we want to aggregate data as below
mysql> select country, year, sum(profit) as profit from sales group by country, year UNION select country, NULL, sum(profit) as profit from sales group by country UNION select NULL, year, sum(profit) as profit from sales group by year UNION select NULL, NULL, sum(profit) as profit from sales;
+---------+------+--------+
| country | year | profit |
+---------+------+--------+
| IN      | 2000 |  32500 |
| IN      | 2001 |  20000 |
| USA     | 2000 | 100000 |
| US      | 2001 |   2600 |
| IN      | NULL |  52500 |
| USA     | NULL | 100000 |
| US      | NULL |   2600 |
| NULL    | 2000 | 132500 |
| NULL    | 2001 |  22600 |
| NULL    | NULL | 155100 |
+---------+------+--------+
10 rows in set (0.00 sec)

Group by Country, year
Group by Country
Group by Year
Sum of all profits

Above query used has two issue:
1. Select query is applied on same table 4 times, performace hit, memory hit.
2. Transact Sql code is too much

Hence we can go with Grouping function.

12.20.3 MySQL Handling of GROUP BY
-----------------------------------
SQL-92 and earlier does not permit queries for which the select list, HAVING condition, or ORDER BY list refer to nonaggregated columns that are not named in the GROUP BY clause. For example, this query is illegal in standard SQL-92 because the nonaggregated name column in the select list does not appear in the GROUP BY:

SELECT o.custid, c.name, MAX(o.payment)
  FROM orders AS o, customers AS c
  WHERE o.custid = c.custid
  GROUP BY o.custid;

For the query to be legal in SQL-92, the name column must be omitted from the select list or named in the GROUP BY clause.

SQL:1999 and later permits such nonaggregates per optional feature T301 if they are functionally dependent on GROUP BY columns: If such a relationship exists between name and custid, the query is legal. This would be the case, for example, were custid a primary key of customers.

MySQL implements detection of functional dependence. If the ONLY_FULL_GROUP_BY SQL mode is enabled (which it is by default), MySQL rejects queries for which the select list, HAVING condition, or ORDER BY list refer to nonaggregated columns that are neither named in the GROUP BY clause nor are functionally dependent on them.

MySQL also permits a nonaggregate column not named in a GROUP BY clause when SQL ONLY_FULL_GROUP_BY mode is enabled, provided that this column is limited to a single value, as shown in the following example:

mysql> CREATE TABLE mytable (
    ->    id INT UNSIGNED NOT NULL PRIMARY KEY,
    ->    a VARCHAR(10),
    ->    b INT
    -> );

mysql> INSERT INTO mytable
    -> VALUES (1, 'abc', 1000),
    ->        (2, 'abc', 2000),
    ->        (3, 'def', 4000);

mysql> SET SESSION sql_mode = sys.list_add(@@session.sql_mode, 'ONLY_FULL_GROUP_BY');

mysql> SELECT a, SUM(b) FROM mytable WHERE a = 'abc';
+------+--------+
| a    | SUM(b) |
+------+--------+
| abc  |   3000 |
+------+--------+
It is also possible to have more than one nonaggregate column in the SELECT list when employing ONLY_FULL_GROUP_BY. In this case, every such column must be limited to a single value in the WHERE clause, and all such limiting conditions must be joined by logical AND, as shown here:

mysql> DROP TABLE IF EXISTS mytable;

mysql> CREATE TABLE mytable (
    ->    id INT UNSIGNED NOT NULL PRIMARY KEY,
    ->    a VARCHAR(10),
    ->    b VARCHAR(10),
    ->    c INT
    -> );

mysql> INSERT INTO mytable
    -> VALUES (1, 'abc', 'qrs', 1000),
    ->        (2, 'abc', 'tuv', 2000),
    ->        (3, 'def', 'qrs', 4000),
    ->        (4, 'def', 'tuv', 8000),
    ->        (5, 'abc', 'qrs', 16000),
    ->        (6, 'def', 'tuv', 32000);

mysql> SELECT @@session.sql_mode;
+---------------------------------------------------------------+
| @@session.sql_mode                                            |
+---------------------------------------------------------------+
| ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION |
+---------------------------------------------------------------+

mysql> SELECT a, b, SUM(c) FROM mytable
    ->     WHERE a = 'abc' AND b = 'qrs';
+------+------+--------+
| a    | b    | SUM(c) |
+------+------+--------+
| abc  | qrs  |  17000 |
+------+------+--------+
If ONLY_FULL_GROUP_BY is disabled, a MySQL extension to the standard SQL use of GROUP BY permits the select list, HAVING condition, or ORDER BY list to refer to nonaggregated columns even if the columns are not functionally dependent on GROUP BY columns. This causes MySQL to accept the preceding query. In this case, the server is free to choose any value from each group, so unless they are the same, the values chosen are nondeterministic, which is probably not what you want. Furthermore, the selection of values from each group cannot be influenced by adding an ORDER BY clause. Result set sorting occurs after values have been chosen, and ORDER BY does not affect which value within each group the server chooses. Disabling ONLY_FULL_GROUP_BY is useful primarily when you know that, due to some property of the data, all values in each nonaggregated column not named in the GROUP BY are the same for each group.

You can achieve the same effect without disabling ONLY_FULL_GROUP_BY by using ANY_VALUE() to refer to the nonaggregated column.

The following discussion demonstrates functional dependence, the error message MySQL produces when functional dependence is absent, and ways of causing MySQL to accept a query in the absence of functional dependence.

This query might be invalid with ONLY_FULL_GROUP_BY enabled because the nonaggregated address column in the select list is not named in the GROUP BY clause:

SELECT name, address, MAX(age) FROM t GROUP BY name;
The query is valid if name is a primary key of t or is a unique NOT NULL column. In such cases, MySQL recognizes that the selected column is functionally dependent on a grouping column. For example, if name is a primary key, its value determines the value of address because each group has only one value of the primary key and thus only one row. As a result, there is no randomness in the choice of address value in a group and no need to reject the query.

The query is invalid if name is not a primary key of t or a unique NOT NULL column. In this case, no functional dependency can be inferred and an error occurs:

mysql> SELECT name, address, MAX(age) FROM t GROUP BY name;
ERROR 1055 (42000): Expression #2 of SELECT list is not in GROUP
BY clause and contains nonaggregated column 'mydb.t.address' which
is not functionally dependent on columns in GROUP BY clause; this
is incompatible with sql_mode=only_full_group_by
If you know that, for a given data set, each name value in fact uniquely determines the address value, address is effectively functionally dependent on name. To tell MySQL to accept the query, you can use the ANY_VALUE() function:

SELECT name, ANY_VALUE(address), MAX(age) FROM t GROUP BY name;
Alternatively, disable ONLY_FULL_GROUP_BY.

The preceding example is quite simple, however. In particular, it is unlikely you would group on a single primary key column because every group would contain only one row. For addtional examples demonstrating functional dependence in more complex queries, see Section 12.20.4, “Detection of Functional Dependence”.

If a query has aggregate functions and no GROUP BY clause, it cannot have nonaggregated columns in the select list, HAVING condition, or ORDER BY list with ONLY_FULL_GROUP_BY enabled:

mysql> SELECT name, MAX(age) FROM t;
ERROR 1140 (42000): In aggregated query without GROUP BY, expression
#1 of SELECT list contains nonaggregated column 'mydb.t.name'; this
is incompatible with sql_mode=only_full_group_by
Without GROUP BY, there is a single group and it is nondeterministic which name value to choose for the group. Here, too, ANY_VALUE() can be used, if it is immaterial which name value MySQL chooses:

SELECT ANY_VALUE(name), MAX(age) FROM t;
ONLY_FULL_GROUP_BY also affects handling of queries that use DISTINCT and ORDER BY. Consider the case of a table t with three columns c1, c2, and c3 that contains these rows:

c1 c2 c3
1  2  A
3  4  B
1  2  C
Suppose that we execute the following query, expecting the results to be ordered by c3:

SELECT DISTINCT c1, c2 FROM t ORDER BY c3;
To order the result, duplicates must be eliminated first. But to do so, should we keep the first row or the third? This arbitrary choice influences the retained value of c3, which in turn influences ordering and makes it arbitrary as well. To prevent this problem, a query that has DISTINCT and ORDER BY is rejected as invalid if any ORDER BY expression does not satisfy at least one of these conditions:

The expression is equal to one in the select list

All columns referenced by the expression and belonging to the query's selected tables are elements of the select list

Another MySQL extension to standard SQL permits references in the HAVING clause to aliased expressions in the select list. For example, the following query returns name values that occur only once in table orders:

SELECT name, COUNT(name) FROM orders
  GROUP BY name
  HAVING COUNT(name) = 1;
The MySQL extension permits the use of an alias in the HAVING clause for the aggregated column:

SELECT name, COUNT(name) AS c FROM orders
  GROUP BY name
  HAVING c = 1;
Standard SQL permits only column expressions in GROUP BY clauses, so a statement such as this is invalid because FLOOR(value/100) is a noncolumn expression:

SELECT id, FLOOR(value/100)
  FROM tbl_name
  GROUP BY id, FLOOR(value/100);
MySQL extends standard SQL to permit noncolumn expressions in GROUP BY clauses and considers the preceding statement valid.

Standard SQL also does not permit aliases in GROUP BY clauses. MySQL extends standard SQL to permit aliases, so another way to write the query is as follows:

SELECT id, FLOOR(value/100) AS val
  FROM tbl_name
  GROUP BY id, val;
The alias val is considered a column expression in the GROUP BY clause.

In the presence of a noncolumn expression in the GROUP BY clause, MySQL recognizes equality between that expression and expressions in the select list. This means that with ONLY_FULL_GROUP_BY SQL mode enabled, the query containing GROUP BY id, FLOOR(value/100) is valid because that same FLOOR() expression occurs in the select list. However, MySQL does not try to recognize functional dependence on GROUP BY noncolumn expressions, so the following query is invalid with ONLY_FULL_GROUP_BY enabled, even though the third selected expression is a simple formula of the id column and the FLOOR() expression in the GROUP BY clause:

SELECT id, FLOOR(value/100), id+FLOOR(value/100)
  FROM tbl_name
  GROUP BY id, FLOOR(value/100);
A workaround is to use a derived table:

SELECT id, F, id+F
  FROM
    (SELECT id, FLOOR(value/100) AS F
     FROM tbl_name
     GROUP BY id, FLOOR(value/100)) AS dt;

12.20.4 Detection of Functional Dependence
------------------------------------------
12.20.4 Detection of Functional Dependence

The following discussion provides several examples of the ways in which MySQL detects functional dependencies. The examples use this notation:

{X} -> {Y}
Understand this as “X uniquely determines Y,” which also means that Y is functionally dependent on X.

The examples use the world database, which can be downloaded from https://dev.mysql.com/doc/index-other.html. You can find details on how to install the database on the same page.

Functional Dependencies Derived from Keys

Functional Dependencies Derived from Multiple-Column Keys and from Equalities

Functional Dependency Special Cases

Functional Dependencies and Views

Combinations of Functional Dependencies

Functional Dependencies Derived from Keys

The following query selects, for each country, a count of spoken languages:

SELECT co.Name, COUNT(*)
FROM countrylanguage cl, country co
WHERE cl.CountryCode = co.Code
GROUP BY co.Code;
co.Code is a primary key of co, so all columns of co are functionally dependent on it, as expressed using this notation:

{co.Code} -> {co.*}
Thus, co.name is functionally dependent on GROUP BY columns and the query is valid.

A UNIQUE index over a NOT NULL column could be used instead of a primary key and the same functional dependence would apply. (This is not true for a UNIQUE index that permits NULL values because it permits multiple NULL values and in that case uniqueness is lost.)

Functional Dependencies Derived from Multiple-Column Keys and from Equalities

This query selects, for each country, a list of all spoken languages and how many people speak them:

SELECT co.Name, cl.Language,
cl.Percentage * co.Population / 100.0 AS SpokenBy
FROM countrylanguage cl, country co
WHERE cl.CountryCode = co.Code
GROUP BY cl.CountryCode, cl.Language;
The pair (cl.CountryCode, cl.Language) is a two-column composite primary key of cl, so that column pair uniquely determines all columns of cl:

{cl.CountryCode, cl.Language} -> {cl.*}
Moreover, because of the equality in the WHERE clause:

{cl.CountryCode} -> {co.Code}
And, because co.Code is primary key of co:

{co.Code} -> {co.*}
“Uniquely determines” relationships are transitive, therefore:

{cl.CountryCode, cl.Language} -> {cl.*,co.*}
As a result, the query is valid.

As with the previous example, a UNIQUE key over NOT NULL columns could be used instead of a primary key.

An INNER JOIN condition can be used instead of WHERE. The same functional dependencies apply:

SELECT co.Name, cl.Language,
cl.Percentage * co.Population/100.0 AS SpokenBy
FROM countrylanguage cl INNER JOIN country co
ON cl.CountryCode = co.Code
GROUP BY cl.CountryCode, cl.Language;
Functional Dependency Special Cases

Whereas an equality test in a WHERE condition or INNER JOIN condition is symmetric, an equality test in an outer join condition is not, because tables play different roles.

Assume that referential integrity has been accidentally broken and there exists a row of countrylanguage without a corresponding row in country. Consider the same query as in the previous example, but with a LEFT JOIN:

SELECT co.Name, cl.Language,
cl.Percentage * co.Population/100.0 AS SpokenBy
FROM countrylanguage cl LEFT JOIN country co
ON cl.CountryCode = co.Code
GROUP BY cl.CountryCode, cl.Language;
For a given value of cl.CountryCode, the value of co.Code in the join result is either found in a matching row (determined by cl.CountryCode) or is NULL-complemented if there is no match (also determined by cl.CountryCode). In each case, this relationship applies:

{cl.CountryCode} -> {co.Code}
cl.CountryCode is itself functionally dependent on {cl.CountryCode, cl.Language} which is a primary key.

If in the join result co.Code is NULL-complemented, co.Name is as well. If co.Code is not NULL-complemented, then because co.Code is a primary key, it determines co.Name. Therefore, in all cases:

{co.Code} -> {co.Name}
Which yields:

{cl.CountryCode, cl.Language} -> {cl.*,co.*}
As a result, the query is valid.

However, suppose that the tables are swapped, as in this query:

SELECT co.Name, cl.Language,
cl.Percentage * co.Population/100.0 AS SpokenBy
FROM country co LEFT JOIN countrylanguage cl
ON cl.CountryCode = co.Code
GROUP BY cl.CountryCode, cl.Language;
Now this relationship does not apply:

{cl.CountryCode, cl.Language} -> {cl.*,co.*}
Indeed, all NULL-complemented rows made for cl is put into a single group (they have both GROUP BY columns equal to NULL), and inside this group the value of co.Name can vary. The query is invalid and MySQL rejects it.

Functional dependence in outer joins is thus linked to whether determinant columns belong to the left or right side of the LEFT JOIN. Determination of functional dependence becomes more complex if there are nested outer joins or the join condition does not consist entirely of equality comparisons.

Functional Dependencies and Views

Suppose that a view on countries produces their code, their name in uppercase, and how many different official languages they have:

CREATE VIEW country2 AS
SELECT co.Code, UPPER(co.Name) AS UpperName,
COUNT(cl.Language) AS OfficialLanguages
FROM country AS co JOIN countrylanguage AS cl
ON cl.CountryCode = co.Code
WHERE cl.isOfficial = 'T'
GROUP BY co.Code;
This definition is valid because:

{co.Code} -> {co.*}
In the view result, the first selected column is co.Code, which is also the group column and thus determines all other selected expressions:

{country2.Code} -> {country2.*}
MySQL understands this and uses this information, as described following.

This query displays countries, how many different official languages they have, and how many cities they have, by joining the view with the city table:

SELECT co2.Code, co2.UpperName, co2.OfficialLanguages,
COUNT(*) AS Cities
FROM country2 AS co2 JOIN city ci
ON ci.CountryCode = co2.Code
GROUP BY co2.Code;
This query is valid because, as seen previously:

{co2.Code} -> {co2.*}
MySQL is able to discover a functional dependency in the result of a view and use that to validate a query which uses the view. The same would be true if country2 were a derived table (or common table expression), as in:

SELECT co2.Code, co2.UpperName, co2.OfficialLanguages,
COUNT(*) AS Cities
FROM
(
 SELECT co.Code, UPPER(co.Name) AS UpperName,
 COUNT(cl.Language) AS OfficialLanguages
 FROM country AS co JOIN countrylanguage AS cl
 ON cl.CountryCode=co.Code
 WHERE cl.isOfficial='T'
 GROUP BY co.Code
) AS co2
JOIN city ci ON ci.CountryCode = co2.Code
GROUP BY co2.Code;
Combinations of Functional Dependencies

MySQL is able to combine all of the preceding types of functional dependencies (key based, equality based, view based) to validate more complex queries.


Window Functions
-----------------
Partition By - From which column we want to partition the data.
--------------

Over clause in sql server:
--------------------------
The over clause along with partition by is used to break up the data into partitions.
Over clause can be used with PARTITION BY or ORDER BY or BOTH.
The specified function operates on each partition.
Syntax: function () OVER (PARTITION BY COL1, COL2)

EG. COUNT(Gender) OVER (PARTITION BY GENDER) will partition the data by GENDER i.e there will be 2 partitions(MALE AND FEMALE) and the count function will be applied  over each partition

Any of the following function can be used
COUNT, AVG, SUM, MIN, MAX, ROW_NUMBER, RANK, DENSE_RANK etc


What is achieved by OVER can be achieved by group by as well but it might require too much code in group by.

Let's look at an example:
CREATE TABLE Employees (
    id tinyint,
    name varchar(30),
    gender varchar(6),
    salary int
);

insert into employees values(1, 'mark', 'male', 5000),
(2, 'pam', 'female', 5500),
(3, 'tod', 'male', 6000),
(4, 'sara', 'female', 4000),
(5, 'ben', 'male', 15000);

select * from employees;

WE NEED Name, Gender, GenderTotal, AvgSal, MinSal, MaxSal in the output:

Using Group by

Since we want Non-Aggregated columns like Name and Gender in the output hence this cannot be done by a single query,
SET sql_mode = 'ONLY_FULL_GROUP_BY';
select Name, Gender, count(Gender) as GenderTotal,
AVG(Salary) as AvgSal,
MIN(Salary) as MinSal,
MAX(Salary) as MaxSal
from Employees
group by Gender;

Above query results in below error:
Error Code: 1055. Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'test.Employees.name' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by


Then, another solution with group by is to use multiple select queries and join them, as below
mysql> select e.Name, e.Gender, g.GenderTotal, g.AvgSal, g.MinSal, g.MaxSal
    -> from Employees e
    -> JOIN
    -> (select gender, count(Gender) as GenderTotal,
    -> AVG(Salary) as AvgSal,
    -> MIN(Salary) as MinSal,
    -> MAX(Salary) as MaxSal
    -> from Employees
    -> group by Gender) as g
    -> ON e.Gender = g.Gender;
+------+--------+-------------+-----------+--------+--------+
| Name | Gender | GenderTotal | AvgSal    | MinSal | MaxSal |
+------+--------+-------------+-----------+--------+--------+
| mark | male   |           3 | 8666.6667 |   5000 |  15000 |
| pam  | female |           2 | 4750.0000 |   4000 |   5500 |
| tod  | male   |           3 | 8666.6667 |   5000 |  15000 |
| sara | female |           2 | 4750.0000 |   4000 |   5500 |
| ben  | male   |           3 | 8666.6667 |   5000 |  15000 |
+------+--------+-------------+-----------+--------+--------+

BUT the above code is verbose and requires multiple queries, group by and join.
Same thing can be achieved by over and partition by in a single query

mysql> select name, gender,
    -> count(id) over w as gender_total,
    -> avg(salary) over w as avg_sal,
    -> max(salary) over w as max_sal,
    -> min(salary) over w as min_sal
    -> from employees
    -> window w as (PARTITION BY gender);
+--------+--------+--------------+-----------+---------+---------+
| name   | gender | gender_total | avg_sal   | max_sal | min_sal |
+--------+--------+--------------+-----------+---------+---------+
| pam    | female |            2 | 4750.0000 |    5500 |    4000 |
| sara   | female |            2 | 4750.0000 |    5500 |    4000 |
| mark   | male   |            4 | 8000.0000 |   15000 |    5000 |
| tod    | male   |            4 | 8000.0000 |   15000 |    5000 |
| ben    | male   |            4 | 8000.0000 |   15000 |    5000 |
| Ramesh | male   |            4 | 8000.0000 |   15000 |    5000 |
+--------+--------+--------------+-----------+---------+---------+

ANOTHER WAY:

mysql> select name, gender,
    -> count(Gender) over (partition by Gender) as GenderTotal,
    -> AVG(Salary) over (partition by Gender) as AvgSal,
    -> MIN(Salary) over (partition by Gender) as MinSal,
    -> MAX(Salary) over (partition by Gender) as MaxSal
    -> from Employees;
+------+--------+-------------+-----------+--------+--------+
| name | gender | GenderTotal | AvgSal    | MinSal | MaxSal |
+------+--------+-------------+-----------+--------+--------+
| pam  | female |           2 | 4750.0000 |   4000 |   5500 |
| sara | female |           2 | 4750.0000 |   4000 |   5500 |
| mark | male   |           3 | 8666.6667 |   5000 |  15000 |
| tod  | male   |           3 | 8666.6667 |   5000 |  15000 |
| ben  | male   |           3 | 8666.6667 |   5000 |  15000 |
+------+--------+-------------+-----------+--------+--------+

Using Partiton BY and Order by with Over:
mysql> select name, gender,
    -> count(id) over w as gender_total,
    -> avg(salary) over w as avg_sal,
    -> max(salary) over w as max_sal,
    -> min(salary) over w as min_sal
    -> from employees
    -> window w as (partition by gender order BY salary);
+--------+--------+--------------+-----------+---------+---------+
| name   | gender | gender_total | avg_sal   | max_sal | min_sal |
+--------+--------+--------------+-----------+---------+---------+
| sara   | female |            1 | 4000.0000 |    4000 |    4000 |
| pam    | female |            2 | 4750.0000 |    5500 |    4000 |
| mark   | male   |            1 | 5000.0000 |    5000 |    5000 |
| tod    | male   |            3 | 5666.6667 |    6000 |    5000 |
| Ramesh | male   |            3 | 5666.6667 |    6000 |    5000 |
| ben    | male   |            4 | 8000.0000 |   15000 |    5000 |
+--------+--------+--------------+-----------+---------+---------+


ROW_Number Function -
---------------------
Get the row numbers by partition and/or by order.
Order by clause is required
Partition by clause is optional.

NOTE - PARTITION BY SHOULD ALWAYS BE USED BEFORE ORDER BY ELSE RESULTS IN SYNTAX ERROR.

Syntax - ROW_NUMBER() OVER ([PARTITION BY] ORDER BY Col1, Col2)

mysql> select name, gender, id, ROW_NUMBER() OVER (PARTITION BY gender ORDER BY Gender) as row_num from employees;
+------+--------+------+---------+
| name | gender | id   | row_num |
+------+--------+------+---------+
| pam  | female |    2 |       1 |
| sara | female |    4 |       2 |
| mark | male   |    1 |       1 |
| tod  | male   |    3 |       2 |
| ben  | male   |    5 |       3 |
+------+--------+------+---------+

If we want to get 1st row num for each gender
select * from (select name, gender, id, ROW_NUMBER() OVER (PARTITION BY gender ORDER BY Gender) as row_num from employees) as emp where row_num < 2;

mysql> select * from (select name, gender, id, ROW_NUMBER() OVER (PARTITION BY gender ORDER BY Gender) as row_num from employees) as emp where row_num < 2;
+------+--------+------+---------+
| name | gender | id   | row_num |
+------+--------+------+---------+
| pam  | female |    2 |       1 |
| mark | male   |    1 |       1 |
+------+--------+------+---------+

similarly if we want to delete all rows except first row for each gender.
mysql> delete from (select name, gender, id, ROW_NUMBER() OVER (PARTITION BY gender ORDER BY Gender) as row_num from employees) as emp where row_num > 1;


RANK AND DENSE_RANK FUNCTION
----------------------------
RANK AND DENSE_RANK function are used to provide rank to row, eg, we want to find nth salary from a table by gender.
Order by clause is mandatory
partition by clause is optional

Diff between Rank and Dense Rank?
Rank skips the next number if there is a tie, eg if there is a tie in first two row output will be 1,1,3,4,5
Dense_Rank does not skip the next number if there is a tie, eg if there is a tie in first two row output will be 1,1,2,3,4

Eg. Get the rank and dense_rank details from Employees table

insert into employees values(6, 'Ramesh', 'Male', 15000);
select * from Employees;

mysql> select name, salary, gender,
    -> RANK() over w as ranks,
    ->     DEnSE_RANK() over w as 'dense_rank' # if we use function name as a varible then it should be within quotes
    ->     from employees
    ->     window w as (partition by gender order by salary desc);
+--------+--------+--------+-------+------------+
| name   | salary | gender | ranks | dense_rank |
+--------+--------+--------+-------+------------+
| pam    |   5500 | female |     1 |          1 |
| sara   |   4000 | female |     2 |          2 |
| ben    |  15000 | male   |     1 |          1 |
| Ramesh |  15000 | Male   |     1 |          1 |
| tod    |   6000 | male   |     3 |          2 |
| mark   |   5000 | male   |     4 |          3 |
+--------+--------+--------+-------+------------+

Get 3rd highest salary for male using Rank
mysql> select * from(select name, salary, gender,
    -> rank() over w as sal_rank
    -> from employees
    -> window w as (partition by gender order by salary desc)) as emp
    -> where sal_rank = 3 and gender='male';
+------+--------+--------+----------+
| name | salary | gender | sal_rank |
+------+--------+--------+----------+
| tod  |   6000 | male   |        3 |
+------+--------+--------+----------+



Get Highest salary for female using dense_rank
mysql> select * from(select name, salary, gender,
    -> dense_rank() over w as sal_dense_rank
    -> from employees
    -> window w as (partition by gender order by salary desc)) as emp
    -> where sal_dense_rank = 1 and gender='female';
+------+--------+--------+----------------+
| name | salary | gender | sal_dense_rank |
+------+--------+--------+----------------+
| pam  |   5500 | female |              1 |
+------+--------+--------+----------------+

Similarities and Dissimilarities between ROW_NUMBER, RANK AND DENSE FUNCTION:
-----------------------------------------------------------------------------
Similarities
IF there are no duplicates in column which is used with order by, then all 3 functions behaves same i.e they return increasing integer numbers starting from 1.
ORDER BY is mandatory for all 3 function.
PARTITION BY is optional for all 3 functions.

mysql> select * from employees;
+------+------+--------+--------+
| id   | name | gender | salary |
+------+------+--------+--------+
|    1 | mark | male   |   5000 |
|    2 | pam  | female |   5500 |
|    3 | tod  | male   |   6000 |
|    4 | sara | female |   4000 |
|    5 | ben  | male   |  15000 |
+------+------+--------+--------+
5 rows in set (0.00 sec)

mysql> select name, gender, salary,
    -> row_number() over w as rnum,
    -> rank() over w as rnk,
    -> dense_rank() over w as drnk
    -> from employees
    -> window w as (order by salary desc);
+------+--------+--------+------+-----+------+
| name | gender | salary | rnum | rnk | drnk |
+------+--------+--------+------+-----+------+
| ben  | male   |  15000 |    1 |   1 |    1 |
| tod  | male   |   6000 |    2 |   2 |    2 |
| pam  | female |   5500 |    3 |   3 |    3 |
| mark | male   |   5000 |    4 |   4 |    4 |
| sara | female |   4000 |    5 |   5 |    5 |
+------+--------+--------+------+-----+------+


Dissimilarities:
When there are duplicates in column which is used with order by, then all 3 functions behaves differently.
ROW_NUMBER behaves same even with duplicates or without duplicates, it return increasing integer numbers starting from 1. Eg. 1,2, 3,4 ,5
RANK function return same rank(int value) for duplicates and skips the next value(s).   1,1,3,4,5
DENSE_RANK function return same rank(int value) for duplicates and does not skip the next value(s). 1,1,2,3,4

mysql> select * from employees;
+------+--------+--------+--------+
| id   | name   | gender | salary |
+------+--------+--------+--------+
|    1 | mark   | male   |   5000 |
|    2 | pam    | female |   5500 |
|    3 | tod    | male   |   6000 |
|    4 | sara   | female |   4000 |
|    5 | ben    | male   |  15000 |
|    6 | Ramesh | Male   |  15000 |
+------+--------+--------+--------+
6 rows in set (0.00 sec)

mysql> select name, gender, salary,
    -> row_number() over w as rnum,
    -> rank() over w as rnk,
    -> dense_rank() over w as drnk
    -> from employees
    -> window w as (order by salary desc);
+--------+--------+--------+------+-----+------+
| name   | gender | salary | rnum | rnk | drnk |
+--------+--------+--------+------+-----+------+
| ben    | male   |  15000 |    1 |   1 |    1 |
| Ramesh | Male   |  15000 |    2 |   1 |    1 |
| tod    | male   |   6000 |    3 |   3 |    2 |
| pam    | female |   5500 |    4 |   4 |    3 |
| mark   | male   |   5000 |    5 |   5 |    4 |
| sara   | female |   4000 |    6 |   6 |    5 |
+--------+--------+--------+------+-----+------+


Calculate Running Total:
------------------------
Get the running total of employees by gender from employees table
insert into employees values (6, 'Ramesh', 'male', 6000);
select * from employees;

Two ways of writing the query is

mysql> select name, gender, salary,
    -> sum(salary) over (partition by gender order by id) as running_sal
    -> from employees;
+--------+--------+--------+-------------+
| name   | gender | salary | running_sal |
+--------+--------+--------+-------------+
| pam    | female |   5500 |        5500 |
| sara   | female |   4000 |        9500 |
| mark   | male   |   5000 |        5000 |
| tod    | male   |   6000 |       11000 |
| ben    | male   |  15000 |       26000 |
| Ramesh | male   |   6000 |       32000 |
+--------+--------+--------+-------------+
6 rows in set (0.01 sec)

mysql> select name, gender, salary,
    -> sum(salary) over w as running_sal
    -> from employees
    -> window w as (partition by gender order by id);
+--------+--------+--------+-------------+
| name   | gender | salary | running_sal |
+--------+--------+--------+-------------+
| pam    | female |   5500 |        5500 |
| sara   | female |   4000 |        9500 |
| mark   | male   |   5000 |        5000 |
| tod    | male   |   6000 |       11000 |
| ben    | male   |  15000 |       26000 |
| Ramesh | male   |   6000 |       32000 |
+--------+--------+--------+-------------+

In above query, why aren't we using salary along with order by clause but id?
because the salary column contains duplicates, and if a we use that we can summation of duplicate values added at a time. See the example below
removing partition by gender to make thing simple.

First running order by id and then order by salary and let's see the difference.
mysql> select id, name, gender, salary,
    -> sum(salary) over w as running_sal
    -> from employees
    -> window w as (order by id);
+------+--------+--------+--------+-------------+
| id   | name   | gender | salary | running_sal |
+------+--------+--------+--------+-------------+
|    1 | mark   | male   |   5000 |        5000 |
|    2 | pam    | female |   5500 |       10500 |
|    3 | tod    | male   |   6000 |       16500 |
|    4 | sara   | female |   4000 |       20500 |
|    5 | ben    | male   |  15000 |       35500 |
|    6 | Ramesh | male   |   6000 |       41500 |
+------+--------+--------+--------+-------------+
6 rows in set (0.01 sec)

mysql> select id, name, gender, salary,
    -> sum(salary) over w as running_sal
    -> from employees
    -> window w as (order by salary);
+------+--------+--------+--------+-------------+
| id   | name   | gender | salary | running_sal |
+------+--------+--------+--------+-------------+
|    4 | sara   | female |   4000 |        4000 |
|    1 | mark   | male   |   5000 |        9000 |
|    2 | pam    | female |   5500 |       14500 |
|    3 | tod    | male   |   6000 |       26500 |
|    6 | Ramesh | male   |   6000 |       26500 |
|    5 | ben    | male   |  15000 |       41500 |
+------+--------+--------+--------+-------------+
6 rows in set (0.00 sec)

See the Tod and Ramesh column having duplication in running sum as well.

Hence it is always better to use column with distinct values along with order by clause.

Question -
Find the moving avg salary of employees
mysql> select id, name, gender, salary,
    -> avg(salary) over w as avg_sal
    -> from employees
    -> window w as (order by id);
+------+--------+--------+--------+-----------+
| id   | name   | gender | salary | avg_sal   |
+------+--------+--------+--------+-----------+
|    1 | mark   | male   |   5000 | 5000.0000 |
|    2 | pam    | female |   5500 | 5250.0000 |
|    3 | tod    | male   |   6000 | 5500.0000 |
|    4 | sara   | female |   4000 | 5125.0000 |
|    5 | ben    | male   |  15000 | 7100.0000 |
|    6 | Ramesh | male   |   6000 | 6916.6667 |
+------+--------+--------+--------+-----------+
6 rows in set (0.00 sec)


NTILE FUNCTION -
-----------------
This function divides the number of rows into groups.
Order by clause if mandatory.
Partition by clause is optional.
Distributes the rows into a specified number of groups.
If the number of rows is not divisible by number of groups, you may have groups of different sizes.
    - Larger groups come before smaller groups.
Eg. NTILE(2) of 10 rows divides the rows in 2 Groups(5 in each group)
    NTILE(3) of 10 rows divides the rows in 3 Groups(4 in first group, 3 in 2nd and 3rd group)

Syntax: NTILE(Number_of_groups) OVER (ORDER BY col1, col2...colN)

Example:
Divide rows with equal values in groups
mysql> select Name, Gender, salary,
    -> NTILE(2) over (order by Salary) as 'Ntile'
    -> from employees;
+--------+--------+--------+-------+
| Name   | Gender | salary | Ntile |
+--------+--------+--------+-------+
| sara   | female |   4000 |     1 |
| mark   | male   |   5000 |     1 |
| pam    | female |   5500 |     1 |
| tod    | male   |   6000 |     2 |
| Ramesh | male   |   6000 |     2 |
| ben    | male   |  15000 |     2 |
+--------+--------+--------+-------+

Groups of unequal size:
mysql> select Name, Gender, salary,
    -> NTILE(4) over (order by Salary) as 'Ntile'
    -> from employees;
+--------+--------+--------+-------+
| Name   | Gender | salary | Ntile |
+--------+--------+--------+-------+
| sara   | female |   4000 |     1 |
| mark   | male   |   5000 |     1 |
| pam    | female |   5500 |     2 |
| tod    | male   |   6000 |     2 |
| Ramesh | male   |   6000 |     3 |
| ben    | male   |  15000 |     4 |
+--------+--------+--------+-------+
6 rows in set (0.00 sec)

Using partition by:
mysql> select Name, Gender, salary,
    -> NTILE(2) over (PARTITION BY gender order by Salary) as 'Ntile'
    -> from employees;
+--------+--------+--------+-------+
| Name   | Gender | salary | Ntile |
+--------+--------+--------+-------+
| sara   | female |   4000 |     1 |
| pam    | female |   5500 |     2 |
| mark   | male   |   5000 |     1 |
| tod    | male   |   6000 |     1 |
| Ramesh | male   |   6000 |     2 |
| ben    | male   |  15000 |     2 |
+--------+--------+--------+-------+

LEAD AND LAG FUNCTION
----------------------
Lead function is used to access subsequent row data along with the current row data.
Lag function is used to access previous row data along with the current row data.
ORDER BY clause is mandatory
PARTITION BY clause is optional

Syntax:
LEAD(column_name[,offset,default_value]) OVER (ORDER BY Col1, Col2, ...)
LEAD(column_name[,offset,default_value]) OVER (ORDER BY Col1, Col2, ...)

mandatory param - column name
Optional params -
Offset - Number of rows to lead or lag
Default_value - The default value to return whern the number of rows to lead or lag goes beyond first row or last row in a table or partition. If default value is not specified NULL is returned.

It is similar to shift function in pandas.
Consider a column values as an array which is left shifted for LAG and right shifted for LEAD.

Default Behaviour -
mysql> select Name, Gender, salary,
    -> LEAD(SALARY) over w as 'lead',
    -> LAG(SALARY) over w as 'lag'
    -> from employees
    -> window w as (order by Salary);
+--------+--------+--------+-------+------+
| Name   | Gender | salary | lead  | lag  |
+--------+--------+--------+-------+------+
| sara   | female |   4000 |  5000 | NULL |
| mark   | male   |   5000 |  5500 | 4000 |
| pam    | female |   5500 |  6000 | 5000 |
| tod    | male   |   6000 |  6000 | 5500 |
| Ramesh | male   |   6000 | 15000 | 6000 |
| ben    | male   |  15000 |  NULL | 6000 |
+--------+--------+--------+-------+------+

Using OFFSET and DEFAULT_VALUE
mysql> select Name, Gender, salary,
    -> LEAD(SALARY, 2, -1) over w as 'lead',
    -> LAG(SALARY,1,-1) over w as 'lag'
    -> from employees
    -> window w as (order by Salary);
+--------+--------+--------+-------+------+
| Name   | Gender | salary | lead  | lag  |
+--------+--------+--------+-------+------+
| sara   | female |   4000 |  5500 |   -1 |
| mark   | male   |   5000 |  6000 | 4000 |
| pam    | female |   5500 |  6000 | 5000 |
| tod    | male   |   6000 | 15000 | 5500 |
| Ramesh | male   |   6000 |    -1 | 6000 |
| ben    | male   |  15000 |    -1 | 6000 |
+--------+--------+--------+-------+------+

Using Partition BY
mysql> select Name, Gender, salary,
    -> LEAD(SALARY, 2, -1) over w as 'lead',
    -> LAG(SALARY,1,-1) over w as 'lag'
    -> from employees
    -> window w as (partition by gender order by Salary);
+--------+--------+--------+-------+------+
| Name   | Gender | salary | lead  | lag  |
+--------+--------+--------+-------+------+
| sara   | female |   4000 |    -1 |   -1 |
| pam    | female |   5500 |    -1 | 4000 |
| mark   | male   |   5000 |  6000 |   -1 |
| tod    | male   |   6000 | 15000 | 5000 |
| Ramesh | male   |   6000 |    -1 | 6000 |
| ben    | male   |  15000 |    -1 | 6000 |
+--------+--------+--------+-------+------+


FIRST_VALUE()
-------------
Retrieves the first value from the specified column.
ORDER BY clause is required.
PARTITION BY clause is optional.

SYNTAX - FIRST_VALUE(column_name) OVER (ORDER BY col1, col2)

mysql> select Name, Gender, salary,
    -> FIRST_VALUE(salary) OVER (PARTITION BY gender ORDER BY salary DESC) as 'first_value'
    -> from employees;
+--------+--------+--------+-------------+
| Name   | Gender | salary | first_value |
+--------+--------+--------+-------------+
| pam    | female |   5500 |        5500 |
| sara   | female |   4000 |        5500 |
| ben    | male   |  15000 |       15000 |
| tod    | male   |   6000 |       15000 |
| Ramesh | male   |   6000 |       15000 |
| mark   | male   |   5000 |       15000 |
+--------+--------+--------+-------------+

LAST_VALUE() - Similar to first_value which provides last element from the selected fields.

WINDOW FUNCTIONS -
We have difference categories of window functions -
Eg.
Aggregate Functions - AVG, SUM, MIN, MAX, COUNT etc.
Ranking Functions - RANK, DENSE_RANK, ROW_NUMBER, NTILE etc
Analytics Function - LEAD, LAG, FIRST_VALUE, LAST_VALUE etc

OVER clause defines the partitioning and ordering of rows(i.e windows) for the above functions to operate on. Hence these functions are called Window functions. The OVER clause accepts the following 3 arguments to define a window for these functions to operate on:
* Order by - Defines the logical order of the rows
* Partition by - Divides the query resilt set into partitions. The window function is applied to each partition separately.
* ROWS and RANGE clause - Further limits the rows within the partition by specifying start and end points within the partition.

The default for ROWS and RANGE clause is
RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW[ OR UNBOUNDED FOLLOWING]
    # We will understand   UNBOUNDED PRECEDING AND CURRENT ROW

Initially we were calculating moving average using AVG() and over using below code:

mysql> select id, name, gender, salary,
    -> avg(salary) over w as avg_sal
    -> from employees
    -> window w as (order by id);
+------+--------+--------+--------+-----------+
| id   | name   | gender | salary | avg_sal   |
+------+--------+--------+--------+-----------+
|    1 | mark   | male   |   5000 | 5000.0000 |
|    2 | pam    | female |   5500 | 5250.0000 |
|    3 | tod    | male   |   6000 | 5500.0000 |
|    4 | sara   | female |   4000 | 5125.0000 |
|    5 | ben    | male   |  15000 | 7100.0000 |
|    6 | Ramesh | male   |   6000 | 6916.6667 |
+------+--------+--------+--------+-----------+

In above code the value of ROWS is default i.e UNBOUNDED PRECEDING(means first row) AND CURRENT ROW, hence we were getting avg between 1st row and current row, but what if we need avg of all salaries in each row, we can use ROWS for that.

mysql> select Name, Gender, salary,
    -> AVG(salary) OVER w as 'avg_sal',
    -> COUNT(salary) OVER w as 'count_sal',
    -> SUM(salary) OVER w as 'sum_sal'
    -> from employees
    -> window w as (ORDER BY salary ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING);
+--------+--------+--------+-----------+-----------+-----------+
| Name   | Gender | salary | avg_sal   | count_sal | sum_sal |
+--------+--------+--------+-----------+-----------+-----------+
| sara   | female |   4000 | 6916.6667 |         6 |     41500 |
| mark   | male   |   5000 | 6916.6667 |         6 |     41500 |
| pam    | female |   5500 | 6916.6667 |         6 |     41500 |
| tod    | male   |   6000 | 6916.6667 |         6 |     41500 |
| Ramesh | male   |   6000 | 6916.6667 |         6 |     41500 |
| ben    | male   |  15000 | 6916.6667 |         6 |     41500 |
+--------+--------+--------+-----------+-----------+-----------+

In above code UNBOUNDED FOLLOWING means the last row.

Similarly if we need to find avg for previous, current and next row we can use 1 PRECEDING AND 1 FOLLOWING.
mysql> select Name, Gender, salary,
    -> AVG(salary) OVER w as 'avg_sal',
    -> COUNT(salary) OVER w as 'count_sal',
    -> SUM(salary) OVER w as 'sum_sal'
    -> from employees
    -> window w as (PARTITION BY gender ORDER BY salary ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING);
+--------+--------+--------+------------+-----------+-----------+
| Name   | Gender | salary | avg_sal    | count_sal | sum_sal |
+--------+--------+--------+------------+-----------+-----------+
| sara   | female |   4000 |  4750.0000 |         2 |      9500 |
| pam    | female |   5500 |  4750.0000 |         2 |      9500 |
| mark   | male   |   5000 |  5500.0000 |         2 |     11000 |
| tod    | male   |   6000 |  5666.6667 |         3 |     17000 |
| Ramesh | male   |   6000 |  9000.0000 |         3 |     27000 |
| ben    | male   |  15000 | 10500.0000 |         2 |     21000 |
+--------+--------+--------+------------+-----------+-----------+

Difference between ROWS and RANGE Clause:
-----------------------------------------
ROWS and Range clause acts similart when there are not duplicates in the column on which we operate.
But if there are duplicates, ROWS consider them distinct and gives the proper output but RANGE gives combined output of duplicate rows.

Example:
mysql> select name, gender, salary,
    -> sum(salary) over (order by salary ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as rows_running_sal,
    -> sum(salary) over (order by salary RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as range_running_sal
    -> from employees
    -> window w as (partition by gender order BY salary);
+--------+--------+--------+------------------+-------------------+
| name   | gender | salary | rows_running_sal | range_running_sal |
+--------+--------+--------+------------------+-------------------+
| sara   | female |   4000 |             4000 |              4000 |
| mark   | male   |   5000 |             9000 |              9000 |
| pam    | female |   5500 |            14500 |             14500 |
| tod    | male   |   6000 |            20500 |             26500 |
| Ramesh | male   |   6000 |            26500 |             26500 |
| ben    | male   |  15000 |            41500 |             41500 |
+--------+--------+--------+------------------+-------------------+

Tod and Ramesh have duplicate salary hence rows and range difference can be seen.

Comparing with default running sum without rows and range
mysql> select name, gender, salary,
    -> sum(salary) over (order by salary) as default_running_sal,
    -> sum(salary) over (order by salary ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as rows_running_sal,
    -> sum(salary) over (order by salary RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as range_running_sal
    -> from employees
    -> window w as (partition by gender order BY salary);
+--------+--------+--------+---------------------+------------------+-------------------+
| name   | gender | salary | default_running_sal | rows_running_sal | range_running_sal |
+--------+--------+--------+---------------------+------------------+-------------------+
| sara   | female |   4000 |                4000 |             4000 |              4000 |
| mark   | male   |   5000 |                9000 |             9000 |              9000 |
| pam    | female |   5500 |               14500 |            14500 |             14500 |
| tod    | male   |   6000 |               26500 |            20500 |             26500 |
| Ramesh | male   |   6000 |               26500 |            26500 |             26500 |
| ben    | male   |  15000 |               41500 |            41500 |             41500 |
+--------+--------+--------+---------------------+------------------+-------------------+




12.21 Window Functions
======================
MySQL supports window functions that, for each row from a query, perform a calculation using rows related to that row. The following sections discuss how to use window functions, including descriptions of the OVER and WINDOW clauses. The first section provides descriptions of the nonaggregate window functions. For descriptions of the aggregate window functions, see Section 12.20.1, “Aggregate Function Descriptions”.

For information about optimization and window functions, see Section 8.2.1.21, “Window Function Optimization”.

12.21.1 Window Function Descriptions
-------------------------------------
