3.2 Entering Queries
Make sure that you are connected to the server, as discussed in the previous section. Doing so does not in itself select any database to work with, but that is okay. At this point, it is more important to find out a little about how to issue queries than to jump right in creating tables, loading data into them, and retrieving data from them. This section describes the basic principles of entering queries, using several queries you can try out to familiarize yourself with how mysql works.

Here is a simple query that asks the server to tell you its version number and the current date. Type it in as shown here following the mysql> prompt and press Enter:
SELECT VERSION(), CURRENT_DATE;

This query illustrates several things about mysql:

A query normally consists of an SQL statement followed by a semicolon. (There are some exceptions where a semicolon may be omitted. QUIT, mentioned earlier, is one of them. We'll get to others later.)

When you issue a query, mysql sends it to the server for execution and displays the results, then prints another mysql> prompt to indicate that it is ready for another query.

mysql displays query output in tabular form (rows and columns). The first row contains labels for the columns. The rows following are the query results. Normally, column labels are the names of the columns you fetch from database tables. If you're retrieving the value of an expression rather than a table column (as in the example just shown), mysql labels the column using the expression itself.

mysql shows how many rows were returned and how long the query took to execute, which gives you a rough idea of server performance. These values are imprecise because they represent wall clock time (not CPU or machine time), and because they are affected by factors such as server load and network latency. (For brevity, the “rows in set” line is sometimes not shown in the remaining examples in this chapter.)

Keywords may be entered in any lettercase. The following queries are equivalent:

mysql> SELECT VERSION(), CURRENT_DATE;
mysql> select version(), current_date;
mysql> SeLeCt vErSiOn(), current_DATE;

Here is another query. It demonstrates that you can use mysql as a simple calculator:
SELECT SIN(PI()/4), 4+1*5;

The queries shown thus far have been relatively short, single-line statements. You can even enter multiple statements on a single line. Just end each one with a semicolon:
SELECT VERSION(); SELECT NOW();

A query need not be given all on a single line, so lengthy queries that require several lines are not a problem. mysql determines where your statement ends by looking for the terminating semicolon, not by looking for the end of the input line. (In other words, mysql accepts free-format input: it collects input lines but does not execute them until it sees the semicolon.)

Here is a simple multiple-line statement:
SELECT user()
,
current_time(),
current_time,
current_timestamp,
current_timestamp(),
current_date,
current_date(),
current_user(),
curtime(),
curdate()
curtime;

In this example, notice how the prompt changes from mysql> to -> after you enter the first line of a multiple-line query. This is how mysql indicates that it has not yet seen a complete statement and is waiting for the rest. The prompt is your friend, because it provides valuable feedback. If you use that feedback, you can always be aware of what mysql is waiting for.

If you decide you do not want to execute a query that you are in the process of entering, cancel it by typing \c:

Here, too, notice the prompt. It switches back to mysql> after you type \c, providing feedback to indicate that mysql is ready for a new query.

The following table shows each of the prompts you may see and summarizes what they mean about the state that mysql is in.

Prompt	Meaning
mysql>	Ready for new query
->	    Waiting for next line of multiple-line query
'>	    Waiting for next line, waiting for completion of a string that began with a single quote (')
">	    Waiting for next line, waiting for completion of a string that began with a double quote (")
`>	    Waiting for next line, waiting for completion of an identifier that began with a backtick (`)
/*>	    Waiting for next line, waiting for completion of a comment that began with /*

Multiple-line statements commonly occur by accident when you intend to issue a query on a single line, but forget the terminating semicolon. In this case, mysql waits for more input:


mysql> SELECT USER()
    ->

If this happens to you (you think you've entered a statement but the only response is a -> prompt), most likely mysql is waiting for the semicolon. If you don't notice what the prompt is telling you, you might sit there for a while before realizing what you need to do. Enter a semicolon to complete the statement, and mysql executes it:

mysql> SELECT USER()
    -> ;

The '> and "> prompts occur during string collection (another way of saying that MySQL is waiting for completion of a string). In MySQL, you can write strings surrounded by either ' or " characters (for example, 'hello' or "goodbye"), and mysql lets you enter strings that span multiple lines. When you see a '> or "> prompt, it means that you have entered a line containing a string that begins with a ' or " quote character, but have not yet entered the matching quote that terminates the string. This often indicates that you have inadvertently left out a quote character. For example:


mysql> SELECT * FROM my_table WHERE name = 'Smith AND age < 30;
    '>

If you enter this SELECT statement, then press Enter and wait for the result, nothing happens. Instead of wondering why this query takes so long, notice the clue provided by the '> prompt. It tells you that mysql expects to see the rest of an unterminated string. (Do you see the error in the statement? The string 'Smith is missing the second single quotation mark.)

At this point, what do you do? The simplest thing is to cancel the query. However, you cannot just type \c in this case, because mysql interprets it as part of the string that it is collecting. Instead, enter the closing quote character (so mysql knows you've finished the string), then type \c:

mysql> SELECT * FROM my_table WHERE name = 'Smith AND age < 30;
    '> '\c
mysql>
The prompt changes back to mysql>, indicating that mysql is ready for a new query.

The `> prompt is similar to the '> and "> prompts, but indicates that you have begun but not completed a backtick-quoted identifier.

It is important to know what the '>, ">, and `> prompts signify, because if you mistakenly enter an unterminated string, any further lines you type appear to be ignored by mysql—including a line containing QUIT. This can be quite confusing, especially if you do not know that you need to supply the terminating quote before you can cancel the current query.

Note
Multiline statements from this point on are written without the secondary (-> or other) prompts, to make it easier to copy and paste the statements to try for yourself.

3.3 Creating and Using a Database
---------------------------------
Once you know how to enter SQL statements, you are ready to access a database.

Suppose that you have several pets in your home (your menagerie) and you would like to keep track of various types of information about them. You can do so by creating tables to hold your data and loading them with the desired information. Then you can answer different sorts of questions about your animals by retrieving data from the tables. This section shows you how to perform the following operations:

Create a database

Create a table

Load data into the table

Retrieve data from the table in various ways

Use multiple tables

The menagerie database is simple (deliberately), but it is not difficult to think of real-world situations in which a similar type of database might be used. For example, a database like this could be used by a farmer to keep track of livestock, or by a veterinarian to keep track of patient records. A menagerie distribution containing some of the queries and sample data used in the following sections can be obtained from the MySQL website. It is available in both compressed tar file and Zip formats at https://dev.mysql.com/doc/.

Use the SHOW statement to find out what databases currently exist on the server:

show DATABASES;
# Database
'information_schema'
'mysql'
'performance_schema'
'sys'
'test'

To get list of all tables in a particular database/table_schema use:
SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA='TEST'; # For test DB
SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA='INFORMATION_SCHEMA'; # for information_schema db

To get list of all tables:
SELECT * FROM INFORMATION_SCHEMA.TABLES;

The mysql database describes user access privileges. The test database often is available as a workspace for users to try things out.

The list of databases displayed by the statement may be different on your machine; SHOW DATABASES does not show databases that you have no privileges for if you do not have the SHOW DATABASES privilege. See Section 13.7.7.14, “SHOW DATABASES Statement”.

If the test database exists, try to access it:

The mysql database describes user access privileges. The test database often is available as a workspace for users to try things out.

The list of databases displayed by the statement may be different on your machine; SHOW DATABASES does not show databases that you have no privileges for if you do not have the SHOW DATABASES privilege. See Section 13.7.7.14, “SHOW DATABASES Statement”.

If the test database exists, try to access it:

mysql> GRANT ALL ON menagerie.* TO 'your_mysql_name'@'your_client_host';
where your_mysql_name is the MySQL user name assigned to you and your_client_host is the host from which you connect to the server.


3.3.1 Creating and Selecting a Database

If the administrator creates your database for you when setting up your permissions, you can begin using it. Otherwise, you need to create it yourself:

CREATE DATABASE menagerie;

Under Unix, database names are case-sensitive (unlike SQL keywords), so you must always refer to your database as menagerie, not as Menagerie, MENAGERIE, or some other variant. This is also true for table names. (Under Windows, this restriction does not apply, although you must refer to databases and tables using the same lettercase throughout a given query. However, for a variety of reasons, the recommended best practice is always to use the same lettercase that was used when the database was created.)

Note
If you get an error such as ERROR 1044 (42000): Access denied for user 'micah'@'localhost' to database 'menagerie' when attempting to create a database, this means that your user account does not have the necessary privileges to do so.

Creating a database does not select it for use; you must do that explicitly. To make menagerie the current database, use this statement:

mysql> USE menagerie
Database changed

Your database needs to be created only once, but you must select it for use each time you begin a mysql session. You can do this by issuing a USE statement as shown in the example. Alternatively, you can select the database on the command line when you invoke mysql. Just specify its name after any connection parameters that you might need to provide. For example:

shell> mysql -h host -u user -p menagerie
Enter password: ********
Important
menagerie in the command just shown is not your password. If you want to supply your password on the command line after the -p option, you must do so with no intervening space (for example, as -ppassword, not as -p password). However, putting your password on the command line is not recommended, because doing so exposes it to snooping by other users logged in on your machine.

Note
You can see at any time which database is currently selected using SELECT DATABASE().
SELECT DATABASE(); # 'menagerie'

3.3.2 Creating a Table
----------------------
Creating the database is the easy part, but at this point it is empty, as SHOW TABLES tells you:

mysql> SHOW TABLES;
Empty set (0.00 sec)

SHOW TABLES;

The harder part is deciding what the structure of your database should be: what tables you need and what columns should be in each of them.

You want a table that contains a record for each of your pets. This can be called the pet table, and it should contain, as a bare minimum, each animal's name. Because the name by itself is not very interesting, the table should contain other information. For example, if more than one person in your family keeps pets, you might want to list each animal's owner. You might also want to record some basic descriptive information such as species and sex.

How about age? That might be of interest, but it is not a good thing to store in a database. Age changes as time passes, which means you'd have to update your records often. Instead, it is better to store a fixed value such as date of birth. Then, whenever you need age, you can calculate it as the difference between the current date and the birth date. MySQL provides functions for doing date arithmetic, so this is not difficult. Storing birth date rather than age has other advantages, too:

You can use the database for tasks such as generating reminders for upcoming pet birthdays. (If you think this type of query is somewhat silly, note that it is the same question you might ask in the context of a business database to identify clients to whom you need to send out birthday greetings in the current week or month, for that computer-assisted personal touch.)

You can calculate age in relation to dates other than the current date. For example, if you store death date in the database, you can easily calculate how old a pet was when it died.

You can probably think of other types of information that would be useful in the pet table, but the ones identified so far are sufficient: name, owner, species, sex, birth, and death.

Use a CREATE TABLE statement to specify the layout of your table:

CREATE TABLE pet (
    name VARCHAR(20),
    owner VARCHAR(20),
    species VARCHAR(20),
    sex ENUM('M', 'F'),
    birth DATE,
    death DATE
);

VARCHAR is a good choice for the name, owner, and species columns because the column values vary in length. The lengths in those column definitions need not all be the same, and need not be 20. You can normally pick any length from 1 to 65535, whatever seems most reasonable to you. If you make a poor choice and it turns out later that you need a longer field, MySQL provides an ALTER TABLE statement.

Several types of values can be chosen to represent sex in animal records, such as 'm' and 'f', or perhaps 'male' and 'female'. It is simplest to use the single characters 'm' and 'f'.

The use of the DATE data type for the birth and death columns is a fairly obvious choice.

Once you have created a table, SHOW TABLES should produce some output:

mysql> SHOW TABLES;
+---------------------+
| Tables in menagerie |
+---------------------+
| pet                 |
+---------------------+
To verify that your table was created the way you expected, use a DESCRIBE statement:

DESCRIBE pet;
# Field, Type, Null, Key, Default, Extra
'name', 'varchar(20)', 'YES', '', NULL, ''
'owner', 'varchar(20)', 'YES', '', NULL, ''
'species', 'varchar(20)', 'YES', '', NULL, ''
'sex', 'enum(\'M\',\'F\')', 'YES', '', NULL, ''
'birth', 'date', 'YES', '', NULL, ''
'death', 'date', 'YES', '', NULL, ''

3.3.3 Loading Data into a Table
After creating your table, you need to populate it. The LOAD DATA and INSERT statements are useful for this.

Suppose that your pet records can be described as shown here. (Observe that MySQL expects dates in 'YYYY-MM-DD' format; this may differ from what you are used to.)

Because you are beginning with an empty table, an easy way to populate it is to create a text file containing a row for each of your animals, then load the contents of the file into the table with a single statement.

You could create a text file pet.txt containing one record per line, with values separated by tabs, and given in the order in which the columns were listed in the CREATE TABLE statement. For missing values (such as unknown sexes or death dates for animals that are still living), you can use NULL values. To represent these in your text file, use \N (backslash, capital-N). For example, the record for Whistler the bird would look like this (where the whitespace between values is a single tab character):

To load a file:
start the mysql server as - (base) Utsavs-MacBook-Air:LaunchDaemons utsav$ mysql -u root -p --local-infile menagerie
mysql> SET GLOBAL local_infile = 1;
mysql> LOAD DATA LOCAL INFILE '/Users/utsav/Desktop/repos/SQLLearning/te.txt' INTO TABLE pet;

If you created the file on Windows with an editor that uses \r\n as a line terminator, you should use this statement instead:

mysql> LOAD DATA LOCAL INFILE '/path/pet.txt' INTO TABLE pet
       LINES TERMINATED BY '\r\n';

(On an Apple machine running macOS, you would likely want to use LINES TERMINATED BY '\r'.)

You can specify the column value separator and end of line marker explicitly in the LOAD DATA statement if you wish, but the defaults are tab and linefeed. These are sufficient for the statement to read the file pet.txt properly.

If the statement fails, it is likely that your MySQL installation does not have local file capability enabled by default. See Section 6.1.6, “Security Considerations for LOAD DATA LOCAL”(https://dev.mysql.com/doc/refman/8.0/en/load-data-local-security.html), for information on how to change this.

When you want to add new records one at a time, the INSERT statement is useful. In its simplest form, you supply values for each column, in the order in which the columns were listed in the CREATE TABLE statement. Suppose that Diane gets a new hamster named “Puffball.” You could add a new record using an INSERT statement like this:

String and date values are specified as quoted strings here. Also, with INSERT, you can insert NULL directly to represent a missing value. You do not use \N like you do with LOAD DATA.

From this example, you should be able to see that there would be a lot more typing involved to load your records initially using several INSERT statements rather than a single LOAD DATA statement.

Load a csv file -
mysql> LOAD DATA LOCAL INFILE '/Users/utsav/Desktop/repos/SQLLearning/te.csv' INTO TABLE test_csv_load fields terminated by ',';
Query OK, 8 rows affected (0.01 sec)
Records: 8  Deleted: 0  Skipped: 0  Warnings: 0

mysql> select * from test_csv_load;
+----------+--------+---------+------+------------+------------+
| name     | owner  | species | sex  | birth      | death      |
+----------+--------+---------+------+------------+------------+
| Fluffy   | Harold | cat     | F    | 1993-02-04 | NULL       |
| Claws    | Gwen   | cat     | M    | 1994-03-17 | NULL       |
| Buffy    | Harold | dog     | F    | 1989-05-13 | NULL       |
| Fang     | Benny  | dog     | M    | 1990-08-27 | NULL       |
| Bowser   | Diane  | dog     | M    | 1979-08-31 | 1995-07-29 |
| Chirpy   | Gwen   | bird    | F    | 1998-09-11 | NULL       |
| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |
| Slim     | Benny  | snake   | M    | 1996-04-29 | NULL       |
+----------+--------+---------+------+------------+------------+
8 rows in set (0.00 sec)

3.3.4 Retrieving Information from a Table
------------------------------------------
The SELECT statement is used to pull information from a table. The general form of the statement is:

SELECT what_to_select
FROM which_table
WHERE conditions_to_satisfy;
what_to_select indicates what you want to see. This can be a list of columns, or * to indicate “all columns.” which_table indicates the table from which you want to retrieve data. The WHERE clause is optional. If it is present, conditions_to_satisfy specifies one or more conditions that rows must satisfy to qualify for retrieval.

3.3.4.1 Selecting All Data

The simplest form of SELECT retrieves everything from a table:
SELECT * FROM pet;

This form of SELECT uses *, which is shorthand for “select all columns.” This is useful if you want to review your entire table, for example, after you've just loaded it with your initial data set. For example, you may happen to think that the birth date for Bowser doesn't seem quite right. Consulting your original pedigree papers, you find that the correct birth year should be 1989, not 1979.

There are at least two ways to fix this:

Edit the file pet.txt to correct the error, then empty the table and reload it using DELETE and LOAD DATA:

mysql> select * from pet;                                                                                            +----------+--------+---------+------+------------+------------+
| name     | owner  | species | sex  | birth      | death      |
+----------+--------+---------+------+------------+------------+
| Fluffy   | Harold | cat     | F    | 1993-02-04 | NULL       |
| Claws    | Gwen   | cat     | M    | 1994-03-17 | NULL       |
| Buffy    | Harold | dog     | F    | 1989-05-13 | NULL       |
| Fang     | Benny  | dog     | M    | 1990-08-27 | NULL       |
| Bowser   | Diane  | dog     | M    | 1989-08-31 | 1995-07-29 |
| Chirpy   | Gwen   | bird    | F    | 1998-09-11 | NULL       |
| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |
| Slim     | Benny  | snake   | M    | 1996-04-29 | NULL       |
+----------+--------+---------+------+------------+------------+

mysql> DELETE FROM pet;
mysql> LOAD DATA LOCAL INFILE 'pet.txt' INTO TABLE pet;
However, if you do this, you must also re-enter the record for Puffball.

Fix only the erroneous record with an UPDATE statement:

mysql> UPDATE pet SET birth = '1989-08-31' WHERE name = 'Bowser';
The UPDATE changes only the record in question and does not require you to reload the table.

There is an exception to the principle that SELECT * selects all columns. If a table contains invisible columns, * does not include them. For more information, see Section 13.1.20.10, “Invisible Columns”.

3.3.4.2 Selecting Particular Rows

As shown in the preceding section, it is easy to retrieve an entire table. Just omit the WHERE clause from the SELECT statement. But typically you don't want to see the entire table, particularly when it becomes large. Instead, you're usually more interested in answering a particular question, in which case you specify some constraints on the information you want. Let's look at some selection queries in terms of questions about your pets that they answer.

You can select only particular rows from your table. For example, if you want to verify the change that you made to Bowser's birth date, select Bowser's record like this:

mysql> SELECT * FROM pet WHERE name = 'Bowser';
+--------+-------+---------+------+------------+------------+
| name   | owner | species | sex  | birth      | death      |
+--------+-------+---------+------+------------+------------+
| Bowser | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+-------+---------+------+------------+------------+
The output confirms that the year is correctly recorded as 1989, not 1979.

String comparisons normally are case-insensitive, so you can specify the name as 'bowser', 'BOWSER', and so forth. The query result is the same.

You can specify conditions on any column, not just name. For example, if you want to know which animals were born during or after 1998, test the birth column:

mysql> SELECT * FROM pet WHERE birth >= '1998-1-1';
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Puffball | Diane | hamster | f    | 1999-03-30 | NULL  |
+----------+-------+---------+------+------------+-------+
You can combine conditions, for example, to locate female dogs:

mysql> SELECT * FROM pet WHERE species = 'dog' AND sex = 'f';
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
The preceding query uses the AND logical operator. There is also an OR operator:

mysql> SELECT * FROM pet WHERE species = 'snake' OR species = 'bird';
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL  |
| Slim     | Benny | snake   | m    | 1996-04-29 | NULL  |
+----------+-------+---------+------+------------+-------+
AND and OR may be intermixed, although AND has higher precedence than OR. If you use both operators, it is a good idea to use parentheses to indicate explicitly how conditions should be grouped:

mysql> SELECT * FROM pet WHERE (species = 'cat' AND sex = 'm')
       OR (species = 'dog' AND sex = 'f');
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+

3.3.4.3 Selecting Particular Columns
------------------------------------
If you do not want to see entire rows from your table, just name the columns in which you are interested, separated by commas. For example, if you want to know when your animals were born, select the name and birth columns:

mysql> SELECT name, birth FROM pet;
+----------+------------+
| name     | birth      |
+----------+------------+
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Buffy    | 1989-05-13 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Puffball | 1999-03-30 |
+----------+------------+
To find out who owns pets, use this query:

mysql> SELECT owner FROM pet;
+--------+
| owner  |
+--------+
| Harold |
| Gwen   |
| Harold |
| Benny  |
| Diane  |
| Gwen   |
| Gwen   |
| Benny  |
| Diane  |
+--------+
Notice that the query simply retrieves the owner column from each record, and some of them appear more than once. To minimize the output, retrieve each unique output record just once by adding the keyword DISTINCT:

mysql> SELECT DISTINCT owner FROM pet;
+--------+
| owner  |
+--------+
| Benny  |
| Diane  |
| Gwen   |
| Harold |
+--------+
You can use a WHERE clause to combine row selection with column selection. For example, to get birth dates for dogs and cats only, use this query:

mysql> SELECT name, species, birth FROM pet
       WHERE species = 'dog' OR species = 'cat';
+--------+---------+------------+
| name   | species | birth      |
+--------+---------+------------+
| Fluffy | cat     | 1993-02-04 |
| Claws  | cat     | 1994-03-17 |
| Buffy  | dog     | 1989-05-13 |
| Fang   | dog     | 1990-08-27 |
| Bowser | dog     | 1989-08-31 |
+--------+---------+------------+

3.3.4.4 Sorting Rows

You may have noticed in the preceding examples that the result rows are displayed in no particular order. It is often easier to examine query output when the rows are sorted in some meaningful way. To sort a result, use an ORDER BY clause.

Here are animal birthdays, sorted by date:

mysql> SELECT name, birth FROM pet ORDER BY birth;
+----------+------------+
| name     | birth      |
+----------+------------+
| Buffy    | 1989-05-13 |
| Bowser   | 1989-08-31 |
| Fang     | 1990-08-27 |
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Slim     | 1996-04-29 |
| Whistler | 1997-12-09 |
| Chirpy   | 1998-09-11 |
| Puffball | 1999-03-30 |
+----------+------------+
On character type columns, sorting—like all other comparison operations—is normally performed in a case-insensitive fashion. This means that the order is undefined for columns that are identical except for their case. You can force a case-sensitive sort for a column by using BINARY like so: ORDER BY BINARY col_name.

mysql> select * from pet order by BINARY name;
+----------+--------+---------+------+------------+------------+
| name     | owner  | species | sex  | birth      | death      |
+----------+--------+---------+------+------------+------------+
| Bowser   | Diane  | dog     | M    | 1989-08-31 | 1995-07-29 |
| Buffy    | Harold | dog     | F    | 1989-05-13 | NULL       |
| Chirpy   | Gwen   | bird    | F    | 1998-09-11 | NULL       |
| Claws    | Gwen   | cat     | M    | 1994-03-17 | NULL       |
| Fang     | Benny  | dog     | M    | 1990-08-27 | NULL       |
| Fluffy   | Harold | cat     | F    | 1993-02-04 | NULL       |
| Slim     | Benny  | snake   | M    | 1996-04-29 | NULL       |
| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |
| bruzo    | Chinku | dog     | M    | 2019-01-04 | NULL       |
+----------+--------+---------+------+------------+------------+
9 rows in set (0.00 sec)

You can sort on multiple columns, and you can sort different columns in different directions. For example, to sort by type of animal in ascending order, then by birth date within animal type in descending order (youngest animals first), use the following query:

mysql> select name, species, birth from pet
    -> order by species, birth desc;
+----------+---------+------------+
| name     | species | birth      |
+----------+---------+------------+
| Chirpy   | bird    | 1998-09-11 |
| Whistler | bird    | 1997-12-09 |
| Claws    | cat     | 1994-03-17 |
| Fluffy   | cat     | 1993-02-04 |
| bruzo    | dog     | 2019-01-04 |
| Fang     | dog     | 1990-08-27 |
| Bowser   | dog     | 1989-08-31 |
| Buffy    | dog     | 1989-05-13 |
| Slim     | snake   | 1996-04-29 |
+----------+---------+------------+

NOTE - The DESC keyword applies only to the column name immediately preceding it (birth); it does not affect the species column sort order.

If we need both species and birth in descending order, then desc with each col
mysql> select name, species, birth from pet  order by species desc, birth desc;
+----------+---------+------------+
| name     | species | birth      |
+----------+---------+------------+
| Slim     | snake   | 1996-04-29 |
| bruzo    | dog     | 2019-01-04 |
| Fang     | dog     | 1990-08-27 |
| Bowser   | dog     | 1989-08-31 |
| Buffy    | dog     | 1989-05-13 |
| Claws    | cat     | 1994-03-17 |
| Fluffy   | cat     | 1993-02-04 |
| Chirpy   | bird    | 1998-09-11 |
| Whistler | bird    | 1997-12-09 |
+----------+---------+------------+
9 rows in set (0.00 sec)


mysql> describe pet;
+---------+---------------+------+-----+---------+-------+
| Field   | Type          | Null | Key | Default | Extra |
+---------+---------------+------+-----+---------+-------+
| name    | varchar(20)   | YES  |     | NULL    |       |
| owner   | varchar(20)   | YES  |     | NULL    |       |
| species | varchar(20)   | YES  |     | NULL    |       |
| sex     | enum('M','F') | YES  |     | NULL    |       |
| birth   | date          | YES  |     | NULL    |       |
| death   | date          | YES  |     | NULL    |       |
+---------+---------------+------+-----+---------+-------+
6 rows in set (0.01 sec)

NOTE - describe is equivalent to meta in kdb

3.3.4.5 Date Calculations
-------------------------

MySQL provides several functions that you can use to perform calculations on dates, for example, to calculate ages or extract parts of dates.

To determine how many years old each of your pets is, use the TIMESTAMPDIFF() function. Its arguments are the unit in which you want the result expressed, and the two dates for which to take the difference. The following query shows, for each pet, the birth date, the current date, and the age in years. An alias (age) is used to make the final output column label more meaningful.

mysql> select name, birth, curdate(), timestampdiff(YEAR,birth,curdate()) as age from pet order by age desc;
+----------+------------+------------+------+
| name     | birth      | curdate()  | age  |
+----------+------------+------------+------+
| Buffy    | 1989-05-13 | 2021-07-05 |   32 |
| Bowser   | 1989-08-31 | 2021-07-05 |   31 |
| Fang     | 1990-08-27 | 2021-07-05 |   30 |
| Fluffy   | 1993-02-04 | 2021-07-05 |   28 |
| Claws    | 1994-03-17 | 2021-07-05 |   27 |
| Slim     | 1996-04-29 | 2021-07-05 |   25 |
| Whistler | 1997-12-09 | 2021-07-05 |   23 |
| Chirpy   | 1998-09-11 | 2021-07-05 |   22 |
| bruzo    | 2019-01-04 | 2021-07-05 |    2 |
+----------+------------+------------+------+
9 rows in set (0.00 sec)

A similar query can be used to determine age at death for animals that have died. You determine which animals these are by checking whether the death value is NULL. Then, for those with non-NULL values, compute the difference between the death and birth values:
mysql> select name, birth, death, timestampdiff(YEAR, birth, death) as age from pet where death IS NOT NULL order by name;
+--------+------------+------------+------+
| name   | birth      | death      | age  |
+--------+------------+------------+------+
| Bowser | 1989-08-31 | 1995-07-29 |    5 |
+--------+------------+------------+------+

Similarly if we want age of species which are alive.
mysql> select name, birth, death, timestampdiff(YEAR, birth, curdate()) as age from pet where death IS NULL order by name;
+----------+------------+-------+------+
| name     | birth      | death | age  |
+----------+------------+-------+------+
| bruzo    | 2019-01-04 | NULL  |    2 |
| Buffy    | 1989-05-13 | NULL  |   32 |
| Chirpy   | 1998-09-11 | NULL  |   22 |
| Claws    | 1994-03-17 | NULL  |   27 |
| Fang     | 1990-08-27 | NULL  |   30 |
| Fluffy   | 1993-02-04 | NULL  |   28 |
| Slim     | 1996-04-29 | NULL  |   25 |
| Whistler | 1997-12-09 | NULL  |   23 |
+----------+------------+-------+------+

The query uses death IS NOT NULL rather than death <> NULL because NULL is a special value that cannot be compared using the usual comparison operators. This is discussed later. See Section 3.3.4.6, “Working with NULL Values”.

What if you want to know which animals have birthdays next month? For this type of calculation, year and day are irrelevant; you simply want to extract the month part of the birth column. MySQL provides several functions for extracting parts of dates, such as YEAR(), MONTH(), and DAYOFMONTH(). MONTH() is the appropriate function here. To see how it works, run a simple query that displays the value of both birth and MONTH(birth):

Get complete birth details
mysql> select birth, year(birth), month(birth), dayofmonth(birth), weekday(birth), dayname(birth) from pet;
+------------+-------------+--------------+-------------------+----------------+----------------+
| birth      | year(birth) | month(birth) | dayofmonth(birth) | weekday(birth) | dayname(birth) |
+------------+-------------+--------------+-------------------+----------------+----------------+
| 1993-02-04 |        1993 |            2 |                 4 |              3 | Thursday       |
| 1994-03-17 |        1994 |            3 |                17 |              3 | Thursday       |
| 1989-05-13 |        1989 |            5 |                13 |              5 | Saturday       |
| 1990-08-27 |        1990 |            8 |                27 |              0 | Monday         |
| 1989-08-31 |        1989 |            8 |                31 |              3 | Thursday       |
| 1998-09-11 |        1998 |            9 |                11 |              4 | Friday         |
| 1997-12-09 |        1997 |           12 |                 9 |              1 | Tuesday        |
| 1996-04-29 |        1996 |            4 |                29 |              0 | Monday         |
| 2019-01-04 |        2019 |            1 |                 4 |              4 | Friday         |
+------------+-------------+--------------+-------------------+----------------+----------------+

Get the pets whose birthday is in coming month.
mysql> select name, birth, species from pet where month(birth)=(month(curdate())+1);
+--------+------------+---------+
| name   | birth      | species |
+--------+------------+---------+
| Fang   | 1990-08-27 | dog     |
| Bowser | 1989-08-31 | dog     |
+--------+------------+---------+

Other then using curdate()+1, you can use DATE_ADD()
First let's see few examples of DATE_ADD()
mysql> select DATE_ADD(curdate(),INTERVAL 1 MONTH);
+--------------------------------------+
| DATE_ADD(curdate(),INTERVAL 1 MONTH) |
+--------------------------------------+
| 2021-08-05                           |
+--------------------------------------+
1 row in set (0.00 sec)

mysql> select DATE_ADD(curdate(),INTERVAL 1 DAY);
+------------------------------------+
| DATE_ADD(curdate(),INTERVAL 1 DAY) |
+------------------------------------+
| 2021-07-06                         |
+------------------------------------+
1 row in set (0.00 sec)

mysql> select DATE_ADD(curdate(),INTERVAL 1 YEAR);
+-------------------------------------+
| DATE_ADD(curdate(),INTERVAL 1 YEAR) |
+-------------------------------------+
| 2022-07-05                          |
+-------------------------------------+
1 row in set (0.00 sec)

Query - mysql> select name, birth, species from pet where month(birth)=(month(DATE_ADD(curdate(),INTERVAL 1 MONTH)));
        +--------+------------+---------+
        | name   | birth      | species |
        +--------+------------+---------+
        | Fang   | 1990-08-27 | dog     |
        | Bowser | 1989-08-31 | dog     |
        +--------+------------+---------+



But the above code will fail if the current month is december, for that we can use:
mysql> select name, birth, species from pet where month(birth)=(month(DATE_ADD('2020-12-01',INTERVAL 1 MONTH)));
+-------+------------+---------+
| name  | birth      | species |
+-------+------------+---------+
| bruzo | 2019-01-04 | dog     |
+-------+------------+---------+

You can write the query so that it works no matter what the current month is, so that you do not have to use the number for a particular month. DATE_ADD() enables you to add a time interval to a given date. If you add a month to the value of CURDATE(), then extract the month part with MONTH(), the result produces the month in which to look for birthdays:

mysql> SELECT name, birth FROM pet
       WHERE MONTH(birth) = MONTH(DATE_ADD(CURDATE(),INTERVAL 1 MONTH));

A different way to accomplish the same task is to add 1 to get the next month after the current one after using the modulo function (MOD) to wrap the month value to 0 if it is currently 12:


mysql> select name, birth, species from pet where month(birth)=MOD(MONTH(CURDATE()), 12)+1;
+--------+------------+---------+
| name   | birth      | species |
+--------+------------+---------+
| Fang   | 1990-08-27 | dog     |
| Bowser | 1989-08-31 | dog     |
+--------+------------+---------+
2 rows in set (0.00 sec)

mysql> select name, birth, species from pet where month(birth)=MOD(MONTH('2020-12-01'), 12)+1;
+-------+------------+---------+
| name  | birth      | species |
+-------+------------+---------+
| bruzo | 2019-01-04 | dog     |
+-------+------------+---------+
1 row in set (0.00 sec)

MONTH() returns a number between 1 and 12. And MOD(something,12) returns a number between 0 and 11. So the addition has to be after the MOD(), otherwise we would go from November (11) to January (1).

If a calculation uses invalid dates, the calculation fails and produces warnings:
mysql> select '2021-06-04' + 1;
+------------------+
| '2021-06-04' + 1 |
+------------------+
|             2022 |
+------------------+
1 row in set, 1 warning (0.00 sec)

mysql> select '2021-06-04' + INTERVAL 1 DAY;
+-------------------------------+
| '2021-06-04' + INTERVAL 1 DAY |
+-------------------------------+
| 2021-06-05                    |
+-------------------------------+
1 row in set (0.00 sec)

mysql> select '2021-06-32' + INTERVAL 1 DAY;
+-------------------------------+
| '2021-06-32' + INTERVAL 1 DAY |
+-------------------------------+
| NULL                          |
+-------------------------------+
1 row in set, 1 warning (0.00 sec)

mysql> show warnings;
+---------+------+----------------------------------------+
| Level   | Code | Message                                |
+---------+------+----------------------------------------+
| Warning | 1292 | Incorrect datetime value: '2021-06-32' |
+---------+------+----------------------------------------+
1 row in set (0.00 sec)

3.3.4.6 Working with NULL Values
--------------------------------
The NULL value can be surprising until you get used to it. Conceptually, NULL means “a missing unknown value” and it is treated somewhat differently from other values.

To test for NULL, use the IS NULL and IS NOT NULL operators, as shown here:

mysql> SELECT 2 IS NULL, 2 IS NOT NULL;
+-----------+---------------+
| 2 IS NULL | 2 IS NOT NULL |
+-----------+---------------+
|         0 |             1 |
+-----------+---------------+

You cannot use arithmetic comparison operators such as =, <, or <> to test for NULL. To demonstrate this for yourself, try the following query:
mysql> select 1=NULL, 1<>NULL, 1<NULL, 1>NULL;
+--------+---------+--------+--------+
| 1=NULL | 1<>NULL | 1<NULL | 1>NULL |
+--------+---------+--------+--------+
|   NULL |    NULL |   NULL |   NULL |
+--------+---------+--------+--------+

Because the result of any arithmetic comparison with NULL is also NULL, you cannot obtain any meaningful results from such comparisons.

In MySQL, 0 or NULL means false and anything else means true. The default truth value from a boolean operation is 1.

This special treatment of NULL is why, in the previous section, it was necessary to determine which animals are no longer alive using death IS NOT NULL instead of death <> NULL.

Two NULL values are regarded as equal in a GROUP BY.

When doing an ORDER BY, NULL values are presented first if you do ORDER BY ... ASC and last if you do ORDER BY ... DESC.

mysql> SELECT 2 OR NULL;
+-----------+
| 2 OR NULL |
+-----------+
|         1 |
+-----------+
1 row in set (0.00 sec)

mysql> SELECT 0 OR NULL;
+-----------+
| 0 OR NULL |
+-----------+
|      NULL |
+-----------+
1 row in set (0.00 sec)

mysql> select 2 AND NULL;
+------------+
| 2 AND NULL |
+------------+
|       NULL |
+------------+
1 row in set (0.01 sec)

A common error when working with NULL is to assume that it is not possible to insert a zero or an empty string into a column defined as NOT NULL, but this is not the case. These are in fact values, whereas NULL means “not having a value.” You can test this easily enough by using IS [NOT] NULL as shown:
mysql> SELECT 0 IS NULL, 0 IS NOT NULL, '' IS NULL, '' IS NOT NULL;
+-----------+---------------+------------+----------------+
| 0 IS NULL | 0 IS NOT NULL | '' IS NULL | '' IS NOT NULL |
+-----------+---------------+------------+----------------+
|         0 |             1 |          0 |              1 |
+-----------+---------------+------------+----------------+

B.3.4.3 Problems with NULL Values
---------------------------------
The concept of the NULL value is a common source of confusion for newcomers to SQL, who often think that NULL is the same thing as an empty string ''. This is not the case. For example, the following statements are completely different:

mysql> INSERT INTO my_table (phone) VALUES (NULL);
mysql> INSERT INTO my_table (phone) VALUES ('');
Both statements insert a value into the phone column, but the first inserts a NULL value and the second inserts an empty string. The meaning of the first can be regarded as “phone number is not known” and the meaning of the second can be regarded as “the person is known to have no phone, and thus no phone number.”

In SQL, the NULL value is never true in comparison to any other value, even NULL. An expression that contains NULL always produces a NULL value unless otherwise indicated in the documentation for the operators and functions involved in the expression. All columns in the following example return NULL:
mysql> SELECT NULL, 1+NULL, CONCAT('Invisible', NULL);
+------+--------+---------------------------+
| NULL | 1+NULL | CONCAT('Invisible', NULL) |
+------+--------+---------------------------+
| NULL |   NULL | NULL                      |
+------+--------+---------------------------+

To search for column values that are NULL, you cannot use an expr = NULL test. The following statement returns no rows, because expr = NULL is never true for any expression:
SELECT * FROM my_table WHERE phone = NULL;

To look for NULL values, you must use the IS NULL test. The following statements show how to find the NULL phone number and the empty phone number:

mysql> SELECT * FROM my_table WHERE phone IS NULL;
mysql> SELECT * FROM my_table WHERE phone = '';

You can add an index on a column that can have NULL values if you are using the MyISAM, InnoDB, or MEMORY storage engine. Otherwise, you must declare an indexed column NOT NULL, and you cannot insert NULL into the column.

When reading data with LOAD DATA, empty or missing columns are updated with ''. To load a NULL value into a column, use \N in the data file. The literal word NULL may also be used under some circumstances.

When using DISTINCT, GROUP BY, or ORDER BY, all NULL values are regarded as equal.

When using ORDER BY, NULL values are presented first, or last if you specify DESC to sort in descending order.

Aggregate (group) functions such as COUNT(), MIN(), and SUM() ignore NULL values. The exception to this is COUNT(*), which counts rows and not individual column values. For example, the following statement produces two counts. The first is a count of the number of rows in the table, and the second is a count of the number of non-NULL values in the age column:
mysql> SELECT COUNT(*), COUNT(SEX) FROM pet;
+----------+------------+
| COUNT(*) | COUNT(SEX) |
+----------+------------+
|        9 |          8 |
+----------+------------+
For some data types, MySQL handles NULL values specially. If you insert NULL into a TIMESTAMP column, the current date and time is inserted. If you insert NULL into an integer or floating-point column that has the AUTO_INCREMENT attribute, the next number in the sequence is inserted.

3.3.4.7 Pattern Matching
========================
MySQL provides standard SQL pattern matching as well as a form of pattern matching based on extended regular expressions similar to those used by Unix utilities such as vi, grep, and sed.

SQL pattern matching enables you to use _ to match any single character and % to match an arbitrary number of characters (including zero characters). In MySQL, SQL patterns are case-insensitive by default. Some examples are shown here. Do not use = or <> when you use SQL patterns. Use the LIKE or NOT LIKE comparison operators instead.

To find names beginning with b:
mysql> SELECT * FROM pet WHERE name LIKE 'B%';
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | F    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | M    | 1989-08-31 | 1995-07-29 |
| bruzo  | Chinku | dog     | M    | 2019-01-04 | NULL       |
+--------+--------+---------+------+------------+------------+
3 rows in set (0.01 sec)

mysql> SELECT * FROM pet WHERE name LIKE BINARY 'B%';
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | F    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | M    | 1989-08-31 | 1995-07-29 |
+--------+--------+---------+------+------------+------------+
2 rows in set (0.00 sec)

To find names ending with fy:
mysql> SELECT * FROM pet WHERE name LIKE '%FY';
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | F    | 1993-02-04 | NULL  |
| Buffy  | Harold | dog     | F    | 1989-05-13 | NULL  |
+--------+--------+---------+------+------------+-------+
2 rows in set (0.00 sec)

To find names containing a w:
mysql> SELECT * FROM pet WHERE name LIKE '%w%';
+----------+-------+---------+------+------------+------------+
| name     | owner | species | sex  | birth      | death      |
+----------+-------+---------+------+------------+------------+
| Claws    | Gwen  | cat     | M    | 1994-03-17 | NULL       |
| Bowser   | Diane | dog     | M    | 1989-08-31 | 1995-07-29 |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL       |
+----------+-------+---------+------+------------+------------+
3 rows in set (0.00 sec)

To find names containing exactly five characters, use five instances of the _ pattern character:
mysql> SELECT * FROM pet WHERE name LIKE '_____';
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | M    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | F    | 1989-05-13 | NULL  |
| bruzo | Chinku | dog     | M    | 2019-01-04 | NULL  |
+-------+--------+---------+------+------------+-------+
3 rows in set (0.00 sec)

The other type of pattern matching provided by MySQL uses extended regular expressions. When you test for a match for this type of pattern, use the REGEXP_LIKE() function (or the REGEXP or RLIKE operators, which are synonyms for REGEXP_LIKE()).

The following list describes some characteristics of extended regular expressions:

. matches any single character.

A character class [...] matches any character within the brackets. For example, [abc] matches a, b, or c. To name a range of characters, use a dash. [a-z] matches any letter, whereas [0-9] matches any digit.

* matches zero or more instances of the thing preceding it. For example, x* matches any number of x characters, [0-9]* matches any number of digits, and .* matches any number of anything.

A regular expression pattern match succeeds if the pattern matches anywhere in the value being tested. (This differs from a LIKE pattern match, which succeeds only if the pattern matches the entire value.)

To anchor a pattern so that it must match the beginning or end of the value being tested, use ^ at the beginning or $ at the end of the pattern.

To demonstrate how extended regular expressions work, the LIKE queries shown previously are rewritten here to use REGEXP_LIKE().

To find names beginning with b, use ^ to match the beginning of the name:

mysql> select * from pet where REGEXP_LIKE(name, '^b' COLLATE utf8mb4_0900_as_cs);
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| bruzo | Chinku | dog     | M    | 2019-01-04 | NULL  |
+-------+--------+---------+------+------------+-------+

mysql> select * from pet where REGEXP_LIKE(name, BINARY '^b');
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| bruzo | Chinku | dog     | M    | 2019-01-04 | NULL  |
+-------+--------+---------+------+------------+-------+

mysql> select * from pet where REGEXP_LIKE(name, '^b');
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | F    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | M    | 1989-08-31 | 1995-07-29 |
| bruzo  | Chinku | dog     | M    | 2019-01-04 | NULL       |
+--------+--------+---------+------+------------+------------+

mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, '^b', 'c');
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| bruzo | Chinku | dog     | M    | 2019-01-04 | NULL  |
+-------+--------+---------+------+------------+-------+
1 row in set (0.00 sec)

To find names ending with fy, use $ to match the end of the name:
mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, 'fy$');
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | F    | 1993-02-04 | NULL  |
| Buffy  | Harold | dog     | F    | 1989-05-13 | NULL  |
+--------+--------+---------+------+------------+-------+

To find names containing a w, use this query:
mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, 'w');
+----------+-------+---------+------+------------+------------+
| name     | owner | species | sex  | birth      | death      |
+----------+-------+---------+------+------------+------------+
| Claws    | Gwen  | cat     | M    | 1994-03-17 | NULL       |
| Bowser   | Diane | dog     | M    | 1989-08-31 | 1995-07-29 |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL       |
+----------+-------+---------+------+------------+------------+

mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, BINARY 'w');
+--------+-------+---------+------+------------+------------+
| name   | owner | species | sex  | birth      | death      |
+--------+-------+---------+------+------------+------------+
| Claws  | Gwen  | cat     | M    | 1994-03-17 | NULL       |
| Bowser | Diane | dog     | M    | 1989-08-31 | 1995-07-29 |
+--------+-------+---------+------+------------+------------+
2 rows in set (0.00 sec)

mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, 'w', 'c');
+--------+-------+---------+------+------------+------------+
| name   | owner | species | sex  | birth      | death      |
+--------+-------+---------+------+------------+------------+
| Claws  | Gwen  | cat     | M    | 1994-03-17 | NULL       |
| Bowser | Diane | dog     | M    | 1989-08-31 | 1995-07-29 |
+--------+-------+---------+------+------------+------------+
2 rows in set (0.00 sec)

Because a regular expression pattern matches if it occurs anywhere in the value, it is not necessary in the previous query to put a wildcard on either side of the pattern to get it to match the entire value as would be true with an SQL pattern.

To find names containing exactly five characters, use ^ and $ to match the beginning and end of the name, and five instances of . in between:
mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, '^.....$');
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | M    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | F    | 1989-05-13 | NULL  |
| bruzo | Chinku | dog     | M    | 2019-01-04 | NULL  |
+-------+--------+---------+------+------------+-------+

You could also write the previous query using the {n} (“repeat-n-times”) operator:
mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, '^.{5}$');
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | M    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | F    | 1989-05-13 | NULL  |
| bruzo | Chinku | dog     | M    | 2019-01-04 | NULL  |
+-------+--------+---------+------+------------+-------+

mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, '^.{4,6}$');
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Fluffy | Harold | cat     | F    | 1993-02-04 | NULL       |
| Claws  | Gwen   | cat     | M    | 1994-03-17 | NULL       |
| Buffy  | Harold | dog     | F    | 1989-05-13 | NULL       |
| Fang   | Benny  | dog     | M    | 1990-08-27 | NULL       |
| Bowser | Diane  | dog     | M    | 1989-08-31 | 1995-07-29 |
| Chirpy | Gwen   | bird    | F    | 1998-09-11 | NULL       |
| Slim   | Benny  | snake   | M    | 1996-04-29 | NULL       |
| bruzo  | Chinku | dog     | M    | 2019-01-04 | NULL       |
+--------+--------+---------+------+------------+------------+

12.8.2 Regular Expressions
---------------------------
Table 12.14 Regular Expression Functions and Operators

Name	            Description
NOT REGEXP	        Negation of REGEXP
REGEXP	            Whether string matches regular expression
REGEXP_INSTR()	    Starting index of substring matching regular expression
REGEXP_LIKE()	    Whether string matches regular expression
REGEXP_REPLACE()	Replace substrings matching regular expression
REGEXP_SUBSTR()	    Return substring matching regular expression
RLIKE	            Whether string matches regular expression

A regular expression is a powerful way of specifying a pattern for a complex search. This section discusses the functions and operators available for regular expression matching and illustrates, with examples, some of the special characters and constructs that can be used for regular expression operations

MySQL implements regular expression support using International Components for Unicode (ICU), which provides full Unicode support and is multibyte safe.

Regular Expression Function and Operator Descriptions
======================================================
expr NOT REGEXP pat, expr NOT RLIKE pat
This is the same as NOT (expr REGEXP pat).
expr REGEXP pat, expr RLIKE pat
Returns 1 if the string expr matches the regular expression specified by the pattern pat, 0 otherwise. If expr or pat is NULL, the return value is NULL.
REGEXP and RLIKE are synonyms for REGEXP_LIKE().
For additional information about how matching occurs, see the description for REGEXP_LIKE().

mysql> SELECT 'Michael!' REGEXP '.*';
+------------------------+
| 'Michael!' REGEXP '.*' |
+------------------------+
|                      1 |
+------------------------+
1 row in set (0.00 sec)

mysql> SELECT 'Michael!' RLIKE '.*';
+-----------------------+
| 'Michael!' RLIKE '.*' |
+-----------------------+
|                     1 |
+-----------------------+
1 row in set (0.02 sec)

mysql> select 'new*\n*line' REGEXP '.*';
+---------------------------+
| 'new*\n*line' REGEXP '.*' |
+---------------------------+
|                         1 |
+---------------------------+
1 row in set (0.00 sec)

mysql> select 'new*\n*line' REGEXP 'new\\*.\\*line';
+---------------------------------------+
| 'new*\n*line' REGEXP 'new\\*.\\*line' |
+---------------------------------------+
|                                     0 |
+---------------------------------------+
1 row in set (0.01 sec)

mysql> select 'a' regexp '^[a-d]';
+---------------------+
| 'a' regexp '^[a-d]' |
+---------------------+
|                   1 |
+---------------------+
1 row in set (0.00 sec)

mysql> select 'a' regexp 'A', 'a' regexp binary 'A';
+----------------+-----------------------+
| 'a' regexp 'A' | 'a' regexp binary 'A' |
+----------------+-----------------------+
|              1 |                     0 |
+----------------+-----------------------+

REGEXP_INSTR(expr, pat[, pos[, occurrence[, return_option[, match_type]]]])
-----------------------------------------------------------------------------
Returns the starting index of the substring of the string expr that matches the regular expression specified by the pattern pat, 0 if there is no match. If expr or pat is NULL, the return value is NULL. Character indexes begin at 1.

REGEXP_INSTR() takes these optional arguments:

pos: The position in expr at which to start the search. If omitted, the default is 1.

occurrence: Which occurrence of a match to search for. If omitted, the default is 1.

return_option: Which type of position to return. If this value is 0, REGEXP_INSTR() returns the position of the matched substring's first character. If this value is 1, REGEXP_INSTR() returns the position following the matched substring. If omitted, the default is 0.

match_type: A string that specifies how to perform matching. The meaning is as described for REGEXP_LIKE().

For additional information about how matching occurs, see the description for REGEXP_LIKE().

mysql> select REGEXP_INSTR('dog cat dog', 'dog');
+------------------------------------+
| REGEXP_INSTR('dog cat dog', 'dog') |
+------------------------------------+
|                                  1 |
+------------------------------------+
1 row in set (0.01 sec)

mysql> select REGEXP_INSTR('dog cat dog', 'cat');
+------------------------------------+
| REGEXP_INSTR('dog cat dog', 'cat') |
+------------------------------------+
|                                  5 |
+------------------------------------+
1 row in set (0.00 sec)

mysql> select REGEXP_INSTR('dog cat dog', 'dog', 2);
+---------------------------------------+
| REGEXP_INSTR('dog cat dog', 'dog', 2) |
+---------------------------------------+
|                                     9 |
+---------------------------------------+

mysql> select REGEXP_INSTR('dogdog cat dog', 'dog', 2);                                                                         +------------------------------------------+
| REGEXP_INSTR('dogdog cat dog', 'dog', 2) |
+------------------------------------------+
|                                        4 |
+------------------------------------------+


mysql> select REGEXP_INSTR('AA AAA AAA', 'A{2}');
+------------------------------------+
| REGEXP_INSTR('AA AAA AAA', 'A{2}') |
+------------------------------------+
|                                  1 |
+------------------------------------+
1 row in set (0.00 sec)

mysql> select REGEXP_INSTR('AA AAA AAAA', 'A{3}');
+-------------------------------------+
| REGEXP_INSTR('AA AAA AAAA', 'A{3}') |
+-------------------------------------+
|                                   4 |
+-------------------------------------+
1 row in set (0.00 sec)

mysql> select REGEXP_INSTR('AA AAA AAAA', 'A{4}');
+-------------------------------------+
| REGEXP_INSTR('AA AAA AAAA', 'A{4}') |
+-------------------------------------+
|                                   8 |
+-------------------------------------+

mysql> select REGEXP_INSTR('AA AAA AAAA', 'B{4}');
+-------------------------------------+
| REGEXP_INSTR('AA AAA AAAA', 'B{4}') |
+-------------------------------------+
|                                   0 |
+-------------------------------------+
1 row in set (0.00 sec)

mysql> select REGEXP_INSTR('AA AAA AAAA', 'NULL');
+-------------------------------------+
| REGEXP_INSTR('AA AAA AAAA', 'NULL') |
+-------------------------------------+
|                                   0 |
+-------------------------------------+
1 row in set (0.00 sec)

REGEXP_LIKE(expr, pat[, match_type])
-------------------------------------
Returns 1 if the string expr matches the regular expression specified by the pattern pat, 0 otherwise. If expr or pat is NULL, the return value is NULL.

The pattern can be an extended regular expression, the syntax for which is discussed in Regular Expression Syntax. The pattern need not be a literal string. For example, it can be specified as a string expression or table column.

The optional match_type argument is a string that may contain any or all the following characters specifying how to perform matching:

c: Case-sensitive matching.

i: Case-insensitive matching.

m: Multiple-line mode. Recognize line terminators within the string. The default behavior is to match line terminators only at the start and end of the string expression.

n: The . character matches line terminators. The default is for . matching to stop at the end of a line.

u: Unix-only line endings. Only the newline character is recognized as a line ending by the ., ^, and $ match operators.

If characters specifying contradictory options are specified within match_type, the rightmost one takes precedence.

By default, regular expression operations use the character set and collation of the expr and pat arguments when deciding the type of a character and performing the comparison. If the arguments have different character sets or collations, coercibility rules apply as described in Section 10.8.4, “Collation Coercibility in Expressions”. Arguments may be specified with explicit collation indicators to change comparison behavior.

mysql> select regexp_like('CamelCase', 'CAMELCASE');
+---------------------------------------+
| regexp_like('CamelCase', 'CAMELCASE') |
+---------------------------------------+
|                                     1 |
+---------------------------------------+

mysql> select regexp_like('CamelCase', 'CAMELCASE', 'c');
+--------------------------------------------+
| regexp_like('CamelCase', 'CAMELCASE', 'c') |
+--------------------------------------------+
|                                          0 |
+--------------------------------------------+

mysql> select regexp_like('CamelCase', 'CAMELCASE' COLLATE utf8mb4_0900_as_cs);
+------------------------------------------------------------------+
| regexp_like('CamelCase', 'CAMELCASE' COLLATE utf8mb4_0900_as_cs) |
+------------------------------------------------------------------+
|                                                                0 |
+------------------------------------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like('CamelCase', BINARY 'CAMELCASE');
+----------------------------------------------+
| regexp_like('CamelCase', BINARY 'CAMELCASE') |
+----------------------------------------------+
|                                            0 |
+----------------------------------------------+

match_type may be specified with the c or i characters to override the default case sensitivity. Exception: If either argument is a binary string, the arguments are handled in case-sensitive fashion as binary strings, even if match_type contains the i character.

mysql> select regexp_like('CamelCase', BINARY 'CAMELCASE', 'i');
+---------------------------------------------------+
| regexp_like('CamelCase', BINARY 'CAMELCASE', 'i') |
+---------------------------------------------------+
|                                                 1 |
+---------------------------------------------------+

Note
MySQL uses C escape syntax in strings (for example, \n to represent the newline character). If you want your expr or pat argument to contain a literal \, you must double it. (Unless the NO_BACKSLASH_ESCAPES SQL mode is enabled, in which case no escape character is used.)

REGEXP_REPLACE(expr, pat, repl[, pos[, occurrence[, match_type]]])
--------------------------------------------------------------------
Replaces occurrences in the string expr that match the regular expression specified by the pattern pat with the replacement string repl, and returns the resulting string. If expr, pat, or repl is NULL, the return value is NULL.

REGEXP_REPLACE() takes these optional arguments:

pos: The position in expr at which to start the search. If omitted, the default is 1.

occurrence: Which occurrence of a match to replace. If omitted, the default is 0 (which means “replace all occurrences”).

match_type: A string that specifies how to perform matching. The meaning is as described for REGEXP_LIKE().

Prior to MySQL 8.0.17, the result returned by this function used the UTF-16 character set; in MySQL 8.0.17 and later, the character set and collation of the expression searched for matches is used. (Bug #94203, Bug #29308212)

For additional information about how matching occurs, see the description for REGEXP_LIKE().

mysql> select REGEXP_REPLACE('a b c', 'b', 'X');
+-----------------------------------+
| regexp_replace('a b c', 'b', 'X') |
+-----------------------------------+
| a X c                             |
+-----------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_replace('abc def ghi', '[a-z]+', 'X', 1,3);
+---------------------------------------------------+
| regexp_replace('abc def ghi', '[a-z]+', 'X', 1,3) |
+---------------------------------------------------+
| abc def X                                         |
+---------------------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_replace('abc def ghi', '[a-z]+', 'X');
+----------------------------------------------+
| regexp_replace('abc def ghi', '[a-z]+', 'X') |
+----------------------------------------------+
| X X X                                        |
+----------------------------------------------+

REGEXP_SUBSTR(expr, pat[, pos[, occurrence[, match_type]]])
------------------------------------------------------------
Returns the substring of the string expr that matches the regular expression specified by the pattern pat, NULL if there is no match. If expr or pat is NULL, the return value is NULL.

REGEXP_SUBSTR() takes these optional arguments:

pos: The position in expr at which to start the search. If omitted, the default is 1.

occurrence: Which occurrence of a match to search for. If omitted, the default is 1.

match_type: A string that specifies how to perform matching. The meaning is as described for REGEXP_LIKE().

Prior to MySQL 8.0.17, the result returned by this function used the UTF-16 character set; in MySQL 8.0.17 and later, the character set and collation of the expression searched for matches is used. (Bug #94203, Bug #29308212)

For additional information about how matching occurs, see the description for REGEXP_LIKE().

mysql> select regexp_substr('abc def ghi', '[a-z]+');
+----------------------------------------+
| regexp_substr('abc def ghi', '[a-z]+') |
+----------------------------------------+
| abc                                    |
+----------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_substr('abc def ghi', '[a-z]+',1);
+------------------------------------------+
| regexp_substr('abc def ghi', '[a-z]+',1) |
+------------------------------------------+
| abc                                      |
+------------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_substr('abc def ghi', '[a-z]+',1,2);
+--------------------------------------------+
| regexp_substr('abc def ghi', '[a-z]+',1,2) |
+--------------------------------------------+
| def                                        |
+--------------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_substr('abc 12 def ghi', '[a-z]+',1,2);
+-----------------------------------------------+
| regexp_substr('abc 12 def ghi', '[a-z]+',1,2) |
+-----------------------------------------------+
| def                                           |
+-----------------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_substr('abc12def ghi', '[a-z]+',1,2);
+---------------------------------------------+
| regexp_substr('abc12def ghi', '[a-z]+',1,2) |
+---------------------------------------------+
| def                                         |
+---------------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_substr('abc12def ghi', '[a-z]+');
+-----------------------------------------+
| regexp_substr('abc12def ghi', '[a-z]+') |
+-----------------------------------------+
| abc                                     |
+-----------------------------------------+


Regular Expression Syntax
==========================
Regular Expression Syntax

A regular expression describes a set of strings. The simplest regular expression is one that has no special characters in it. For example, the regular expression hello matches hello and nothing else.

Nontrivial regular expressions use certain special constructs so that they can match more than one string. For example, the regular expression hello|world contains the | alternation operator and matches either the hello or world.

As a more complex example, the regular expression B[an]*s matches any of the strings Bananas, Baaaaas, Bs, and any other string starting with a B, ending with an s, and containing any number of a or n characters in between.

The following list covers some of the basic special characters and constructs that can be used in regular expressions. For information about the full regular expression syntax supported by the ICU library used to implement regular expression support, visit the International Components for Unicode website.

^ - Match the beginning of a string.
mysql> select regexp_like ('fo\nfo', '^fo$');
+--------------------------------+
| regexp_like ('fo\nfo', '^fo$') |
+--------------------------------+
|                              0 |
+--------------------------------+
1 row in set (0.01 sec)

mysql> select regexp_like ('fo\nfo', '^fo');
+-------------------------------+
| regexp_like ('fo\nfo', '^fo') |
+-------------------------------+
|                             1 |
+-------------------------------+

$ - Match the end of a string.
mysql> SELECT REGEXP_LIKE('fo\no', '^fo\no$');                 -> 1
mysql> SELECT REGEXP_LIKE('fo\no', '^fo$');                    -> 0

. - Match any character (including carriage return and newline, although to match these in the middle of a string, the m (multiple line) match-control character or the (?m) within-pattern modifier must be given).

mysql> select regexp_like ('fofo', '^f.*$');
+-------------------------------+
| regexp_like ('fofo', '^f.*$') |
+-------------------------------+
|                             1 |
+-------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like ('fo\r\nfo', '^f.*$');
+-----------------------------------+
| regexp_like ('fo\r\nfo', '^f.*$') |
+-----------------------------------+
|                                 0 |
+-----------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like ('fo\r\nfo', '^f.*$', 'm');
+----------------------------------------+
| regexp_like ('fo\r\nfo', '^f.*$', 'm') |
+----------------------------------------+
|                                      1 |
+----------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like ('fo\r\nfo', '(?m)^f.*$');
+---------------------------------------+
| regexp_like ('fo\r\nfo', '(?m)^f.*$') |
+---------------------------------------+
|                                     1 |
+---------------------------------------+

a* - Match any sequence of zero or more a characters.
mysql> SELECT REGEXP_LIKE('Ban', '^Ba*n');                     -> 1
mysql> SELECT REGEXP_LIKE('Baaan', '^Ba*n');                   -> 1
mysql> SELECT REGEXP_LIKE('Bn', '^Ba*n');                      -> 1

a+ - Match any sequence of one or more a characters.
mysql> SELECT REGEXP_LIKE('Ban', '^Ba+n');                     -> 1
mysql> SELECT REGEXP_LIKE('Bn', '^Ba+n');                      -> 0

a? - Match either zero or one a character.
mysql> SELECT REGEXP_LIKE('Bn', '^Ba?n');                      -> 1
mysql> SELECT REGEXP_LIKE('Ban', '^Ba?n');                     -> 1
mysql> SELECT REGEXP_LIKE('Baan', '^Ba?n');                    -> 0

de|abc - alternation; match either of the sequences de or abc.
mysql> SELECT REGEXP_LIKE('pi', 'pi|apa');                     -> 1
mysql> SELECT REGEXP_LIKE('axe', 'pi|apa');                    -> 0
mysql> SELECT REGEXP_LIKE('apa', 'pi|apa');                    -> 1
mysql> SELECT REGEXP_LIKE('apa', '^(pi|apa)$');                -> 1
mysql> SELECT REGEXP_LIKE('pi', '^(pi|apa)$');                 -> 1
mysql> SELECT REGEXP_LIKE('pix', '^(pi|apa)$');                -> 0

(abc)* - Match zero or more instances of the sequence abc.
mysql> SELECT REGEXP_LIKE('pi', '^(pi)*$');                    -> 1
mysql> SELECT REGEXP_LIKE('pip', '^(pi)*$');                   -> 0
mysql> SELECT REGEXP_LIKE('pipi', '^(pi)*$');                  -> 1

mysql> SELECT REGEXP_LIKE('pip', '(pi)*');
+-----------------------------+
| REGEXP_LIKE('pip', '(pi)*') |
+-----------------------------+
|                           1 |
+-----------------------------+
1 row in set (0.00 sec)

{1}, {2,3} - Repetition; {n} and {m,n} notation provide a more general way of writing regular expressions that match many occurrences of the previous atom (or “piece”) of the pattern. m and n are integers.

a* - Can be written as a{0,}.
a+ - Can be written as a{1,}.
a? - Can be written as a{0,1}.

mysql> select regexp_like ('abcde', 'a[bcd]{1}e');
+-------------------------------------+
| regexp_like ('abcde', 'a[bcd]{1}e') |
+-------------------------------------+
|                                   0 |
+-------------------------------------+
1 row in set (0.01 sec)

mysql> select regexp_like ('abcde', 'a[bcd]{1,}e');
+--------------------------------------+
| regexp_like ('abcde', 'a[bcd]{1,}e') |
+--------------------------------------+
|                                    1 |
+--------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like ('abcde', 'a[bcd]{2}e');
+-------------------------------------+
| regexp_like ('abcde', 'a[bcd]{2}e') |
+-------------------------------------+
|                                   0 |
+-------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like ('abcde', 'a[bcd]{3}e');
+-------------------------------------+
| regexp_like ('abcde', 'a[bcd]{3}e') |
+-------------------------------------+
|                                   1 |
+-------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like ('abcde', 'a[bcd]{4}e');
+-------------------------------------+
| regexp_like ('abcde', 'a[bcd]{4}e') |
+-------------------------------------+
|                                   0 |
+-------------------------------------+

mysql> SELECT REGEXP_LIKE('abcde', 'a[bcd]{1,10}e');           -> 1

[a-dX], [^a-dX] - Matches any character that is (or is not, if ^ is used) either a, b, c, d or X. A - character between two other characters forms a range that matches all characters from the first character to the second. For example, [0-9] matches any decimal digit. To include a literal ] character, it must immediately follow the opening bracket [. To include a literal - character, it must be written first or last. Any character that does not have a defined special meaning inside a [] pair matches only itself.

mysql> SELECT REGEXP_LIKE('aXbc', '[a-dXYZ]');                 -> 1
mysql> SELECT REGEXP_LIKE('aXbc', '^[a-dXYZ]$');               -> 0
mysql> SELECT REGEXP_LIKE('aXbc', '^[a-dXYZ]+$');              -> 1
mysql> SELECT REGEXP_LIKE('aXbc', '^[^a-dXYZ]+$');             -> 0
mysql> SELECT REGEXP_LIKE('gheis', '^[^a-dXYZ]+$');            -> 1
mysql> SELECT REGEXP_LIKE('gheisa', '^[^a-dXYZ]+$');           -> 0

mysql> SELECT REGEXP_LIKE('aXbcZ', '^[a-dXY]');
+----------------------------------+
| REGEXP_LIKE('aXbcZ', '^[a-dXY]') |
+----------------------------------+
|                                1 |
+----------------------------------+
1 row in set (0.00 sec)

mysql> SELECT REGEXP_LIKE('caXbcZ', '^[a-dXY]');
+-----------------------------------+
| REGEXP_LIKE('caXbcZ', '^[a-dXY]') |
+-----------------------------------+
|                                 1 |
+-----------------------------------+

[=character_class=] - Within a bracket expression (written using [ and ]), [=character_class=] represents an equivalence class. It matches all characters with the same collation value, including itself. For example, if o and (+) are the members of an equivalence class, [[=o=]], [[=(+)=]], and [o(+)] are all synonymous. An equivalence class may not be used as an endpoint of a range.

[:character_class:] - Within a bracket expression (written using [ and ]), [:character_class:] represents a character class that matches all characters belonging to that class. The following table lists the standard class names. These names stand for the character classes defined in the ctype(3) manual page. A particular locale may provide other class names. A character class may not be used as an endpoint of a range.

Character Class Name	Meaning
alnum	                Alphanumeric characters
alpha	                Alphabetic characters
blank	                Whitespace characters
cntrl	                Control characters
digit	                Digit characters
graph	                Graphic characters
lower	                Lowercase alphabetic characters
print	                Graphic or space characters
punct	                Punctuation characters
space	                Space, tab, newline, and carriage return
upper	                Uppercase alphabetic characters
xdigit	                Hexadecimal digit characters

mysql> SELECT REGEXP_LIKE('justalnums', '[[:alnum:]]+');       -> 1
mysql> SELECT REGEXP_LIKE('!!', '[[:alnum:]]+');               -> 0

To use a literal instance of a special character in a regular expression, precede it by two backslash (\) characters. The MySQL parser interprets one of the backslashes, and the regular expression library interprets the other. For example, to match the string 1+2 that contains the special + character, only the last of the following regular expressions is the correct one:

mysql> SELECT REGEXP_LIKE('1+2', '1+2');                       -> 0
mysql> SELECT REGEXP_LIKE('1+2', '1\+2');                      -> 0
mysql> SELECT REGEXP_LIKE('1+2', '1\\+2');                     -> 1

mysql> select regexp_like('ramesh123', '[[:alnum:]]');
+-----------------------------------------+
| regexp_like('ramesh123', '[[:alnum:]]') |
+-----------------------------------------+
|                                       1 |
+-----------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like('ramesh', '[[:alnum:]]');
+--------------------------------------+
| regexp_like('ramesh', '[[:alnum:]]') |
+--------------------------------------+
|                                    1 |
+--------------------------------------+
1 row in set (0.01 sec)

mysql> select regexp_like('123', '[[:alnum:]]');
+-----------------------------------+
| regexp_like('123', '[[:alnum:]]') |
+-----------------------------------+
|                                 1 |
+-----------------------------------+
1 row in set (0.01 sec)

mysql> select regexp_like('', '[[:alnum:]]');
+--------------------------------+
| regexp_like('', '[[:alnum:]]') |
+--------------------------------+
|                              0 |
+--------------------------------+
1 row in set (0.01 sec)

mysql> select regexp_like('123!', '[[:alnum:]]');
+------------------------------------+
| regexp_like('123!', '[[:alnum:]]') |
+------------------------------------+
|                                  1 |
+------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like('123!', '[[:alnum:]]+');
+-------------------------------------+
| regexp_like('123!', '[[:alnum:]]+') |
+-------------------------------------+
|                                   1 |
+-------------------------------------+
1 row in set (0.01 sec)


Regular Expression Resource Control

REGEXP_LIKE() and similar functions use resources that can be controlled by setting system variables:

The match engine uses memory for its internal stack. To control the maximum available memory for the stack in bytes, set the regexp_stack_limit system variable.

The match engine operates in steps. To control the maximum number of steps performed by the engine (and thus indirectly the execution time), set the regexp_time_limit system variable. Because this limit is expressed as number of steps, it affects execution time only indirectly. Typically, it is on the order of milliseconds.

3.3.4.8 Counting Rows
---------------------
Databases are often used to answer the question, “How often does a certain type of data occur in a table?” For example, you might want to know how many pets you have, or how many pets each owner has, or you might want to perform various kinds of census operations on your animals.

Counting the total number of animals you have is the same question as “How many rows are in the pet table?” because there is one record per pet. COUNT(*) counts the number of rows, so the query to count your animals looks like this:
mysql> select count(*) from pet;
+----------+
| count(*) |
+----------+
|        9 |
+----------+

Earlier, you retrieved the names of the people who owned pets. You can use COUNT() if you want to find out how many pets each owner has:
mysql> select owner, count(owner) from pet group by owner;
+--------+--------------+
| owner  | count(owner) |
+--------+--------------+
| Harold |            2 |
| Gwen   |            3 |
| Benny  |            2 |
| Diane  |            1 |
| Chinku |            1 |
+--------+--------------+
5 rows in set (0.00 sec)

The preceding query uses GROUP BY to group all records for each owner. The use of COUNT() in conjunction with GROUP BY is useful for characterizing your data under various groupings. The following examples show different ways to perform animal census operations.

Number of animals per species:
mysql> select species, count(species) from pet group by species;
+---------+----------------+
| species | count(species) |
+---------+----------------+
| cat     |              2 |
| dog     |              4 |
| bird    |              2 |
| snake   |              1 |
+---------+----------------+
4 rows in set (0.01 sec)

Number of animals per sex:
mysql> select sex, count(sex) from pet group by sex;
+------+------------+
| sex  | count(sex) |
+------+------------+
| F    |          3 |
| M    |          5 |
| NULL |          0 |
+------+------------+
3 rows in set (0.00 sec)

OR -
mysql> select sex, count(*) from pet group by sex;
+------+----------+
| sex  | count(*) |
+------+----------+
| F    |        3 |
| M    |        5 |
| NULL |        1 |
+------+----------+
3 rows in set (0.00 sec)

(In this output, NULL indicates that the sex is unknown.)

Number of animals per combination of species and sex:
mysql> select species, sex, count(*) from pet group by species, sex;
+---------+------+----------+
| species | sex  | count(*) |
+---------+------+----------+
| cat     | F    |        1 |
| cat     | M    |        1 |
| dog     | F    |        1 |
| dog     | M    |        3 |
| bird    | F    |        1 |
| bird    | NULL |        1 |
| snake   | M    |        1 |
+---------+------+----------+

You need not retrieve an entire table when you use COUNT(). For example, the previous query, when performed just on dogs and cats, looks like this:
mysql> select species, sex, count(*) from pet where species = 'dog' or species = 'cat' group by species, sex;
+---------+------+----------+
| species | sex  | count(*) |
+---------+------+----------+
| cat     | F    |        1 |
| cat     | M    |        1 |
| dog     | F    |        1 |
| dog     | M    |        3 |
+---------+------+----------+
4 rows in set (0.00 sec)

OR -
mysql> select species, sex, count(*) from pet group by species, sex having species='dog' or species='cat';
+---------+------+----------+
| species | sex  | count(*) |
+---------+------+----------+
| cat     | F    |        1 |
| cat     | M    |        1 |
| dog     | F    |        1 |
| dog     | M    |        3 |
+---------+------+----------+
4 rows in set (0.00 sec)

Or, if you wanted the number of animals per sex only for animals whose sex is known:
mysql> select species, sex, count(sex) from pet where sex is not null group by species, sex;
+---------+------+------------+
| species | sex  | count(sex) |
+---------+------+------------+
| cat     | F    |          1 |
| cat     | M    |          1 |
| dog     | F    |          1 |
| dog     | M    |          3 |
| bird    | F    |          1 |
| snake   | M    |          1 |
+---------+------+------------+
6 rows in set (0.00 sec)

mysql> select species, sex, count(*) from pet where sex is not null group by species, sex;
+---------+------+----------+
| species | sex  | count(*) |
+---------+------+----------+
| cat     | F    |        1 |
| cat     | M    |        1 |
| dog     | F    |        1 |
| dog     | M    |        3 |
| bird    | F    |        1 |
| snake   | M    |        1 |
+---------+------+----------+
6 rows in set (0.00 sec)

If you name columns to select in addition to the COUNT() value, a GROUP BY clause should be present that names those same columns. Otherwise, the following occurs:

If the ONLY_FULL_GROUP_BY SQL mode is enabled, an error occurs:

mysql> SET sql_mode = 'ONLY_FULL_GROUP_BY';
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT owner, COUNT(*) FROM pet;
ERROR 1140 (42000): In aggregated query without GROUP BY, expression
#1 of SELECT list contains nonaggregated column 'menagerie.pet.owner';
this is incompatible with sql_mode=only_full_group_by
If ONLY_FULL_GROUP_BY is not enabled, the query is processed by treating all rows as a single group, but the value selected for each named column is nondeterministic. The server is free to select the value from any row:

mysql> SET sql_mode = '';
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT owner, COUNT(*) FROM pet;
+--------+----------+
| owner  | COUNT(*) |
+--------+----------+
| Harold |        8 |
+--------+----------+
1 row in set (0.00 sec)

See also Section 12.20.3, “MySQL Handling of GROUP BY”. See Section 12.20.1, “Aggregate Function Descriptions” for information about COUNT(expr) behavior and related optimizations.

12.20.3 MySQL Handling of GROUP BY
----------------------------------

