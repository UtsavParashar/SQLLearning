SQL Theory -

It's a declarative language i.e you don't have to tell sql how to divide the task and get the things done. It has SQL optimizer to create sub task and do the job.
You just need to tell SQL, get me this data and you are done.
Concentration is what you require rather then how to find what you require.

As a declarative language, it has following 4 components:
1. DDL - Data Definition Language
2. DML - Data Manipulation Language
3. DCL - Data Control Language
4. TCL - Transaction Control Language

DDL
----
SQLs Syntax - Comprises of several types of statements that allow you to perform various commands and operations.

DDL - A set of statements that allow the user to define or modify data structures and objects, such as tables.

Create Statement - Create Database and Database objects like tables.
-----------------
Syntax :
    CREATE OBJECT_TYPE object_name;

Eg. CREATE TABLE table_name (column_name, datetype);
CREATE TABLE  sales (purchare_number, INT);

It is a common practise to have same name of the database and its main table.

Alter Statement - Alter a table by adding removing renaming column names
---------------
Eg. ALTER TABLE sales
ADD COLUMN purchase_date DATE;


DROP/Delete a table/database:
-----------------------------
DROP OBJECT object_name;
DROP TABLE sales;

RENAME - To rename a table/column etc.
-------
RENAME TABLE sales TO customer_sales;

TRUNCATE Statement:
-------------------
To clear all data i.e elements of the table but the keep the schema of the table, we can go with TRUNCATE statement.
TRUNCATE OBJECT object_name;
TRUNCATE TABLE customers;

SQL Keywords: ~ RESERVED WORDS
-------------
ADD, RENAME, ALTER(ADD, REMOVE), DROP, TRUNCATE etc

Keywords in SQL cannot be variable names - objects and databases cannot have names that coincides with SQL keywords.


DML - Data Manipulation Language
================================
The statements that allows us to manipulate data in the tables of a database.

SELECT Statement - used to retrieve data from db objects like tables.
----------------- Eg: SELECT * FROM TABLE;
SELECT * FROM sales;

Generalized version
SELECT ... FROM ... WHERE

INSERT Statement - used to insert data into tables.
-----------------
It goes hand in hand with keywords -- INTO and VALUES

Generalized version
INSERT INTO ... VALUES

Eg
INSERT INTO sales (purchare_number, purchase_date) VALUES (1, '2021-01-01')  -- OR
INSERT INTO sales VALUES (2, '2021-03-02') -- Since we have two columns, values will be entered in positional sequence.

UPDATE Statement - allows you to update/renew existing data of your tables.
----------------
It goes hand in hand with

Generalized version
UPDATE .... SET .... WHERE

Eg. UPDATE sales
    SET  purchase_date='2021-03-01'
    WHERE purchare_number=1;

DELETE Statement - It works similar to the TRUNCATE statement from DDL.
----------------
With a diff - DELETE vs TRUNCATE
TRUNCATE removes all the data from the table i.e clear all elements from the table whereas
DELETE can either remove all elements or we can precisely specify what all rows are to be removed by providing the condition with where clause.

DELETE FROM sale; -- works similar to TRUNCATE i.e
TRUNCATE TABLE sales;

Generalized version -- DELETE ... FROM ... WHERE

But if we want to delete a row based on condition then we can go with:
DELETE FROM sales
WHERE purchase_date='2021-03-01'; -- This will remove only one horizontal entity from the table.

Generalized versions of DML Language Statements:
SELECT -- SELECT ... FROM ... WHERE
INSERT -- INSERT INTO ... VALUES
UPDATE -- UPDATE ... SET ... WHERE
DELETE -- DELETE ... FROM ... WHERE

DCL - Data Control Language
=============================
It includes two statements
GRANT and REVOKE - allows us to make rights users have in a db.

GRANT - GRANT gives or grants certain permissions to users
-------
Syntax - GRANT type_of_permission
         ON database_name.table_name
         TO 'username'@'localhost'

From this statement a user can be granted a certain permission (SELECT/INSERT/UPDATE/DELETE/CREATE/ALTER(ADD,REMOVE)/DROP/TRUNCATE/RENAME) to one of many tables of a db.

Eg. GRANT SELECT
    ON salesDb.customers_table
    TO 'frank'@'euhost'

This statement will provide ONLY select permission to user frank on table customers_table of salesDb database.

To grant all permission to frank on salesDb we can use:
GRANT ALL
ON salesdb.*
TO 'frank'@'euhost'

Database Admin - People who have complete rights to the db are db admin they can grant access to users and can revoke it.
---------------

REVOKE - used to revoke permissions of the users, it is the exact opposite of GRANT.
-------
Eg. REVOKE SELECT
    ON salesdb.customers_table
    FROM 'frank'@'euhost'


TCL - Transaction Control Language
===================================
Not every change you make to a db is saved automatically.

COMMIT Statement - All the changes which you have made related to INSERT, UPDATE, DELETE will not be saved permanently until you commit them.
----------------
Commit will save the changes you have made and will have other users have access to the modified version of the database.
Once Commit is run, changes cannot be undone.

Eg. To Update last name of a user
UPDATE customer_table
SET lastname = 'Kumar'
WHERE firstname='Ramesh';

After running above statement, rest of the users using the db won't know that you have updated the lastname. In order to reflect the changes to other users, you will have to add commit to the statement.

UPDATE customer_table
SET lastname='Kumar'
WHERE firstname='Ramesh'
COMMIT;

Now the updated information will be available to the users.
If you are db admin, u might have to run Commit 20 times a day hence committed states can accrue.

ROLLBACK clause - This clause will let you make a step back.
---------------
It allows you to undo any changes you have made an don't want to save permanently.

eg. ROLLBACK;

This will remove all changes and move to last committed state.


Revision:
DDL - CREATE/DESCRIBE DATA
    CREATE - CREATE TABLE table_name;
    ALTER - ALTER TABLE table_name ADD COLUMN column_name column_type;
    RENAME - RENAME TABLE table_name;
    DROP - DROP TABLE table_name;
    TRUNCATE - TRUNCATE TABLE table_name;

DML - MANIPULATE DATA
    SELECT - SELECT * FROM table_name  WHERE condition;
    INSERT - INSERT INTO table_name  WHERE condition;
    UPDATE - UPDATE table_name SET values WHERE condition;
    DELETE - DELETE cols FROM table_name WHERE condition;

DCL - CONTROL DATA THROUGH ACCESS
    GRANT - GRANT SELECT ON table_name TO 'user_name'@'hostname';
    REVOKE - REVOKE SELECT ON table_name FROM  'user_name'@'hostname';

TCL - COMMIT AND REVOKE CHANGES
    COMMIT - COMMIT;
    ROLLBACK - ROLLBACK;

Basic Database Terminology
==========================
The goal of the db is is to organize huge amounts of data that can be quickly retrieved.

What is relational database?
Database where there is relationship between tables also called as relations in the form of primary - foreign key. Hence when we need data from k of n tables then we work with only k tables(i.e only k tables are loaded) hence data is efficiently retrieved.
It is based on relational algebra.
i.e 3 tables == 3 relations
The smallest unit in the entire system that can carry integral logical meaning.

Two ways to design a DB:
------------------------
ER Diagram - Draw a diagram(like flowchart) showing the mappings of all tables and their connections through arrows.
Relational Schema - Create a rectangle for each table with tablename at the top and columns in rectangle, do same for all tables in a db and connect them through arrows.
When we combine relational schema it forms the database schema.


Primary Key:
============
A column or a set of columns whose value exists and is unique for every record in a table is a candidate of primary key.
Each table can have one and only one Primary key. In one table we cannot have 3-4 primary keys.
That Primary key can be a single Field(Column) like Purchase_id in sales table where purchase_id will have unique sequence of numbers.
Or two columns together can be combined to form a primary key eg purchase_number + date_of_purchase.
Only condition being Primary key should be unique.
Primary keys are also called unique identifiers of a table.
Primary keys cannot contain null values.

In Relational schema -
Table Name is at the top.
Then the primary key column is placed at the to of all other columns as is underlined.
Relational schema for a sales table having purchase_id as a primary key.

        Sales
 =======================
|    purchase_id        |
|    ------------       |
|    date_of_purchase   |
|    customer_id        |
|    item_code          |
 -----------------------

Not all tables you work with will have a primary key.

Foreign Key:
-----------
Suppose we have customers info like firstname, lastname, emailaddress, numberofcomplaints which is required in more than one table then other then having redundant info in different tables we can create Customers table with a primary key as customer_id and this can be mapped to other tables where it will behave as Foreign key.
primary key customer_id can have different column name in different tables like ID, cust_id etc but it can be mapped as Foreign key and Primary key combination.
Eg. In sales table we same name for column customer_id for foreign key which maps to primary key customer_id of Customers table.

Relational schema:
Foreign key in one table should be shown by (FK) around the column name and it should point an arrow to the primary key of other table it is mapping.
Eg. customer_id which is FK in Sales will point to primary key customer_id of Customer table.
Similarly there can be other tables like Items with item_code as FK in Sales table and primary key in Items table

                                             Customers
                                      =================================
        Sales              |-------> |      customer_id                 |
 =======================   |         |      ------------                |
|    purchase_id        |  |         |      first_name                  |
|    ------------       |  |         |      last_name                   |
|    date_of_purchase   |  |         |      email_address               |
|    customer_id  (FK)  |--          |      number_of_complaints        |
|    item_code    (FK)  |--|          ----------------------------------
 -----------------------   |
                           |
                           |                    Items
                           |         ===================================
                           |------->|           item_code               |
                                    |           ----------              |
                                    |           item                    |
                                    |           unit_price              |
                                    |           company_id              |
                                     -----------------------------------

 if the foreign key inserted in the Sales table does not have a corresponding value in Customers table then sql will raise an error.

 HENCE, FOREIGN KEYS ARE IDENTIFIERS THAT IDENTIFIES RELATIONS BETWEEN TABLES BUT NOT THE TABLES THEMSELVES.

 Relational Schema - Unique Keys and Null Values
 ================================================
 Unique key is used whenever you would like to specify that you don't want to see duplicate data in a given field.
 Unique keys are columns which should have unique values but unlike primary key
 1. It can contain null values
 2. There can be more than one unique columns in a table.

 Similar to primary key:- Unique key can be formed by combination of one or more columns.

                                             Customers
                                       =================================
         Sales              |-------> |      customer_id                 |
  =======================   |         |      ------------                |
 |    purchase_id        |  |         |      first_name                  |
 |    ------------       |  |         |      last_name                   |
 |    date_of_purchase   |  |         |      email_address               |
 |    customer_id  (FK)  |--          |      number_of_complaints        |
 |    item_code    (FK)  |--|          ----------------------------------
  -----------------------   |
                            |
                            |                    Items
                            |         ===================================
                            |------->|           item_code               |                      Companies
                                     |           ----------              |               ===================================
                                     |           item                    |      |--->   |       company_id                  |
                                     |           unit_price              |      |       |       -----------                 |
                                     |           company_id   (FK)       |------|       |       headquarters_phone_number   |
                                      -----------------------------------               |       company_name                |
                                                                                         -----------------------------------

Relationships
==============
Relationships tell you how much of the data from a foreign key field can be seen in the primary key column of the table the data is related to and vice versa.

customer_id column in Sales can have many duplicates as a customer can buy many items but each customer can have a single entry(customer_id) in Customers table.
Hence Customers to Sales is - One to Many relationship AND
Sales to Customers is - Many to One relationship

In relational diagram, one to many relationship is shown as >| AND
many to one relationship is shown as ||

                                             Customers
                               Many-One  =================================
         Sales                 |---||->|      customer_id                 |
  =======================      |       |      ------------                |
 |    purchase_id        |     |       |      first_name                  |
 |    ------------       |     |       |      last_name                   |
 |    date_of_purchase   |     |       |      email_address               |
 |    customer_id  (FK)  |\|---|       |      number_of_complaints        |
 |    item_code    (FK)  |/|             ----------------------------------
  ----------------------- One-Many

These are called cardinality constraints.
 > | define max and min relationship respectively.
 M N - define infinite relationship
 O - Optional Relationship which in this case when it was not necessary for a registered person to purchase an item.

 Few types of relationship-
 one to one
 one to many
 many to many
 many to one

Hence, Relational Schemas
- represents the concept db admins must implement
- depict how a database is organized
- blueprints, or a plan for a db

Relational Schemas will help you immensely while writing your queries.

Section 5 - First Steps in SQL
------------------------------
Let's create a db first.

Syntax: CREATE DATABASE [IF NOT EXISTS] dbname; -- OR
CREATE SCHEMA IF NOT EXISTS dbname;


Let's dissect the above statement.

CREATE DATABASE - Creates a db as an abstract unit it means after this statement db will not create any data but act as an object which is ready to persist information.

IF NOT EXISTS - verifies if the db with the same name exists already.
This won't prevent(impede) us from creating a db with the same name. The bracket around mean the statement is optional (we can either type or omit the statement),even if we don't include it, it will run anyway. It is always useful to include it because when we are working with large amount of datasets it reduces potential errors

dbname - It is always suggested to give a short name but at the same time as related to content of data as possible.

The SQL code is not case sensitive.
We can use quotes around dbname or without quotes.

; - Semi colon is the statement terminator. It is often true that the statement will run properly without it but in longer scripts when the code contains more than one statement. The semi colon is indispensable.
make a habit of using semi colon.

There can be many db when working through Workbench, in that case we can apply USE command to use a particular db.
USE Sales;

Introduction to Datatypes:
--------------------------
We must specify the type of the data that will be inserted in each column of the table.
Different datatypes represent different types of information that can be contained in a specific column.

String Data Types: The text format is sql is called string.
Datatypes containing strings are also called alphanumeric datatypes.
Eg. James will be treated a string datatype.

CHAR - character string - Fixed length string or called FIXED STORAGE DATATYPE
    max (size)limit is 255
    For CHAR(5) - Here 5 means the max symbols(chars) we are allowed to use in writing a value in this format.
    if a string -
        'James' is stored, it will take 5 bytes storage
        'Bob' is stored, it will also take 5 bytes storage
    Then why use CHAR when it takes fixed bytes?
        Two reasons -
            It is around 50% faster compared to VARCHAR.
            It can be used in situations where we need to store company acronyms with 4 chars like GOOG, AMZN, MSFT then we can go with CHAR(4).

VARCHAR - Variable Character - Variable length string
    Max (size)limit is 65535
    For VARCHAR(5)
    if a string -
            'James' is stored, it will take 5 bytes storage
            'Bob' is stored, it will also take 3 bytes storage
    Example - Store password which is not more than 10 chars, we can use VARCHAR as it will use storage based on size of password.

ENUM - Enumerate - It is particularly useful when we know beforehand what type of column are we going to deal with.
    It is same as choice, like to insert the Gender of a person you can define ENUM('M', 'F') then mysql will show error if you want to store value other than M or F.
    MySql will show an error if you attempt to insert any value different from M or F.

Numeric Types -
===============
INTEGERS
FIXED-POINT
FLOATING-POINT

INTEGERS - When we want to store whole numbers with no decimal points. Eg - 5, 15, -200, 1000
--------
Integers(signed/unsigned) signed includes negative values, then we can go with Integers.
Integers are further divided into few types based on size.
By default, INTEGER type are signed.
If we want to use a range containing only positive, 'unsigned' values, we will have to specify this in our query.

INT Type       size(bytes)              minimum value(signed/unsigned)                     maximum value(signed/unsigned)
TINYINT         1                           -128                                                127
                                               0                                                255
SMALLINT        2                         -32768                                              32767
                                               0                                              65535
MEDIUMINT       3                     -8,388,608                                          8,388,607
                                               0                                         16,777,215
INT             4                 -2,147,483,648                                      2,147,483,647
                                               0                                      4,294,967,295
BIGINT          8     -9,223,372,036,854,775,808                          9,223,372,036,854,775,807
                                               0                         18,446,744,073,709,551,615

Why not just use BIGINT all the time?
Answers comes in computer's processing speed, if in a field you are sure that you won't need an integer smaller than 0 and greater than 100, TINYINT will do the job perfectly and you would not need more storage space per data point.
A smaller integer type may suffice and increase the processing speed.


FIXED-POINT
-----------
DECIMAL
NUMERIC

Let's first get used to two concepts -
precision and scale.
precision - refers to number of digits in a number.
scale - number of digits right to the decimal point in a number.

Eg. DECIMAL(5,3) has precision 5 and scale 3 i.e it can have 5 values and 3 of to the right of decimal.

Fixed Point data represents exact values i.e in case of

DECIMAL(5,3) if the value 10.5 is inserted then mysql will convert it to 10.500.
DECIMAL(5,3) if the value is 10.5247516 then it will be rounded to 10.525 and a warning will be raised for FIXED POINT Number.

When only one digit is placed inside the parentheses, it will be treated as the precision of that data type.
Like DECIMAL(7) will be treated as DECIMAL(7,0) Eg - 1234567

NUMERIC is also defined as
NUMERIC(p,s) -- where p is precision and s is scale
These are good for storing salaries like
NUMERIC(8,2) - 300000.50

FLOATING-POINT
--------------
FLOAT
DOUBLE

It is used for approximate values only
Aims to balance between range and precision ( ==> floating)

When we have FLOAT(5,3) then 10.5 will be stored as is an not 10.500
and 10.524678 will be stored as 10.525 without any warning.

Hence the main difference between the fixed and floating point type is in the way the value is represented in the memory of the computer.
Where fixed point will raise a warning when its structure is not respected but floating point won't.

FLOAT and DOUBLE diff

Floating Point Type     size(bytes)         precision       maximum number of digits
FLOAT                   4                   single          23
DOUBLE                  8                   double          43


What is the difference between DECIMAL and NUMERIC FIXED POINT type? OR
How can I store a variable precision and fixed precision in mysql?
There is a small difference between NUMERIC(p,s) and DECIMAL(p,s) SQL numeric data type. NUMERIC determines the exact precision and scale. DECIMAL specifies only the exact scale; the precision is equal or greater than what is specified by the coder. DECIMAL columns can have a larger-than-specified precision if this is more convenient or efficient for the database system.
In other words, DECIMAL gives you some leeway.
Keep in mind that financial data such as account balances must be stored as NUMERIC or DECIMAL data types.

In statistics numerals are of 4 types:
Nominal - Like customer id, phone numbers etc These numbers are labelled but we don't do calculations on them like we cannot say that id 100 is better then id 90 or by adding two phone numbers we generate an amazing phone number.

Ordinal - These numbers have orders/categories attached to them like on the scale of 1-5, 1 being satisfied 5 being unsatisfied etc

Interval - Interval values shows the exact difference like yesterday the share volume was 100, today its 60 hence the difference is 40.

Ratio - Ratio values are intervals with a defined value as zero.

Each SQL numeric data type is used to represent all of the above values, especially intervals and ratios. You can compare character values in SQL, so one could argue that character values can also represent interval data. However, that's a topic for another article.

In SQL, numbers are defined as either exact or approximate.

The exact numeric data types are SMALLINT, INTEGER, BIGINT, NUMERIC(p,s), and DECIMAL(p,s). Exact SQL numeric data type means that the value is stored as a literal representation of the number's value.

The approximate numeric data types are FLOAT(p), REAL, and DOUBLE PRECISION. These represent real numbers, but they are not represented as exact numbers in the database. Rather, they are an approximation of the real number because of the way that computer systems represent numbers. If this sounds confusing, rest assured that we'll explain it in detail later.

Other Data types:
-----------------
Temporal Types
DATE
DATETIME
TIMESTAMP

DATE - Stores Date is YYYY-MM-DD Format, Range is 1000-01-01 To 9999-12-31. Eg - 2021-06-09
DATETIME - Stores Date + Time in YYYY-MM-DD HH:MM:SS[.MICROS] precision. Eg. - 2021-06-09 10:32:45.36945
TIMESTAMP - Unix timestamps - Epoch time stamps, Range - 1970-01-01 - 2038-01-19.   Useful in time calculations like subtracting one time from another. It is more capable of storing timezones which datetime in not very capable of doing.

Hence -
STRING AND TEMPORAL - CHAR, VARCHAR, DATE, DATETIME, TIMESTAMP might be written in quotes.
NUMERIC - TINYINT, SMALLINT, MIDINT, INT, BIGINT, DECIMAL, NUMERIC, FLOAT, DOUBLE can be written without quotes.


BLOB - Binary Large OBject
For File objects, jpegs, wav etc
Refers to a file of binary data with 1s and 0s.
Involves saving files in a record.
Eg. *.doc, *.xlsx, *.xml, *.jpg, *.wav


Constraints -
NOT NULL - Defines the constraint that column should not be null else an error will be thrown.
AUTO INCREMENT - Increment the values of the column automatically like i column in kdb.
Frees you from having to insert all purchase numbers manually through the INSERT command at the later stage,
assign 1 to the first record of the table and automatically increments by 1 for every subsequent row.

Creating a table in Sales DB
----------------------------
We will create tables as we have created in Relational Schema i.e sales, customers, items, companies.
Let's start with sales table.

Compulsory requirement - While creating a table we must provide atleast one column name, else we will get an error.

Syntax:
CREATE TABLE table_name
(
    col1 datatype constraint,
    col2 datatype constraint,

    coln datatype constraint
);

Eg:
CREATE TABLE sales
(
	purchase_id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
    date_of_purchase DATE NOT NULL,
    customer_id INT,
    item_code VARCHAR(10) NOT NULL
);


CREATE TABLE customers
(
	customer_id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
    first_name VARCHAR(255) NOT NULL,
    last_name VARCHAR(255),
    email_address VARCHAR(255),
    number_of_complaints SMALLINT
);

Queries:
========
query - a command to write in SQL with the idea of either retrieving information from db on which you are working, or, alternatively, to insert, delete, update data from it.
Semi-colon acts as a terminator.
After creating a db Sales, we used 'Use Sales' to let mysql know that we want to use mysql objects(like tables) from Sales db and run query over them.

queries -
one of the main feature of the query is to manipulate data within database.
eg.
USE Sales;
SELECT * FROM customers;

When using multiple databases and tables:
Whenever we want to refer to a SQL object in our queries, we must specify to the db it is applied.
SQL objects are like tables, indexes, views, stored procedures, functions.
We can do it in two ways:
1. set a default db:
    USE Sales;
    SELECT * FROM customers;
2. Call a dbobject directly from dbname using dot operator.
    Syntax: dbname.dbobject
    dot operator - signals the existence of a connection between the two object types.
Eg. SELECT * FROM Sales.customers;


To delete a table:
DROP TABLE table_name;
DROP TABLE sales;


MYSQL Constraints:
------------------
What are constraints?
    specific rules, or limits, that we define in our tables.
    The role of constraints is to outline the existing relationships between different tables in our database.
    eg. NOT NULL, AUTO_INCREMENT, PRIMARY KEY, FOREIGN KEY, UNIQUE KEY

    AUTO_INCREMENT(Extra Constraint) works only with PRIMARY KEY, UNIQUE KEY, INDEX

PRIMARY KEY -
    PRIMARY KEY can be assigned in two ways:

   1. How we did earlier:
    CREATE TABLE sales
    (
    	purchase_id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
        date_of_purchase DATE NOT NULL,
        customer_id INT,
        item_code VARCHAR(10) NOT NULL
    );

   2. Another way:
    CREATE TABLE sales
    (
       	purchase_id INT NOT NULL  AUTO_INCREMENT,
        date_of_purchase DATE NOT NULL,
        customer_id INT,
        item_code VARCHAR(10) NOT NULL,
    PRIMARY KEY(purchase_id)
    );

Eg: customers table
CREATE TABLE customers
(
	customer_id INT NOT NULL AUTO_INCREMENT,
    first_name VARCHAR(255) NOT NULL,
    last_name VARCHAR(255),
    email_address VARCHAR(255),
    number_of_complaints SMALLINT,
PRIMARY KEY(customer_id)
);


FOREIGN KEY
===========
Points to a column of another table and thus links the two tables.

It is a column in one table(Child table / referencing table) which refers to a column in another table(Parent table / referenced table)
In our example child table in sales and parent table in customers when customer_id column(foreign key) of sales table is referred by customer_id(Primary key) of customers table.

Remember, it is not an obligatory requirement - these two keys can have completely different names. What's imp is that the data types and the information match! It's just common practice to use, if not the same, then similar names for both keys.

A foreign key in sql is defined through a foreign key constraint.
Hence the connection between two tables is maintained using foreign keys.
The foreign key maintains the referential integrity within the database.

SYNTAX -
    FOREIGN KEY(foreign key col) REFERENCE parent_table_name(primary key col) ON DELETE CASCADE

ON DELETE CASCADE constraint is used in practice which means if the primary key record os deleted from referenced table then its corresponding records will be deleted from referencing tables.


Three ways to add foreign key constraint:
1. While creating the table:

CREATE TABLE sales
(
    purchase_id         INT NOT NULL AUTO_INCREMENT,
    date_of_purchase    DATE NOT NULL,
    customer_id         INT,
    item_code           INT NOT NULL,
PRIMARY KEY(purchase_id),
FOREIGN KEY(customer_id) REFERENCES customers(customer_id) ON DELETE CASCADE
);

2. ADD foreign key constraint by altering the table
ALTER TABLE sales
ADD FOREIGN KEY(customer_id) REFERENCES customers(customer_id) ON DELETE CASCADE;

Internally ddl for Sales.sales table looks like this
CREATE TABLE `sales` (
  `purchase_id` int NOT NULL AUTO_INCREMENT,
  `date_of_purchase` date NOT NULL,
  `customer_id` int DEFAULT NULL,
  `item_code` int NOT NULL,
  PRIMARY KEY (`purchase_id`),
  KEY `customer_id` (`customer_id`),
  CONSTRAINT `sales_ibfk_1` FOREIGN KEY (`customer_id`) REFERENCES `customers` (`customer_id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci

we can use the foreign key CONSTRAINT name sales_ibfk_1 to drop the foreign key

DROP foreign key
-----------------
ALTER table sales
DROP FOREIGN KEY `sales_ibfk_1`;

OR without backtick
ALTER table sales
DROP FOREIGN KEY sales_ibfk_1;

3. From MySql Workbench
Right click on table name and click 'Alter table' -- Foreign key tab -- Reference table customers --referenced column -- On DELETE cascade - apply
IF you want there is option for on update cascade as well


UNIQUE KEY
===========
Used whenever we would like to specify that we don't want duplicate records in a given field.
It ensures that all values in a column or a set of columns are different.
Just like Primary key and foreign key, unique keys are implemented in SQL through a constraint - UNIQUE KEY.
Hence, if we try to insert a duplicate value in a unique key column then sql with display an error.

Eg. email_address in customers table should be unique.

CREATE TABLE customers
(
	customer_id INT NOT NULL AUTO_INCREMENT,
	first_name VARCHAR(255),
    last_name VARCHAR(255),
    email_address VARCHAR(255),
    number_of_complaints SMALLINT,
PRIMARY KEY(customer_id),
UNIQUE KEY(email_address)
);

Another way is through ALTER table, to add unique key constraint to an existing table.
ALTER TABLE customers
ADD UNIQUE KEY(email_address);

To drop a unique key constraint -
Unique key in mysql has same role as indexes but reverse isn't true.

Index of a table - an organizational unit which helps retrieve data more easily.
Unique key is same as an index to a column which supports faster searching of elements hence to drop unique key we use INDEX.
Indexing comes with a cost, it takes more time to update a table with indexes because indexes must be updated too and it is time consuming.
ALTER TABLE customers
DROP INDEX email_address;

If we will try to add a unique key constraint to an existing table which already have unique key on same Field then mysql will not display an error rather it will just show a warning like below and add one more unique key constaint.
"0 row(s) affected, 1 warning(s): 1831 Duplicate index 'email_address_2' defined on the table 'sales.customers'. This is deprecated and will be disallowed in a future release. Records: 0  Duplicates: 0  Warnings: 1"

DDL
CREATE TABLE `customers` (
  `customer_id` int NOT NULL AUTO_INCREMENT,
  `first_name` varchar(255) DEFAULT NULL,
  `last_name` varchar(255) DEFAULT NULL,
  `email_address` varchar(255) DEFAULT NULL,
  `number_of_complaints` smallint DEFAULT NULL,
  PRIMARY KEY (`customer_id`),
  UNIQUE KEY `email_address` (`email_address`),
  UNIQUE KEY `email_address_2` (`email_address`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci


After dropping index email_address
ALTER TABLE customers
DROP INDEX email_address;

Still one unique key constraint(email_address_2) is applied, let remove that as well

DDL
CREATE TABLE `customers` (
  `customer_id` int NOT NULL AUTO_INCREMENT,
  `first_name` varchar(255) DEFAULT NULL,
  `last_name` varchar(255) DEFAULT NULL,
  `email_address` varchar(255) DEFAULT NULL,
  `number_of_complaints` smallint DEFAULT NULL,
  PRIMARY KEY (`customer_id`),
  UNIQUE KEY `email_address_2` (`email_address`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_c

ALTER TABLE customers
DROP INDEX email_address_2;

DDL
CREATE TABLE `customers` (
  `customer_id` int NOT NULL AUTO_INCREMENT,
  `first_name` varchar(255) DEFAULT NULL,
  `last_name` varchar(255) DEFAULT NULL,
  `email_address` varchar(255) DEFAULT NULL,
  `number_of_complaints` smallint DEFAULT NULL,
  PRIMARY KEY (`customer_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci


Let's play a little with customers table.
CREATE TABLE customers (
    customer_id INT NOT NULL AUTO_INCREMENT,
    first_name VARCHAR(255),
    last_name VARCHAR(255),
    email_address VARCHAR(255),
    number_of_complaints INT,
PRIMARY KEY (customer_id)
);

ALTER TABLE customers
ADD COLUMN gender ENUM('M','F') AFTER last_name;

INSERT INTO customers (first_name, last_name, gender, email_address, number_of_complaints)
VALUES ('Ramesh', 'Kumar', 'M', 'rameshk@ramesha.com',1000);

SELECT * FROM customers;

To get a list of columns in mysql use INFORMATION.SCHEMA
SELECT * FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_NAME='customers';

or to get an empty table with just column names
SELECT * FROM customers WHERE 1=0; -- quick and dirty

DEFAULT Constraint
===================
It is used to add default values to all records of a column.

If we need to add a value other than default value then we will have to specify in separately.

Eg. number_of_complaints column in customers table can be set to 0.

(
	customer_id INT NOT NULL AUTO_INCREMENT,
	first_name VARCHAR(255),
    last_name VARCHAR(255),
    email_address VARCHAR(255),
    number_of_complaints SMALLINT DEFAULT 0,
PRIMARY KEY(customer_id),
UNIQUE KEY(email_address)
);

OR

If we want to add default constraint after creation of table

ALTER TABLE customers
CHANGE COLUMN number_of_complaints number_of_complaints SMALLINT DEFAULT 0;

Test changes by adding a new record:
INSERT INTO customers (first_name, last_name, gender)
VALUES ('Chandu', 'Thakur', 'M');

SELECT * FROM customers;

How can we drop the DEFAULT constraint?
ALTER TABLE customers
ALTER COLUMN number_of_complaints DROP DEFAULT;

NOT NULL Constraint:
====================
In a primary key all records should be not null but in case of unique key duplicate values are not allowed but we can have NULL values.
The 'not null' restriction is applied through NOT NULL constraint.
which means when you insert values in the table, you cannot leave the respective field empty.
If we leave it empty, mysql will display an error.

Let's go with examples:
CREATE TABLE companies
(
	company_id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
	company_name VARCHAR(255) NOT NULL,
    headquarters_phone_number VARCHAR(255)
);

OR
ALTER TABLE companies
CHANGE COLUMN company_name company_name VARCHAR(255) NOT NULL;

MODIFY NOT NULL to NULL (There is nothing like drop NOT NULL Constraint)
ALTER TABLE companies
MODIFY company_name VARCHAR(255) NULL;

Insert values:
INSERT INTO companies (headquarters_phone_number, company_name)
values ('5327385-358', 'Company A');

Select values:
SELECT * FROM companies;

EXERCISE:
ALTER TABLE companies
CHANGE COLUMN headquarters_phone_number headquarters_phone_number VARCHAR(255) NOT NULL;

ALTER TABLE companies
MODIFY headquarters_phone_number VARCHAR(255) NULL;

GOTCHAS of NOT NULL CONSTRAINT:
-------------------------------
Don't confuse a NULL values with a numeral value 0 or a string value NONE.
If a record has 0 value its a valid value and not null value like no_of_complaints
If a record had NONE value its a valid value like in feedback column if a person does not wish to give feedback we can place NONE value.

If the record in no_of_complaints or feedback is empty then we can say it as NULL.


Coding Practices:
Good code is not what computers understand, it's the one that humans understand.

When assigning names to variables or SQL objects, always choose shorter, meaningful names, conveying specific information.
meaningful means pronounceable - where one word per concept has been picked.

[column] names will constitute more then 80% of your code, choose them wisely.

Use uppercase for SQL keywords.

=================
DML Statements===
=================
SELECT
========
It allows to extract complete or a fraction of a dataset.
It is used to retrieve data from db objects, like tables.
Used to query data from a db.

Basic select statement:(But it can become very complex if you are a pro)
select col1, col2.... coln
from tablename;

Practically from keyword is mandatory, it tells us from which table the data is to be retrieved.

When extracting info, SELECT always goes with FROM.

To select first and last name from the employees table.
USE employees;
SELECT
    first_name, last_name
FROM
    employees;


select all records and cols from employees table.
'*' is a wildcard characters which mean all 'all' or 'everything'.
SELECT
    *
FROM
    employees;

Exercise:
-- departments table  dept_name
SELECT
    dept_name
FROM
    departments;

WHERE Clause
-------------
It allows us to set a condition upon which we will specify what part of the data we want to retrieve from the database.

Syntax
SELECT col1, col2.... coln
FROM tablename WHERE condition;

Eg. Select employees from employees table whose first name is Denis.
SELECT
    *
FROM
    employees
WHERE
    first_name = 'Denis';


In above where clause we have use equal '=' operator to match a string.
In SQL, there are many other linking keywords and symbols, called operators, that you can use with the where clause.

Eg:
AND         OR
IN          NOT IN
LIKE        NOT LIKE
BETWEEN
EXISTS      NOT EXISTS
IS NULL     IS NOT NULL
comparison operators etc


AND Operator
============
allows you to logically combine two statements in the condition code block.
It allows us to narrow the output we would like to extract from the data. Hence
AND binds SQL to meet both conditions enlisted in the WHERE clause simultaneously.

Syntax:
SELECT col1, col2.... coln
FROM tablename WHERE condition1 AND cond2;

Eg: Find all employees name 'Saniya' and have gender 'F'
SELECT
    *
FROM
    employees
WHERE
    first_name = 'Saniya' AND gender = 'F';

OR Operator
===========
Applies OR condition

SELECT col1, col2.... coln
FROM tablename WHERE condition1 OR cond2;

Eg: Select emps with firstname as Elvis or Saniya
SELECT
    *
FROM
    employees
WHERE
    first_name = 'Saniya'
        OR first_name = 'Elvis';

Operator Precedence:
--------------------
AND has precedence over OR.

SELECT
    *
FROM
    employees
WHERE
    last_name = 'Denis'
        AND (gender = 'M' OR gender = 'F');

IN and NOT IN
----------------
IN operator can be used along with list to fetch elements IN a column.
We can use OR operator but if there are more than 2 elements to check then we can go with IN operator.
Also, using IN is faster than using OR.

Eg. select all employees whose first name is Cathie, Mark or Nathan.

SELECT
    *
FROM
    employees
WHERE
    first_name IN ('Cathie' , 'Mark', 'Nathan');


Eg of NOT IN:
SELECT
    *
FROM
    employees
WHERE
    first_name NOT IN ('Cathie' , 'Mark', 'Nathan');

LIKE or NOT LIKE
================
It is used for pattern matching.
% - is used for matching 0 or more chars
_ - is used for matching one character

Also, mysql is case insensitive meaning, you can pass 'Mar%' or 'mar%' to search for all strings starting with 'Mar'

Eg:
SELECT
    *
FROM
    employees
WHERE
    first_name LIKE 'Mar%';

SELECT
    *
FROM
    employees
WHERE
    first_name LIKE 'Mar_';

Eg. - Not like
SELECT
    *
FROM
    employees
WHERE
    first_name NOT LIKE '%Ma%';

Retrieve a list with all employees who have been hired in the year 2000.
SELECT
    *
FROM
    employees
WHERE
    hire_date LIKE '2000%';

Retrieve a list with all employees whose employee number is written with 5 characters, and starts with “1000”.
SELECT
    *
FROM
    employees
WHERE
    emp_no LIKE '1000_';

Wildcard Characters:
====================
% - 0 or more matches
_ - 1 match
* - for selecting all columns, can be used to count all rows of a table.






Questions:
Why is char faster than varchar?
