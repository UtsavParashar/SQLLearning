3.2 Entering Queries
Make sure that you are connected to the server, as discussed in the previous section. Doing so does not in itself select any database to work with, but that is okay. At this point, it is more important to find out a little about how to issue queries than to jump right in creating tables, loading data into them, and retrieving data from them. This section describes the basic principles of entering queries, using several queries you can try out to familiarize yourself with how mysql works.

Here is a simple query that asks the server to tell you its version number and the current date. Type it in as shown here following the mysql> prompt and press Enter:
SELECT VERSION(), CURRENT_DATE;

This query illustrates several things about mysql:

A query normally consists of an SQL statement followed by a semicolon. (There are some exceptions where a semicolon may be omitted. QUIT, mentioned earlier, is one of them. We'll get to others later.)

When you issue a query, mysql sends it to the server for execution and displays the results, then prints another mysql> prompt to indicate that it is ready for another query.

mysql displays query output in tabular form (rows and columns). The first row contains labels for the columns. The rows following are the query results. Normally, column labels are the names of the columns you fetch from database tables. If you're retrieving the value of an expression rather than a table column (as in the example just shown), mysql labels the column using the expression itself.

mysql shows how many rows were returned and how long the query took to execute, which gives you a rough idea of server performance. These values are imprecise because they represent wall clock time (not CPU or machine time), and because they are affected by factors such as server load and network latency. (For brevity, the “rows in set” line is sometimes not shown in the remaining examples in this chapter.)

Keywords may be entered in any lettercase. The following queries are equivalent:

mysql> SELECT VERSION(), CURRENT_DATE;
mysql> select version(), current_date;
mysql> SeLeCt vErSiOn(), current_DATE;

Here is another query. It demonstrates that you can use mysql as a simple calculator:
SELECT SIN(PI()/4), 4+1*5;

The queries shown thus far have been relatively short, single-line statements. You can even enter multiple statements on a single line. Just end each one with a semicolon:
SELECT VERSION(); SELECT NOW();

A query need not be given all on a single line, so lengthy queries that require several lines are not a problem. mysql determines where your statement ends by looking for the terminating semicolon, not by looking for the end of the input line. (In other words, mysql accepts free-format input: it collects input lines but does not execute them until it sees the semicolon.)

Here is a simple multiple-line statement:
SELECT user()
,
current_time(),
current_time,
current_timestamp,
current_timestamp(),
current_date,
current_date(),
current_user(),
curtime(),
curdate()
curtime;

In this example, notice how the prompt changes from mysql> to -> after you enter the first line of a multiple-line query. This is how mysql indicates that it has not yet seen a complete statement and is waiting for the rest. The prompt is your friend, because it provides valuable feedback. If you use that feedback, you can always be aware of what mysql is waiting for.

If you decide you do not want to execute a query that you are in the process of entering, cancel it by typing \c:

Here, too, notice the prompt. It switches back to mysql> after you type \c, providing feedback to indicate that mysql is ready for a new query.

The following table shows each of the prompts you may see and summarizes what they mean about the state that mysql is in.

Prompt	Meaning
mysql>	Ready for new query
->	    Waiting for next line of multiple-line query
'>	    Waiting for next line, waiting for completion of a string that began with a single quote (')
">	    Waiting for next line, waiting for completion of a string that began with a double quote (")
`>	    Waiting for next line, waiting for completion of an identifier that began with a backtick (`)
/*>	    Waiting for next line, waiting for completion of a comment that began with /*

Multiple-line statements commonly occur by accident when you intend to issue a query on a single line, but forget the terminating semicolon. In this case, mysql waits for more input:


mysql> SELECT USER()
    ->

If this happens to you (you think you've entered a statement but the only response is a -> prompt), most likely mysql is waiting for the semicolon. If you don't notice what the prompt is telling you, you might sit there for a while before realizing what you need to do. Enter a semicolon to complete the statement, and mysql executes it:

mysql> SELECT USER()
    -> ;

The '> and "> prompts occur during string collection (another way of saying that MySQL is waiting for completion of a string). In MySQL, you can write strings surrounded by either ' or " characters (for example, 'hello' or "goodbye"), and mysql lets you enter strings that span multiple lines. When you see a '> or "> prompt, it means that you have entered a line containing a string that begins with a ' or " quote character, but have not yet entered the matching quote that terminates the string. This often indicates that you have inadvertently left out a quote character. For example:


mysql> SELECT * FROM my_table WHERE name = 'Smith AND age < 30;
    '>

If you enter this SELECT statement, then press Enter and wait for the result, nothing happens. Instead of wondering why this query takes so long, notice the clue provided by the '> prompt. It tells you that mysql expects to see the rest of an unterminated string. (Do you see the error in the statement? The string 'Smith is missing the second single quotation mark.)

At this point, what do you do? The simplest thing is to cancel the query. However, you cannot just type \c in this case, because mysql interprets it as part of the string that it is collecting. Instead, enter the closing quote character (so mysql knows you've finished the string), then type \c:

mysql> SELECT * FROM my_table WHERE name = 'Smith AND age < 30;
    '> '\c
mysql>
The prompt changes back to mysql>, indicating that mysql is ready for a new query.

The `> prompt is similar to the '> and "> prompts, but indicates that you have begun but not completed a backtick-quoted identifier.

It is important to know what the '>, ">, and `> prompts signify, because if you mistakenly enter an unterminated string, any further lines you type appear to be ignored by mysql—including a line containing QUIT. This can be quite confusing, especially if you do not know that you need to supply the terminating quote before you can cancel the current query.

Note
Multiline statements from this point on are written without the secondary (-> or other) prompts, to make it easier to copy and paste the statements to try for yourself.

3.3 Creating and Using a Database
---------------------------------
Once you know how to enter SQL statements, you are ready to access a database.

Suppose that you have several pets in your home (your menagerie) and you would like to keep track of various types of information about them. You can do so by creating tables to hold your data and loading them with the desired information. Then you can answer different sorts of questions about your animals by retrieving data from the tables. This section shows you how to perform the following operations:

Create a database

Create a table

Load data into the table

Retrieve data from the table in various ways

Use multiple tables

The menagerie database is simple (deliberately), but it is not difficult to think of real-world situations in which a similar type of database might be used. For example, a database like this could be used by a farmer to keep track of livestock, or by a veterinarian to keep track of patient records. A menagerie distribution containing some of the queries and sample data used in the following sections can be obtained from the MySQL website. It is available in both compressed tar file and Zip formats at https://dev.mysql.com/doc/.

Use the SHOW statement to find out what databases currently exist on the server:

show DATABASES;
# Database
'information_schema'
'mysql'
'performance_schema'
'sys'
'test'

To get list of all tables in a particular database/table_schema use:
SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA='TEST'; # For test DB
SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA='INFORMATION_SCHEMA'; # for information_schema db

To get list of all tables:
SELECT * FROM INFORMATION_SCHEMA.TABLES;

The mysql database describes user access privileges. The test database often is available as a workspace for users to try things out.

The list of databases displayed by the statement may be different on your machine; SHOW DATABASES does not show databases that you have no privileges for if you do not have the SHOW DATABASES privilege. See Section 13.7.7.14, “SHOW DATABASES Statement”.

If the test database exists, try to access it:

The mysql database describes user access privileges. The test database often is available as a workspace for users to try things out.

The list of databases displayed by the statement may be different on your machine; SHOW DATABASES does not show databases that you have no privileges for if you do not have the SHOW DATABASES privilege. See Section 13.7.7.14, “SHOW DATABASES Statement”.

If the test database exists, try to access it:

mysql> GRANT ALL ON menagerie.* TO 'your_mysql_name'@'your_client_host';
where your_mysql_name is the MySQL user name assigned to you and your_client_host is the host from which you connect to the server.


3.3.1 Creating and Selecting a Database

If the administrator creates your database for you when setting up your permissions, you can begin using it. Otherwise, you need to create it yourself:

CREATE DATABASE menagerie;

Under Unix, database names are case-sensitive (unlike SQL keywords), so you must always refer to your database as menagerie, not as Menagerie, MENAGERIE, or some other variant. This is also true for table names. (Under Windows, this restriction does not apply, although you must refer to databases and tables using the same lettercase throughout a given query. However, for a variety of reasons, the recommended best practice is always to use the same lettercase that was used when the database was created.)

Note
If you get an error such as ERROR 1044 (42000): Access denied for user 'micah'@'localhost' to database 'menagerie' when attempting to create a database, this means that your user account does not have the necessary privileges to do so.

Creating a database does not select it for use; you must do that explicitly. To make menagerie the current database, use this statement:

mysql> USE menagerie
Database changed

Your database needs to be created only once, but you must select it for use each time you begin a mysql session. You can do this by issuing a USE statement as shown in the example. Alternatively, you can select the database on the command line when you invoke mysql. Just specify its name after any connection parameters that you might need to provide. For example:

shell> mysql -h host -u user -p menagerie
Enter password: ********
Important
menagerie in the command just shown is not your password. If you want to supply your password on the command line after the -p option, you must do so with no intervening space (for example, as -ppassword, not as -p password). However, putting your password on the command line is not recommended, because doing so exposes it to snooping by other users logged in on your machine.

Note
You can see at any time which database is currently selected using SELECT DATABASE().
SELECT DATABASE(); # 'menagerie'

3.3.2 Creating a Table
----------------------
Creating the database is the easy part, but at this point it is empty, as SHOW TABLES tells you:

mysql> SHOW TABLES;
Empty set (0.00 sec)

SHOW TABLES;

The harder part is deciding what the structure of your database should be: what tables you need and what columns should be in each of them.

You want a table that contains a record for each of your pets. This can be called the pet table, and it should contain, as a bare minimum, each animal's name. Because the name by itself is not very interesting, the table should contain other information. For example, if more than one person in your family keeps pets, you might want to list each animal's owner. You might also want to record some basic descriptive information such as species and sex.

How about age? That might be of interest, but it is not a good thing to store in a database. Age changes as time passes, which means you'd have to update your records often. Instead, it is better to store a fixed value such as date of birth. Then, whenever you need age, you can calculate it as the difference between the current date and the birth date. MySQL provides functions for doing date arithmetic, so this is not difficult. Storing birth date rather than age has other advantages, too:

You can use the database for tasks such as generating reminders for upcoming pet birthdays. (If you think this type of query is somewhat silly, note that it is the same question you might ask in the context of a business database to identify clients to whom you need to send out birthday greetings in the current week or month, for that computer-assisted personal touch.)

You can calculate age in relation to dates other than the current date. For example, if you store death date in the database, you can easily calculate how old a pet was when it died.

You can probably think of other types of information that would be useful in the pet table, but the ones identified so far are sufficient: name, owner, species, sex, birth, and death.

Use a CREATE TABLE statement to specify the layout of your table:

CREATE TABLE pet (
    name VARCHAR(20),
    owner VARCHAR(20),
    species VARCHAR(20),
    sex ENUM('M', 'F'),
    birth DATE,
    death DATE
);

VARCHAR is a good choice for the name, owner, and species columns because the column values vary in length. The lengths in those column definitions need not all be the same, and need not be 20. You can normally pick any length from 1 to 65535, whatever seems most reasonable to you. If you make a poor choice and it turns out later that you need a longer field, MySQL provides an ALTER TABLE statement.

Several types of values can be chosen to represent sex in animal records, such as 'm' and 'f', or perhaps 'male' and 'female'. It is simplest to use the single characters 'm' and 'f'.

The use of the DATE data type for the birth and death columns is a fairly obvious choice.

Once you have created a table, SHOW TABLES should produce some output:

mysql> SHOW TABLES;
+---------------------+
| Tables in menagerie |
+---------------------+
| pet                 |
+---------------------+
To verify that your table was created the way you expected, use a DESCRIBE statement:

DESCRIBE pet;
# Field, Type, Null, Key, Default, Extra
'name', 'varchar(20)', 'YES', '', NULL, ''
'owner', 'varchar(20)', 'YES', '', NULL, ''
'species', 'varchar(20)', 'YES', '', NULL, ''
'sex', 'enum(\'M\',\'F\')', 'YES', '', NULL, ''
'birth', 'date', 'YES', '', NULL, ''
'death', 'date', 'YES', '', NULL, ''

3.3.3 Loading Data into a Table
After creating your table, you need to populate it. The LOAD DATA and INSERT statements are useful for this.

Suppose that your pet records can be described as shown here. (Observe that MySQL expects dates in 'YYYY-MM-DD' format; this may differ from what you are used to.)

Because you are beginning with an empty table, an easy way to populate it is to create a text file containing a row for each of your animals, then load the contents of the file into the table with a single statement.

You could create a text file pet.txt containing one record per line, with values separated by tabs, and given in the order in which the columns were listed in the CREATE TABLE statement. For missing values (such as unknown sexes or death dates for animals that are still living), you can use NULL values. To represent these in your text file, use \N (backslash, capital-N). For example, the record for Whistler the bird would look like this (where the whitespace between values is a single tab character):

To load a file:
start the mysql server as - (base) Utsavs-MacBook-Air:LaunchDaemons utsav$ mysql -u root -p --local-infile menagerie
mysql> SET GLOBAL local_infile = 1;
mysql> LOAD DATA LOCAL INFILE '/Users/utsav/Desktop/repos/SQLLearning/te.txt' INTO TABLE pet;

If you created the file on Windows with an editor that uses \r\n as a line terminator, you should use this statement instead:

mysql> LOAD DATA LOCAL INFILE '/path/pet.txt' INTO TABLE pet
       LINES TERMINATED BY '\r\n';

(On an Apple machine running macOS, you would likely want to use LINES TERMINATED BY '\r'.)

You can specify the column value separator and end of line marker explicitly in the LOAD DATA statement if you wish, but the defaults are tab and linefeed. These are sufficient for the statement to read the file pet.txt properly.

If the statement fails, it is likely that your MySQL installation does not have local file capability enabled by default. See Section 6.1.6, “Security Considerations for LOAD DATA LOCAL”(https://dev.mysql.com/doc/refman/8.0/en/load-data-local-security.html), for information on how to change this.

When you want to add new records one at a time, the INSERT statement is useful. In its simplest form, you supply values for each column, in the order in which the columns were listed in the CREATE TABLE statement. Suppose that Diane gets a new hamster named “Puffball.” You could add a new record using an INSERT statement like this:

String and date values are specified as quoted strings here. Also, with INSERT, you can insert NULL directly to represent a missing value. You do not use \N like you do with LOAD DATA.

From this example, you should be able to see that there would be a lot more typing involved to load your records initially using several INSERT statements rather than a single LOAD DATA statement.

Load a csv file -
SET GLOBAL local_infile = 1;
mysql> LOAD DATA LOCAL INFILE '/Users/utsav/Desktop/repos/SQLLearning/te.csv' INTO TABLE test_csv_load fields terminated by ',';
Query OK, 8 rows affected (0.01 sec)
Records: 8  Deleted: 0  Skipped: 0  Warnings: 0

mysql> select * from test_csv_load;
+----------+--------+---------+------+------------+------------+
| name     | owner  | species | sex  | birth      | death      |
+----------+--------+---------+------+------------+------------+
| Fluffy   | Harold | cat     | F    | 1993-02-04 | NULL       |
| Claws    | Gwen   | cat     | M    | 1994-03-17 | NULL       |
| Buffy    | Harold | dog     | F    | 1989-05-13 | NULL       |
| Fang     | Benny  | dog     | M    | 1990-08-27 | NULL       |
| Bowser   | Diane  | dog     | M    | 1979-08-31 | 1995-07-29 |
| Chirpy   | Gwen   | bird    | F    | 1998-09-11 | NULL       |
| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |
| Slim     | Benny  | snake   | M    | 1996-04-29 | NULL       |
+----------+--------+---------+------+------------+------------+
8 rows in set (0.00 sec)

3.3.4 Retrieving Information from a Table
------------------------------------------
The SELECT statement is used to pull information from a table. The general form of the statement is:

SELECT what_to_select
FROM which_table
WHERE conditions_to_satisfy;
what_to_select indicates what you want to see. This can be a list of columns, or * to indicate “all columns.” which_table indicates the table from which you want to retrieve data. The WHERE clause is optional. If it is present, conditions_to_satisfy specifies one or more conditions that rows must satisfy to qualify for retrieval.

3.3.4.1 Selecting All Data

The simplest form of SELECT retrieves everything from a table:
SELECT * FROM pet;

This form of SELECT uses *, which is shorthand for “select all columns.” This is useful if you want to review your entire table, for example, after you've just loaded it with your initial data set. For example, you may happen to think that the birth date for Bowser doesn't seem quite right. Consulting your original pedigree papers, you find that the correct birth year should be 1989, not 1979.

There are at least two ways to fix this:

Edit the file pet.txt to correct the error, then empty the table and reload it using DELETE and LOAD DATA:

mysql> select * from pet;                                                                                            +----------+--------+---------+------+------------+------------+
| name     | owner  | species | sex  | birth      | death      |
+----------+--------+---------+------+------------+------------+
| Fluffy   | Harold | cat     | F    | 1993-02-04 | NULL       |
| Claws    | Gwen   | cat     | M    | 1994-03-17 | NULL       |
| Buffy    | Harold | dog     | F    | 1989-05-13 | NULL       |
| Fang     | Benny  | dog     | M    | 1990-08-27 | NULL       |
| Bowser   | Diane  | dog     | M    | 1989-08-31 | 1995-07-29 |
| Chirpy   | Gwen   | bird    | F    | 1998-09-11 | NULL       |
| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |
| Slim     | Benny  | snake   | M    | 1996-04-29 | NULL       |
+----------+--------+---------+------+------------+------------+

mysql> DELETE FROM pet;
mysql> LOAD DATA LOCAL INFILE 'pet.txt' INTO TABLE pet;
However, if you do this, you must also re-enter the record for Puffball.

Fix only the erroneous record with an UPDATE statement:

mysql> UPDATE pet SET birth = '1989-08-31' WHERE name = 'Bowser';
The UPDATE changes only the record in question and does not require you to reload the table.

There is an exception to the principle that SELECT * selects all columns. If a table contains invisible columns, * does not include them. For more information, see Section 13.1.20.10, “Invisible Columns”.

3.3.4.2 Selecting Particular Rows

As shown in the preceding section, it is easy to retrieve an entire table. Just omit the WHERE clause from the SELECT statement. But typically you don't want to see the entire table, particularly when it becomes large. Instead, you're usually more interested in answering a particular question, in which case you specify some constraints on the information you want. Let's look at some selection queries in terms of questions about your pets that they answer.

You can select only particular rows from your table. For example, if you want to verify the change that you made to Bowser's birth date, select Bowser's record like this:

mysql> SELECT * FROM pet WHERE name = 'Bowser';
+--------+-------+---------+------+------------+------------+
| name   | owner | species | sex  | birth      | death      |
+--------+-------+---------+------+------------+------------+
| Bowser | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+-------+---------+------+------------+------------+
The output confirms that the year is correctly recorded as 1989, not 1979.

String comparisons normally are case-insensitive, so you can specify the name as 'bowser', 'BOWSER', and so forth. The query result is the same.

You can specify conditions on any column, not just name. For example, if you want to know which animals were born during or after 1998, test the birth column:

mysql> SELECT * FROM pet WHERE birth >= '1998-1-1';
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Puffball | Diane | hamster | f    | 1999-03-30 | NULL  |
+----------+-------+---------+------+------------+-------+
You can combine conditions, for example, to locate female dogs:

mysql> SELECT * FROM pet WHERE species = 'dog' AND sex = 'f';
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
The preceding query uses the AND logical operator. There is also an OR operator:

mysql> SELECT * FROM pet WHERE species = 'snake' OR species = 'bird';
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL  |
| Slim     | Benny | snake   | m    | 1996-04-29 | NULL  |
+----------+-------+---------+------+------------+-------+
AND and OR may be intermixed, although AND has higher precedence than OR. If you use both operators, it is a good idea to use parentheses to indicate explicitly how conditions should be grouped:

mysql> SELECT * FROM pet WHERE (species = 'cat' AND sex = 'm')
       OR (species = 'dog' AND sex = 'f');
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+

3.3.4.3 Selecting Particular Columns
------------------------------------
If you do not want to see entire rows from your table, just name the columns in which you are interested, separated by commas. For example, if you want to know when your animals were born, select the name and birth columns:

mysql> SELECT name, birth FROM pet;
+----------+------------+
| name     | birth      |
+----------+------------+
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Buffy    | 1989-05-13 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Puffball | 1999-03-30 |
+----------+------------+
To find out who owns pets, use this query:

mysql> SELECT owner FROM pet;
+--------+
| owner  |
+--------+
| Harold |
| Gwen   |
| Harold |
| Benny  |
| Diane  |
| Gwen   |
| Gwen   |
| Benny  |
| Diane  |
+--------+
Notice that the query simply retrieves the owner column from each record, and some of them appear more than once. To minimize the output, retrieve each unique output record just once by adding the keyword DISTINCT:

mysql> SELECT DISTINCT owner FROM pet;
+--------+
| owner  |
+--------+
| Benny  |
| Diane  |
| Gwen   |
| Harold |
+--------+
You can use a WHERE clause to combine row selection with column selection. For example, to get birth dates for dogs and cats only, use this query:

mysql> SELECT name, species, birth FROM pet
       WHERE species = 'dog' OR species = 'cat';
+--------+---------+------------+
| name   | species | birth      |
+--------+---------+------------+
| Fluffy | cat     | 1993-02-04 |
| Claws  | cat     | 1994-03-17 |
| Buffy  | dog     | 1989-05-13 |
| Fang   | dog     | 1990-08-27 |
| Bowser | dog     | 1989-08-31 |
+--------+---------+------------+

3.3.4.4 Sorting Rows

You may have noticed in the preceding examples that the result rows are displayed in no particular order. It is often easier to examine query output when the rows are sorted in some meaningful way. To sort a result, use an ORDER BY clause.

Here are animal birthdays, sorted by date:

mysql> SELECT name, birth FROM pet ORDER BY birth;
+----------+------------+
| name     | birth      |
+----------+------------+
| Buffy    | 1989-05-13 |
| Bowser   | 1989-08-31 |
| Fang     | 1990-08-27 |
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Slim     | 1996-04-29 |
| Whistler | 1997-12-09 |
| Chirpy   | 1998-09-11 |
| Puffball | 1999-03-30 |
+----------+------------+
On character type columns, sorting—like all other comparison operations—is normally performed in a case-insensitive fashion. This means that the order is undefined for columns that are identical except for their case. You can force a case-sensitive sort for a column by using BINARY like so: ORDER BY BINARY col_name.

mysql> select * from pet order by BINARY name;
+----------+--------+---------+------+------------+------------+
| name     | owner  | species | sex  | birth      | death      |
+----------+--------+---------+------+------------+------------+
| Bowser   | Diane  | dog     | M    | 1989-08-31 | 1995-07-29 |
| Buffy    | Harold | dog     | F    | 1989-05-13 | NULL       |
| Chirpy   | Gwen   | bird    | F    | 1998-09-11 | NULL       |
| Claws    | Gwen   | cat     | M    | 1994-03-17 | NULL       |
| Fang     | Benny  | dog     | M    | 1990-08-27 | NULL       |
| Fluffy   | Harold | cat     | F    | 1993-02-04 | NULL       |
| Slim     | Benny  | snake   | M    | 1996-04-29 | NULL       |
| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |
| bruzo    | Chinku | dog     | M    | 2019-01-04 | NULL       |
+----------+--------+---------+------+------------+------------+
9 rows in set (0.00 sec)

You can sort on multiple columns, and you can sort different columns in different directions. For example, to sort by type of animal in ascending order, then by birth date within animal type in descending order (youngest animals first), use the following query:

mysql> select name, species, birth from pet
    -> order by species, birth desc;
+----------+---------+------------+
| name     | species | birth      |
+----------+---------+------------+
| Chirpy   | bird    | 1998-09-11 |
| Whistler | bird    | 1997-12-09 |
| Claws    | cat     | 1994-03-17 |
| Fluffy   | cat     | 1993-02-04 |
| bruzo    | dog     | 2019-01-04 |
| Fang     | dog     | 1990-08-27 |
| Bowser   | dog     | 1989-08-31 |
| Buffy    | dog     | 1989-05-13 |
| Slim     | snake   | 1996-04-29 |
+----------+---------+------------+

NOTE - The DESC keyword applies only to the column name immediately preceding it (birth); it does not affect the species column sort order.

If we need both species and birth in descending order, then desc with each col
mysql> select name, species, birth from pet  order by species desc, birth desc;
+----------+---------+------------+
| name     | species | birth      |
+----------+---------+------------+
| Slim     | snake   | 1996-04-29 |
| bruzo    | dog     | 2019-01-04 |
| Fang     | dog     | 1990-08-27 |
| Bowser   | dog     | 1989-08-31 |
| Buffy    | dog     | 1989-05-13 |
| Claws    | cat     | 1994-03-17 |
| Fluffy   | cat     | 1993-02-04 |
| Chirpy   | bird    | 1998-09-11 |
| Whistler | bird    | 1997-12-09 |
+----------+---------+------------+
9 rows in set (0.00 sec)


mysql> describe pet;
+---------+---------------+------+-----+---------+-------+
| Field   | Type          | Null | Key | Default | Extra |
+---------+---------------+------+-----+---------+-------+
| name    | varchar(20)   | YES  |     | NULL    |       |
| owner   | varchar(20)   | YES  |     | NULL    |       |
| species | varchar(20)   | YES  |     | NULL    |       |
| sex     | enum('M','F') | YES  |     | NULL    |       |
| birth   | date          | YES  |     | NULL    |       |
| death   | date          | YES  |     | NULL    |       |
+---------+---------------+------+-----+---------+-------+
6 rows in set (0.01 sec)

NOTE - describe is equivalent to meta in kdb

3.3.4.5 Date Calculations
-------------------------

MySQL provides several functions that you can use to perform calculations on dates, for example, to calculate ages or extract parts of dates.

To determine how many years old each of your pets is, use the TIMESTAMPDIFF() function. Its arguments are the unit in which you want the result expressed, and the two dates for which to take the difference. The following query shows, for each pet, the birth date, the current date, and the age in years. An alias (age) is used to make the final output column label more meaningful.

mysql> select name, birth, curdate(), timestampdiff(YEAR,birth,curdate()) as age from pet order by age desc;
+----------+------------+------------+------+
| name     | birth      | curdate()  | age  |
+----------+------------+------------+------+
| Buffy    | 1989-05-13 | 2021-07-05 |   32 |
| Bowser   | 1989-08-31 | 2021-07-05 |   31 |
| Fang     | 1990-08-27 | 2021-07-05 |   30 |
| Fluffy   | 1993-02-04 | 2021-07-05 |   28 |
| Claws    | 1994-03-17 | 2021-07-05 |   27 |
| Slim     | 1996-04-29 | 2021-07-05 |   25 |
| Whistler | 1997-12-09 | 2021-07-05 |   23 |
| Chirpy   | 1998-09-11 | 2021-07-05 |   22 |
| bruzo    | 2019-01-04 | 2021-07-05 |    2 |
+----------+------------+------------+------+
9 rows in set (0.00 sec)

A similar query can be used to determine age at death for animals that have died. You determine which animals these are by checking whether the death value is NULL. Then, for those with non-NULL values, compute the difference between the death and birth values:
mysql> select name, birth, death, timestampdiff(YEAR, birth, death) as age from pet where death IS NOT NULL order by name;
+--------+------------+------------+------+
| name   | birth      | death      | age  |
+--------+------------+------------+------+
| Bowser | 1989-08-31 | 1995-07-29 |    5 |
+--------+------------+------------+------+

Similarly if we want age of species which are alive.
mysql> select name, birth, death, timestampdiff(YEAR, birth, curdate()) as age from pet where death IS NULL order by name;
+----------+------------+-------+------+
| name     | birth      | death | age  |
+----------+------------+-------+------+
| bruzo    | 2019-01-04 | NULL  |    2 |
| Buffy    | 1989-05-13 | NULL  |   32 |
| Chirpy   | 1998-09-11 | NULL  |   22 |
| Claws    | 1994-03-17 | NULL  |   27 |
| Fang     | 1990-08-27 | NULL  |   30 |
| Fluffy   | 1993-02-04 | NULL  |   28 |
| Slim     | 1996-04-29 | NULL  |   25 |
| Whistler | 1997-12-09 | NULL  |   23 |
+----------+------------+-------+------+

The query uses death IS NOT NULL rather than death <> NULL because NULL is a special value that cannot be compared using the usual comparison operators. This is discussed later. See Section 3.3.4.6, “Working with NULL Values”.

What if you want to know which animals have birthdays next month? For this type of calculation, year and day are irrelevant; you simply want to extract the month part of the birth column. MySQL provides several functions for extracting parts of dates, such as YEAR(), MONTH(), and DAYOFMONTH(). MONTH() is the appropriate function here. To see how it works, run a simple query that displays the value of both birth and MONTH(birth):

Get complete birth details
mysql> select birth, year(birth), month(birth), dayofmonth(birth), weekday(birth), dayname(birth) from pet;
+------------+-------------+--------------+-------------------+----------------+----------------+
| birth      | year(birth) | month(birth) | dayofmonth(birth) | weekday(birth) | dayname(birth) |
+------------+-------------+--------------+-------------------+----------------+----------------+
| 1993-02-04 |        1993 |            2 |                 4 |              3 | Thursday       |
| 1994-03-17 |        1994 |            3 |                17 |              3 | Thursday       |
| 1989-05-13 |        1989 |            5 |                13 |              5 | Saturday       |
| 1990-08-27 |        1990 |            8 |                27 |              0 | Monday         |
| 1989-08-31 |        1989 |            8 |                31 |              3 | Thursday       |
| 1998-09-11 |        1998 |            9 |                11 |              4 | Friday         |
| 1997-12-09 |        1997 |           12 |                 9 |              1 | Tuesday        |
| 1996-04-29 |        1996 |            4 |                29 |              0 | Monday         |
| 2019-01-04 |        2019 |            1 |                 4 |              4 | Friday         |
+------------+-------------+--------------+-------------------+----------------+----------------+

Get the pets whose birthday is in coming month.
mysql> select name, birth, species from pet where month(birth)=(month(curdate())+1);
+--------+------------+---------+
| name   | birth      | species |
+--------+------------+---------+
| Fang   | 1990-08-27 | dog     |
| Bowser | 1989-08-31 | dog     |
+--------+------------+---------+

Other then using curdate()+1, you can use DATE_ADD()
First let's see few examples of DATE_ADD()
mysql> select DATE_ADD(curdate(),INTERVAL 1 MONTH);
+--------------------------------------+
| DATE_ADD(curdate(),INTERVAL 1 MONTH) |
+--------------------------------------+
| 2021-08-05                           |
+--------------------------------------+
1 row in set (0.00 sec)

mysql> select DATE_ADD(curdate(),INTERVAL 1 DAY);
+------------------------------------+
| DATE_ADD(curdate(),INTERVAL 1 DAY) |
+------------------------------------+
| 2021-07-06                         |
+------------------------------------+
1 row in set (0.00 sec)

mysql> select DATE_ADD(curdate(),INTERVAL 1 YEAR);
+-------------------------------------+
| DATE_ADD(curdate(),INTERVAL 1 YEAR) |
+-------------------------------------+
| 2022-07-05                          |
+-------------------------------------+
1 row in set (0.00 sec)

Query - mysql> select name, birth, species from pet where month(birth)=(month(DATE_ADD(curdate(),INTERVAL 1 MONTH)));
        +--------+------------+---------+
        | name   | birth      | species |
        +--------+------------+---------+
        | Fang   | 1990-08-27 | dog     |
        | Bowser | 1989-08-31 | dog     |
        +--------+------------+---------+



But the above code will fail if the current month is december, for that we can use:
mysql> select name, birth, species from pet where month(birth)=(month(DATE_ADD('2020-12-01',INTERVAL 1 MONTH)));
+-------+------------+---------+
| name  | birth      | species |
+-------+------------+---------+
| bruzo | 2019-01-04 | dog     |
+-------+------------+---------+

You can write the query so that it works no matter what the current month is, so that you do not have to use the number for a particular month. DATE_ADD() enables you to add a time interval to a given date. If you add a month to the value of CURDATE(), then extract the month part with MONTH(), the result produces the month in which to look for birthdays:

mysql> SELECT name, birth FROM pet
       WHERE MONTH(birth) = MONTH(DATE_ADD(CURDATE(),INTERVAL 1 MONTH));

A different way to accomplish the same task is to add 1 to get the next month after the current one after using the modulo function (MOD) to wrap the month value to 0 if it is currently 12:


mysql> select name, birth, species from pet where month(birth)=MOD(MONTH(CURDATE()), 12)+1;
+--------+------------+---------+
| name   | birth      | species |
+--------+------------+---------+
| Fang   | 1990-08-27 | dog     |
| Bowser | 1989-08-31 | dog     |
+--------+------------+---------+
2 rows in set (0.00 sec)

mysql> select name, birth, species from pet where month(birth)=MOD(MONTH('2020-12-01'), 12)+1;
+-------+------------+---------+
| name  | birth      | species |
+-------+------------+---------+
| bruzo | 2019-01-04 | dog     |
+-------+------------+---------+
1 row in set (0.00 sec)

MONTH() returns a number between 1 and 12. And MOD(something,12) returns a number between 0 and 11. So the addition has to be after the MOD(), otherwise we would go from November (11) to January (1).

If a calculation uses invalid dates, the calculation fails and produces warnings:
mysql> select '2021-06-04' + 1;
+------------------+
| '2021-06-04' + 1 |
+------------------+
|             2022 |
+------------------+
1 row in set, 1 warning (0.00 sec)

mysql> select '2021-06-04' + INTERVAL 1 DAY;
+-------------------------------+
| '2021-06-04' + INTERVAL 1 DAY |
+-------------------------------+
| 2021-06-05                    |
+-------------------------------+
1 row in set (0.00 sec)

mysql> select '2021-06-32' + INTERVAL 1 DAY;
+-------------------------------+
| '2021-06-32' + INTERVAL 1 DAY |
+-------------------------------+
| NULL                          |
+-------------------------------+
1 row in set, 1 warning (0.00 sec)

mysql> show warnings;
+---------+------+----------------------------------------+
| Level   | Code | Message                                |
+---------+------+----------------------------------------+
| Warning | 1292 | Incorrect datetime value: '2021-06-32' |
+---------+------+----------------------------------------+
1 row in set (0.00 sec)

3.3.4.6 Working with NULL Values
--------------------------------
The NULL value can be surprising until you get used to it. Conceptually, NULL means “a missing unknown value” and it is treated somewhat differently from other values.

To test for NULL, use the IS NULL and IS NOT NULL operators, as shown here:

mysql> SELECT 2 IS NULL, 2 IS NOT NULL;
+-----------+---------------+
| 2 IS NULL | 2 IS NOT NULL |
+-----------+---------------+
|         0 |             1 |
+-----------+---------------+

You cannot use arithmetic comparison operators such as =, <, or <> to test for NULL. To demonstrate this for yourself, try the following query:
mysql> select 1=NULL, 1<>NULL, 1<NULL, 1>NULL;
+--------+---------+--------+--------+
| 1=NULL | 1<>NULL | 1<NULL | 1>NULL |
+--------+---------+--------+--------+
|   NULL |    NULL |   NULL |   NULL |
+--------+---------+--------+--------+

Because the result of any arithmetic comparison with NULL is also NULL, you cannot obtain any meaningful results from such comparisons.

In MySQL, 0 or NULL means false and anything else means true. The default truth value from a boolean operation is 1.

This special treatment of NULL is why, in the previous section, it was necessary to determine which animals are no longer alive using death IS NOT NULL instead of death <> NULL.

Two NULL values are regarded as equal in a GROUP BY.

When doing an ORDER BY, NULL values are presented first if you do ORDER BY ... ASC and last if you do ORDER BY ... DESC.

mysql> SELECT 2 OR NULL;
+-----------+
| 2 OR NULL |
+-----------+
|         1 |
+-----------+
1 row in set (0.00 sec)

mysql> SELECT 0 OR NULL;
+-----------+
| 0 OR NULL |
+-----------+
|      NULL |
+-----------+
1 row in set (0.00 sec)

mysql> select 2 AND NULL;
+------------+
| 2 AND NULL |
+------------+
|       NULL |
+------------+
1 row in set (0.01 sec)

A common error when working with NULL is to assume that it is not possible to insert a zero or an empty string into a column defined as NOT NULL, but this is not the case. These are in fact values, whereas NULL means “not having a value.” You can test this easily enough by using IS [NOT] NULL as shown:
mysql> SELECT 0 IS NULL, 0 IS NOT NULL, '' IS NULL, '' IS NOT NULL;
+-----------+---------------+------------+----------------+
| 0 IS NULL | 0 IS NOT NULL | '' IS NULL | '' IS NOT NULL |
+-----------+---------------+------------+----------------+
|         0 |             1 |          0 |              1 |
+-----------+---------------+------------+----------------+

B.3.4.3 Problems with NULL Values
---------------------------------
The concept of the NULL value is a common source of confusion for newcomers to SQL, who often think that NULL is the same thing as an empty string ''. This is not the case. For example, the following statements are completely different:

mysql> INSERT INTO my_table (phone) VALUES (NULL);
mysql> INSERT INTO my_table (phone) VALUES ('');
Both statements insert a value into the phone column, but the first inserts a NULL value and the second inserts an empty string. The meaning of the first can be regarded as “phone number is not known” and the meaning of the second can be regarded as “the person is known to have no phone, and thus no phone number.”

In SQL, the NULL value is never true in comparison to any other value, even NULL. An expression that contains NULL always produces a NULL value unless otherwise indicated in the documentation for the operators and functions involved in the expression. All columns in the following example return NULL:
mysql> SELECT NULL, 1+NULL, CONCAT('Invisible', NULL);
+------+--------+---------------------------+
| NULL | 1+NULL | CONCAT('Invisible', NULL) |
+------+--------+---------------------------+
| NULL |   NULL | NULL                      |
+------+--------+---------------------------+

To search for column values that are NULL, you cannot use an expr = NULL test. The following statement returns no rows, because expr = NULL is never true for any expression:
SELECT * FROM my_table WHERE phone = NULL;

To look for NULL values, you must use the IS NULL test. The following statements show how to find the NULL phone number and the empty phone number:

mysql> SELECT * FROM my_table WHERE phone IS NULL;
mysql> SELECT * FROM my_table WHERE phone = '';

You can add an index on a column that can have NULL values if you are using the MyISAM, InnoDB, or MEMORY storage engine. Otherwise, you must declare an indexed column NOT NULL, and you cannot insert NULL into the column.

When reading data with LOAD DATA, empty or missing columns are updated with ''. To load a NULL value into a column, use \N in the data file. The literal word NULL may also be used under some circumstances.

When using DISTINCT, GROUP BY, or ORDER BY, all NULL values are regarded as equal.

When using ORDER BY, NULL values are presented first, or last if you specify DESC to sort in descending order.

Aggregate (group) functions such as COUNT(), MIN(), and SUM() ignore NULL values. The exception to this is COUNT(*), which counts rows and not individual column values. For example, the following statement produces two counts. The first is a count of the number of rows in the table, and the second is a count of the number of non-NULL values in the age column:
mysql> SELECT COUNT(*), COUNT(SEX) FROM pet;
+----------+------------+
| COUNT(*) | COUNT(SEX) |
+----------+------------+
|        9 |          8 |
+----------+------------+
For some data types, MySQL handles NULL values specially. If you insert NULL into a TIMESTAMP column, the current date and time is inserted. If you insert NULL into an integer or floating-point column that has the AUTO_INCREMENT attribute, the next number in the sequence is inserted.

3.3.4.7 Pattern Matching
========================
MySQL provides standard SQL pattern matching as well as a form of pattern matching based on extended regular expressions similar to those used by Unix utilities such as vi, grep, and sed.

SQL pattern matching enables you to use _ to match any single character and % to match an arbitrary number of characters (including zero characters). In MySQL, SQL patterns are case-insensitive by default. Some examples are shown here. Do not use = or <> when you use SQL patterns. Use the LIKE or NOT LIKE comparison operators instead.

To find names beginning with b:
mysql> SELECT * FROM pet WHERE name LIKE 'B%';
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | F    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | M    | 1989-08-31 | 1995-07-29 |
| bruzo  | Chinku | dog     | M    | 2019-01-04 | NULL       |
+--------+--------+---------+------+------------+------------+
3 rows in set (0.01 sec)

mysql> SELECT * FROM pet WHERE name LIKE BINARY 'B%';
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | F    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | M    | 1989-08-31 | 1995-07-29 |
+--------+--------+---------+------+------------+------------+
2 rows in set (0.00 sec)

To find names ending with fy:
mysql> SELECT * FROM pet WHERE name LIKE '%FY';
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | F    | 1993-02-04 | NULL  |
| Buffy  | Harold | dog     | F    | 1989-05-13 | NULL  |
+--------+--------+---------+------+------------+-------+
2 rows in set (0.00 sec)

To find names containing a w:
mysql> SELECT * FROM pet WHERE name LIKE '%w%';
+----------+-------+---------+------+------------+------------+
| name     | owner | species | sex  | birth      | death      |
+----------+-------+---------+------+------------+------------+
| Claws    | Gwen  | cat     | M    | 1994-03-17 | NULL       |
| Bowser   | Diane | dog     | M    | 1989-08-31 | 1995-07-29 |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL       |
+----------+-------+---------+------+------------+------------+
3 rows in set (0.00 sec)

To find names containing exactly five characters, use five instances of the _ pattern character:
mysql> SELECT * FROM pet WHERE name LIKE '_____';
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | M    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | F    | 1989-05-13 | NULL  |
| bruzo | Chinku | dog     | M    | 2019-01-04 | NULL  |
+-------+--------+---------+------+------------+-------+
3 rows in set (0.00 sec)

The other type of pattern matching provided by MySQL uses extended regular expressions. When you test for a match for this type of pattern, use the REGEXP_LIKE() function (or the REGEXP or RLIKE operators, which are synonyms for REGEXP_LIKE()).

The following list describes some characteristics of extended regular expressions:

. matches any single character.

A character class [...] matches any character within the brackets. For example, [abc] matches a, b, or c. To name a range of characters, use a dash. [a-z] matches any letter, whereas [0-9] matches any digit.

* matches zero or more instances of the thing preceding it. For example, x* matches any number of x characters, [0-9]* matches any number of digits, and .* matches any number of anything.

A regular expression pattern match succeeds if the pattern matches anywhere in the value being tested. (This differs from a LIKE pattern match, which succeeds only if the pattern matches the entire value.)

To anchor a pattern so that it must match the beginning or end of the value being tested, use ^ at the beginning or $ at the end of the pattern.

To demonstrate how extended regular expressions work, the LIKE queries shown previously are rewritten here to use REGEXP_LIKE().

To find names beginning with b, use ^ to match the beginning of the name:

mysql> select * from pet where REGEXP_LIKE(name, '^b' COLLATE utf8mb4_0900_as_cs);
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| bruzo | Chinku | dog     | M    | 2019-01-04 | NULL  |
+-------+--------+---------+------+------------+-------+

mysql> select * from pet where REGEXP_LIKE(name, BINARY '^b');
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| bruzo | Chinku | dog     | M    | 2019-01-04 | NULL  |
+-------+--------+---------+------+------------+-------+

mysql> select * from pet where REGEXP_LIKE(name, '^b');
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | F    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | M    | 1989-08-31 | 1995-07-29 |
| bruzo  | Chinku | dog     | M    | 2019-01-04 | NULL       |
+--------+--------+---------+------+------------+------------+

mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, '^b', 'c');
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| bruzo | Chinku | dog     | M    | 2019-01-04 | NULL  |
+-------+--------+---------+------+------------+-------+
1 row in set (0.00 sec)

To find names ending with fy, use $ to match the end of the name:
mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, 'fy$');
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | F    | 1993-02-04 | NULL  |
| Buffy  | Harold | dog     | F    | 1989-05-13 | NULL  |
+--------+--------+---------+------+------------+-------+

To find names containing a w, use this query:
mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, 'w');
+----------+-------+---------+------+------------+------------+
| name     | owner | species | sex  | birth      | death      |
+----------+-------+---------+------+------------+------------+
| Claws    | Gwen  | cat     | M    | 1994-03-17 | NULL       |
| Bowser   | Diane | dog     | M    | 1989-08-31 | 1995-07-29 |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL       |
+----------+-------+---------+------+------------+------------+

mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, BINARY 'w');
+--------+-------+---------+------+------------+------------+
| name   | owner | species | sex  | birth      | death      |
+--------+-------+---------+------+------------+------------+
| Claws  | Gwen  | cat     | M    | 1994-03-17 | NULL       |
| Bowser | Diane | dog     | M    | 1989-08-31 | 1995-07-29 |
+--------+-------+---------+------+------------+------------+
2 rows in set (0.00 sec)

mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, 'w', 'c');
+--------+-------+---------+------+------------+------------+
| name   | owner | species | sex  | birth      | death      |
+--------+-------+---------+------+------------+------------+
| Claws  | Gwen  | cat     | M    | 1994-03-17 | NULL       |
| Bowser | Diane | dog     | M    | 1989-08-31 | 1995-07-29 |
+--------+-------+---------+------+------------+------------+
2 rows in set (0.00 sec)

Because a regular expression pattern matches if it occurs anywhere in the value, it is not necessary in the previous query to put a wildcard on either side of the pattern to get it to match the entire value as would be true with an SQL pattern.

To find names containing exactly five characters, use ^ and $ to match the beginning and end of the name, and five instances of . in between:
mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, '^.....$');
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | M    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | F    | 1989-05-13 | NULL  |
| bruzo | Chinku | dog     | M    | 2019-01-04 | NULL  |
+-------+--------+---------+------+------------+-------+

You could also write the previous query using the {n} (“repeat-n-times”) operator:
mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, '^.{5}$');
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | M    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | F    | 1989-05-13 | NULL  |
| bruzo | Chinku | dog     | M    | 2019-01-04 | NULL  |
+-------+--------+---------+------+------------+-------+

mysql> SELECT * FROM pet WHERE REGEXP_LIKE(name, '^.{4,6}$');
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Fluffy | Harold | cat     | F    | 1993-02-04 | NULL       |
| Claws  | Gwen   | cat     | M    | 1994-03-17 | NULL       |
| Buffy  | Harold | dog     | F    | 1989-05-13 | NULL       |
| Fang   | Benny  | dog     | M    | 1990-08-27 | NULL       |
| Bowser | Diane  | dog     | M    | 1989-08-31 | 1995-07-29 |
| Chirpy | Gwen   | bird    | F    | 1998-09-11 | NULL       |
| Slim   | Benny  | snake   | M    | 1996-04-29 | NULL       |
| bruzo  | Chinku | dog     | M    | 2019-01-04 | NULL       |
+--------+--------+---------+------+------------+------------+

12.8.2 Regular Expressions
---------------------------
Table 12.14 Regular Expression Functions and Operators

Name	            Description
NOT REGEXP	        Negation of REGEXP
REGEXP	            Whether string matches regular expression
REGEXP_INSTR()	    Starting index of substring matching regular expression
REGEXP_LIKE()	    Whether string matches regular expression
REGEXP_REPLACE()	Replace substrings matching regular expression
REGEXP_SUBSTR()	    Return substring matching regular expression
RLIKE	            Whether string matches regular expression

A regular expression is a powerful way of specifying a pattern for a complex search. This section discusses the functions and operators available for regular expression matching and illustrates, with examples, some of the special characters and constructs that can be used for regular expression operations

MySQL implements regular expression support using International Components for Unicode (ICU), which provides full Unicode support and is multibyte safe.

Regular Expression Function and Operator Descriptions
======================================================
expr NOT REGEXP pat, expr NOT RLIKE pat
This is the same as NOT (expr REGEXP pat).
expr REGEXP pat, expr RLIKE pat
Returns 1 if the string expr matches the regular expression specified by the pattern pat, 0 otherwise. If expr or pat is NULL, the return value is NULL.
REGEXP and RLIKE are synonyms for REGEXP_LIKE().
For additional information about how matching occurs, see the description for REGEXP_LIKE().

mysql> SELECT 'Michael!' REGEXP '.*';
+------------------------+
| 'Michael!' REGEXP '.*' |
+------------------------+
|                      1 |
+------------------------+
1 row in set (0.00 sec)

mysql> SELECT 'Michael!' RLIKE '.*';
+-----------------------+
| 'Michael!' RLIKE '.*' |
+-----------------------+
|                     1 |
+-----------------------+
1 row in set (0.02 sec)

mysql> select 'new*\n*line' REGEXP '.*';
+---------------------------+
| 'new*\n*line' REGEXP '.*' |
+---------------------------+
|                         1 |
+---------------------------+
1 row in set (0.00 sec)

mysql> select 'new*\n*line' REGEXP 'new\\*.\\*line';
+---------------------------------------+
| 'new*\n*line' REGEXP 'new\\*.\\*line' |
+---------------------------------------+
|                                     0 |
+---------------------------------------+
1 row in set (0.01 sec)

mysql> select 'a' regexp '^[a-d]';
+---------------------+
| 'a' regexp '^[a-d]' |
+---------------------+
|                   1 |
+---------------------+
1 row in set (0.00 sec)

mysql> select 'a' regexp 'A', 'a' regexp binary 'A';
+----------------+-----------------------+
| 'a' regexp 'A' | 'a' regexp binary 'A' |
+----------------+-----------------------+
|              1 |                     0 |
+----------------+-----------------------+

REGEXP_INSTR(expr, pat[, pos[, occurrence[, return_option[, match_type]]]])
-----------------------------------------------------------------------------
Returns the starting index of the substring of the string expr that matches the regular expression specified by the pattern pat, 0 if there is no match. If expr or pat is NULL, the return value is NULL. Character indexes begin at 1.

REGEXP_INSTR() takes these optional arguments:

pos: The position in expr at which to start the search. If omitted, the default is 1.

occurrence: Which occurrence of a match to search for. If omitted, the default is 1.

return_option: Which type of position to return. If this value is 0, REGEXP_INSTR() returns the position of the matched substring's first character. If this value is 1, REGEXP_INSTR() returns the position following the matched substring. If omitted, the default is 0.

match_type: A string that specifies how to perform matching. The meaning is as described for REGEXP_LIKE().

For additional information about how matching occurs, see the description for REGEXP_LIKE().

mysql> select REGEXP_INSTR('dog cat dog', 'dog');
+------------------------------------+
| REGEXP_INSTR('dog cat dog', 'dog') |
+------------------------------------+
|                                  1 |
+------------------------------------+
1 row in set (0.01 sec)

mysql> select REGEXP_INSTR('dog cat dog', 'cat');
+------------------------------------+
| REGEXP_INSTR('dog cat dog', 'cat') |
+------------------------------------+
|                                  5 |
+------------------------------------+
1 row in set (0.00 sec)

mysql> select REGEXP_INSTR('dog cat dog', 'dog', 2);
+---------------------------------------+
| REGEXP_INSTR('dog cat dog', 'dog', 2) |
+---------------------------------------+
|                                     9 |
+---------------------------------------+

mysql> select REGEXP_INSTR('dogdog cat dog', 'dog', 2);                                                                         +------------------------------------------+
| REGEXP_INSTR('dogdog cat dog', 'dog', 2) |
+------------------------------------------+
|                                        4 |
+------------------------------------------+


mysql> select REGEXP_INSTR('AA AAA AAA', 'A{2}');
+------------------------------------+
| REGEXP_INSTR('AA AAA AAA', 'A{2}') |
+------------------------------------+
|                                  1 |
+------------------------------------+
1 row in set (0.00 sec)

mysql> select REGEXP_INSTR('AA AAA AAAA', 'A{3}');
+-------------------------------------+
| REGEXP_INSTR('AA AAA AAAA', 'A{3}') |
+-------------------------------------+
|                                   4 |
+-------------------------------------+
1 row in set (0.00 sec)

mysql> select REGEXP_INSTR('AA AAA AAAA', 'A{4}');
+-------------------------------------+
| REGEXP_INSTR('AA AAA AAAA', 'A{4}') |
+-------------------------------------+
|                                   8 |
+-------------------------------------+

mysql> select REGEXP_INSTR('AA AAA AAAA', 'B{4}');
+-------------------------------------+
| REGEXP_INSTR('AA AAA AAAA', 'B{4}') |
+-------------------------------------+
|                                   0 |
+-------------------------------------+
1 row in set (0.00 sec)

mysql> select REGEXP_INSTR('AA AAA AAAA', 'NULL');
+-------------------------------------+
| REGEXP_INSTR('AA AAA AAAA', 'NULL') |
+-------------------------------------+
|                                   0 |
+-------------------------------------+
1 row in set (0.00 sec)

REGEXP_LIKE(expr, pat[, match_type])
-------------------------------------
Returns 1 if the string expr matches the regular expression specified by the pattern pat, 0 otherwise. If expr or pat is NULL, the return value is NULL.

The pattern can be an extended regular expression, the syntax for which is discussed in Regular Expression Syntax. The pattern need not be a literal string. For example, it can be specified as a string expression or table column.

The optional match_type argument is a string that may contain any or all the following characters specifying how to perform matching:

c: Case-sensitive matching.

i: Case-insensitive matching.

m: Multiple-line mode. Recognize line terminators within the string. The default behavior is to match line terminators only at the start and end of the string expression.

n: The . character matches line terminators. The default is for . matching to stop at the end of a line.

u: Unix-only line endings. Only the newline character is recognized as a line ending by the ., ^, and $ match operators.

If characters specifying contradictory options are specified within match_type, the rightmost one takes precedence.

By default, regular expression operations use the character set and collation of the expr and pat arguments when deciding the type of a character and performing the comparison. If the arguments have different character sets or collations, coercibility rules apply as described in Section 10.8.4, “Collation Coercibility in Expressions”. Arguments may be specified with explicit collation indicators to change comparison behavior.

mysql> select regexp_like('CamelCase', 'CAMELCASE');
+---------------------------------------+
| regexp_like('CamelCase', 'CAMELCASE') |
+---------------------------------------+
|                                     1 |
+---------------------------------------+

mysql> select regexp_like('CamelCase', 'CAMELCASE', 'c');
+--------------------------------------------+
| regexp_like('CamelCase', 'CAMELCASE', 'c') |
+--------------------------------------------+
|                                          0 |
+--------------------------------------------+

mysql> select regexp_like('CamelCase', 'CAMELCASE' COLLATE utf8mb4_0900_as_cs);
+------------------------------------------------------------------+
| regexp_like('CamelCase', 'CAMELCASE' COLLATE utf8mb4_0900_as_cs) |
+------------------------------------------------------------------+
|                                                                0 |
+------------------------------------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like('CamelCase', BINARY 'CAMELCASE');
+----------------------------------------------+
| regexp_like('CamelCase', BINARY 'CAMELCASE') |
+----------------------------------------------+
|                                            0 |
+----------------------------------------------+

match_type may be specified with the c or i characters to override the default case sensitivity. Exception: If either argument is a binary string, the arguments are handled in case-sensitive fashion as binary strings, even if match_type contains the i character.

mysql> select regexp_like('CamelCase', BINARY 'CAMELCASE', 'i');
+---------------------------------------------------+
| regexp_like('CamelCase', BINARY 'CAMELCASE', 'i') |
+---------------------------------------------------+
|                                                 1 |
+---------------------------------------------------+

Note
MySQL uses C escape syntax in strings (for example, \n to represent the newline character). If you want your expr or pat argument to contain a literal \, you must double it. (Unless the NO_BACKSLASH_ESCAPES SQL mode is enabled, in which case no escape character is used.)

REGEXP_REPLACE(expr, pat, repl[, pos[, occurrence[, match_type]]])
--------------------------------------------------------------------
Replaces occurrences in the string expr that match the regular expression specified by the pattern pat with the replacement string repl, and returns the resulting string. If expr, pat, or repl is NULL, the return value is NULL.

REGEXP_REPLACE() takes these optional arguments:

pos: The position in expr at which to start the search. If omitted, the default is 1.

occurrence: Which occurrence of a match to replace. If omitted, the default is 0 (which means “replace all occurrences”).

match_type: A string that specifies how to perform matching. The meaning is as described for REGEXP_LIKE().

Prior to MySQL 8.0.17, the result returned by this function used the UTF-16 character set; in MySQL 8.0.17 and later, the character set and collation of the expression searched for matches is used. (Bug #94203, Bug #29308212)

For additional information about how matching occurs, see the description for REGEXP_LIKE().

mysql> select REGEXP_REPLACE('a b c', 'b', 'X');
+-----------------------------------+
| regexp_replace('a b c', 'b', 'X') |
+-----------------------------------+
| a X c                             |
+-----------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_replace('abc def ghi', '[a-z]+', 'X', 1,3);
+---------------------------------------------------+
| regexp_replace('abc def ghi', '[a-z]+', 'X', 1,3) |
+---------------------------------------------------+
| abc def X                                         |
+---------------------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_replace('abc def ghi', '[a-z]+', 'X');
+----------------------------------------------+
| regexp_replace('abc def ghi', '[a-z]+', 'X') |
+----------------------------------------------+
| X X X                                        |
+----------------------------------------------+

REGEXP_SUBSTR(expr, pat[, pos[, occurrence[, match_type]]])
------------------------------------------------------------
Returns the substring of the string expr that matches the regular expression specified by the pattern pat, NULL if there is no match. If expr or pat is NULL, the return value is NULL.

REGEXP_SUBSTR() takes these optional arguments:

pos: The position in expr at which to start the search. If omitted, the default is 1.

occurrence: Which occurrence of a match to search for. If omitted, the default is 1.

match_type: A string that specifies how to perform matching. The meaning is as described for REGEXP_LIKE().

Prior to MySQL 8.0.17, the result returned by this function used the UTF-16 character set; in MySQL 8.0.17 and later, the character set and collation of the expression searched for matches is used. (Bug #94203, Bug #29308212)

For additional information about how matching occurs, see the description for REGEXP_LIKE().

mysql> select regexp_substr('abc def ghi', '[a-z]+');
+----------------------------------------+
| regexp_substr('abc def ghi', '[a-z]+') |
+----------------------------------------+
| abc                                    |
+----------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_substr('abc def ghi', '[a-z]+',1);
+------------------------------------------+
| regexp_substr('abc def ghi', '[a-z]+',1) |
+------------------------------------------+
| abc                                      |
+------------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_substr('abc def ghi', '[a-z]+',1,2);
+--------------------------------------------+
| regexp_substr('abc def ghi', '[a-z]+',1,2) |
+--------------------------------------------+
| def                                        |
+--------------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_substr('abc 12 def ghi', '[a-z]+',1,2);
+-----------------------------------------------+
| regexp_substr('abc 12 def ghi', '[a-z]+',1,2) |
+-----------------------------------------------+
| def                                           |
+-----------------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_substr('abc12def ghi', '[a-z]+',1,2);
+---------------------------------------------+
| regexp_substr('abc12def ghi', '[a-z]+',1,2) |
+---------------------------------------------+
| def                                         |
+---------------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_substr('abc12def ghi', '[a-z]+');
+-----------------------------------------+
| regexp_substr('abc12def ghi', '[a-z]+') |
+-----------------------------------------+
| abc                                     |
+-----------------------------------------+


Regular Expression Syntax
==========================
Regular Expression Syntax

A regular expression describes a set of strings. The simplest regular expression is one that has no special characters in it. For example, the regular expression hello matches hello and nothing else.

Nontrivial regular expressions use certain special constructs so that they can match more than one string. For example, the regular expression hello|world contains the | alternation operator and matches either the hello or world.

As a more complex example, the regular expression B[an]*s matches any of the strings Bananas, Baaaaas, Bs, and any other string starting with a B, ending with an s, and containing any number of a or n characters in between.

The following list covers some of the basic special characters and constructs that can be used in regular expressions. For information about the full regular expression syntax supported by the ICU library used to implement regular expression support, visit the International Components for Unicode website.

^ - Match the beginning of a string.
mysql> select regexp_like ('fo\nfo', '^fo$');
+--------------------------------+
| regexp_like ('fo\nfo', '^fo$') |
+--------------------------------+
|                              0 |
+--------------------------------+
1 row in set (0.01 sec)

mysql> select regexp_like ('fo\nfo', '^fo');
+-------------------------------+
| regexp_like ('fo\nfo', '^fo') |
+-------------------------------+
|                             1 |
+-------------------------------+

$ - Match the end of a string.
mysql> SELECT REGEXP_LIKE('fo\no', '^fo\no$');                 -> 1
mysql> SELECT REGEXP_LIKE('fo\no', '^fo$');                    -> 0

. - Match any character (including carriage return and newline, although to match these in the middle of a string, the m (multiple line) match-control character or the (?m) within-pattern modifier must be given).

mysql> select regexp_like ('fofo', '^f.*$');
+-------------------------------+
| regexp_like ('fofo', '^f.*$') |
+-------------------------------+
|                             1 |
+-------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like ('fo\r\nfo', '^f.*$');
+-----------------------------------+
| regexp_like ('fo\r\nfo', '^f.*$') |
+-----------------------------------+
|                                 0 |
+-----------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like ('fo\r\nfo', '^f.*$', 'm');
+----------------------------------------+
| regexp_like ('fo\r\nfo', '^f.*$', 'm') |
+----------------------------------------+
|                                      1 |
+----------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like ('fo\r\nfo', '(?m)^f.*$');
+---------------------------------------+
| regexp_like ('fo\r\nfo', '(?m)^f.*$') |
+---------------------------------------+
|                                     1 |
+---------------------------------------+

a* - Match any sequence of zero or more a characters.
mysql> SELECT REGEXP_LIKE('Ban', '^Ba*n');                     -> 1
mysql> SELECT REGEXP_LIKE('Baaan', '^Ba*n');                   -> 1
mysql> SELECT REGEXP_LIKE('Bn', '^Ba*n');                      -> 1

a+ - Match any sequence of one or more a characters.
mysql> SELECT REGEXP_LIKE('Ban', '^Ba+n');                     -> 1
mysql> SELECT REGEXP_LIKE('Bn', '^Ba+n');                      -> 0

a? - Match either zero or one a character.
mysql> SELECT REGEXP_LIKE('Bn', '^Ba?n');                      -> 1
mysql> SELECT REGEXP_LIKE('Ban', '^Ba?n');                     -> 1
mysql> SELECT REGEXP_LIKE('Baan', '^Ba?n');                    -> 0

de|abc - alternation; match either of the sequences de or abc.
mysql> SELECT REGEXP_LIKE('pi', 'pi|apa');                     -> 1
mysql> SELECT REGEXP_LIKE('axe', 'pi|apa');                    -> 0
mysql> SELECT REGEXP_LIKE('apa', 'pi|apa');                    -> 1
mysql> SELECT REGEXP_LIKE('apa', '^(pi|apa)$');                -> 1
mysql> SELECT REGEXP_LIKE('pi', '^(pi|apa)$');                 -> 1
mysql> SELECT REGEXP_LIKE('pix', '^(pi|apa)$');                -> 0

(abc)* - Match zero or more instances of the sequence abc.
mysql> SELECT REGEXP_LIKE('pi', '^(pi)*$');                    -> 1
mysql> SELECT REGEXP_LIKE('pip', '^(pi)*$');                   -> 0
mysql> SELECT REGEXP_LIKE('pipi', '^(pi)*$');                  -> 1

mysql> SELECT REGEXP_LIKE('pip', '(pi)*');
+-----------------------------+
| REGEXP_LIKE('pip', '(pi)*') |
+-----------------------------+
|                           1 |
+-----------------------------+
1 row in set (0.00 sec)

{1}, {2,3} - Repetition; {n} and {m,n} notation provide a more general way of writing regular expressions that match many occurrences of the previous atom (or “piece”) of the pattern. m and n are integers.

a* - Can be written as a{0,}.
a+ - Can be written as a{1,}.
a? - Can be written as a{0,1}.

mysql> select regexp_like ('abcde', 'a[bcd]{1}e');
+-------------------------------------+
| regexp_like ('abcde', 'a[bcd]{1}e') |
+-------------------------------------+
|                                   0 |
+-------------------------------------+
1 row in set (0.01 sec)

mysql> select regexp_like ('abcde', 'a[bcd]{1,}e');
+--------------------------------------+
| regexp_like ('abcde', 'a[bcd]{1,}e') |
+--------------------------------------+
|                                    1 |
+--------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like ('abcde', 'a[bcd]{2}e');
+-------------------------------------+
| regexp_like ('abcde', 'a[bcd]{2}e') |
+-------------------------------------+
|                                   0 |
+-------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like ('abcde', 'a[bcd]{3}e');
+-------------------------------------+
| regexp_like ('abcde', 'a[bcd]{3}e') |
+-------------------------------------+
|                                   1 |
+-------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like ('abcde', 'a[bcd]{4}e');
+-------------------------------------+
| regexp_like ('abcde', 'a[bcd]{4}e') |
+-------------------------------------+
|                                   0 |
+-------------------------------------+

mysql> SELECT REGEXP_LIKE('abcde', 'a[bcd]{1,10}e');           -> 1

[a-dX], [^a-dX] - Matches any character that is (or is not, if ^ is used) either a, b, c, d or X. A - character between two other characters forms a range that matches all characters from the first character to the second. For example, [0-9] matches any decimal digit. To include a literal ] character, it must immediately follow the opening bracket [. To include a literal - character, it must be written first or last. Any character that does not have a defined special meaning inside a [] pair matches only itself.

mysql> SELECT REGEXP_LIKE('aXbc', '[a-dXYZ]');                 -> 1
mysql> SELECT REGEXP_LIKE('aXbc', '^[a-dXYZ]$');               -> 0
mysql> SELECT REGEXP_LIKE('aXbc', '^[a-dXYZ]+$');              -> 1
mysql> SELECT REGEXP_LIKE('aXbc', '^[^a-dXYZ]+$');             -> 0
mysql> SELECT REGEXP_LIKE('gheis', '^[^a-dXYZ]+$');            -> 1
mysql> SELECT REGEXP_LIKE('gheisa', '^[^a-dXYZ]+$');           -> 0

mysql> SELECT REGEXP_LIKE('aXbcZ', '^[a-dXY]');
+----------------------------------+
| REGEXP_LIKE('aXbcZ', '^[a-dXY]') |
+----------------------------------+
|                                1 |
+----------------------------------+
1 row in set (0.00 sec)

mysql> SELECT REGEXP_LIKE('caXbcZ', '^[a-dXY]');
+-----------------------------------+
| REGEXP_LIKE('caXbcZ', '^[a-dXY]') |
+-----------------------------------+
|                                 1 |
+-----------------------------------+

[=character_class=] - Within a bracket expression (written using [ and ]), [=character_class=] represents an equivalence class. It matches all characters with the same collation value, including itself. For example, if o and (+) are the members of an equivalence class, [[=o=]], [[=(+)=]], and [o(+)] are all synonymous. An equivalence class may not be used as an endpoint of a range.

[:character_class:] - Within a bracket expression (written using [ and ]), [:character_class:] represents a character class that matches all characters belonging to that class. The following table lists the standard class names. These names stand for the character classes defined in the ctype(3) manual page. A particular locale may provide other class names. A character class may not be used as an endpoint of a range.

Character Class Name	Meaning
alnum	                Alphanumeric characters
alpha	                Alphabetic characters
blank	                Whitespace characters
cntrl	                Control characters
digit	                Digit characters
graph	                Graphic characters
lower	                Lowercase alphabetic characters
print	                Graphic or space characters
punct	                Punctuation characters
space	                Space, tab, newline, and carriage return
upper	                Uppercase alphabetic characters
xdigit	                Hexadecimal digit characters

mysql> SELECT REGEXP_LIKE('justalnums', '[[:alnum:]]+');       -> 1
mysql> SELECT REGEXP_LIKE('!!', '[[:alnum:]]+');               -> 0

To use a literal instance of a special character in a regular expression, precede it by two backslash (\) characters. The MySQL parser interprets one of the backslashes, and the regular expression library interprets the other. For example, to match the string 1+2 that contains the special + character, only the last of the following regular expressions is the correct one:

mysql> SELECT REGEXP_LIKE('1+2', '1+2');                       -> 0
mysql> SELECT REGEXP_LIKE('1+2', '1\+2');                      -> 0
mysql> SELECT REGEXP_LIKE('1+2', '1\\+2');                     -> 1

mysql> select regexp_like('ramesh123', '[[:alnum:]]');
+-----------------------------------------+
| regexp_like('ramesh123', '[[:alnum:]]') |
+-----------------------------------------+
|                                       1 |
+-----------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like('ramesh', '[[:alnum:]]');
+--------------------------------------+
| regexp_like('ramesh', '[[:alnum:]]') |
+--------------------------------------+
|                                    1 |
+--------------------------------------+
1 row in set (0.01 sec)

mysql> select regexp_like('123', '[[:alnum:]]');
+-----------------------------------+
| regexp_like('123', '[[:alnum:]]') |
+-----------------------------------+
|                                 1 |
+-----------------------------------+
1 row in set (0.01 sec)

mysql> select regexp_like('', '[[:alnum:]]');
+--------------------------------+
| regexp_like('', '[[:alnum:]]') |
+--------------------------------+
|                              0 |
+--------------------------------+
1 row in set (0.01 sec)

mysql> select regexp_like('123!', '[[:alnum:]]');
+------------------------------------+
| regexp_like('123!', '[[:alnum:]]') |
+------------------------------------+
|                                  1 |
+------------------------------------+
1 row in set (0.00 sec)

mysql> select regexp_like('123!', '[[:alnum:]]+');
+-------------------------------------+
| regexp_like('123!', '[[:alnum:]]+') |
+-------------------------------------+
|                                   1 |
+-------------------------------------+
1 row in set (0.01 sec)


Regular Expression Resource Control

REGEXP_LIKE() and similar functions use resources that can be controlled by setting system variables:

The match engine uses memory for its internal stack. To control the maximum available memory for the stack in bytes, set the regexp_stack_limit system variable.

The match engine operates in steps. To control the maximum number of steps performed by the engine (and thus indirectly the execution time), set the regexp_time_limit system variable. Because this limit is expressed as number of steps, it affects execution time only indirectly. Typically, it is on the order of milliseconds.

3.3.4.8 Counting Rows
---------------------
Databases are often used to answer the question, “How often does a certain type of data occur in a table?” For example, you might want to know how many pets you have, or how many pets each owner has, or you might want to perform various kinds of census operations on your animals.

Counting the total number of animals you have is the same question as “How many rows are in the pet table?” because there is one record per pet. COUNT(*) counts the number of rows, so the query to count your animals looks like this:
mysql> select count(*) from pet;
+----------+
| count(*) |
+----------+
|        9 |
+----------+

Earlier, you retrieved the names of the people who owned pets. You can use COUNT() if you want to find out how many pets each owner has:
mysql> select owner, count(owner) from pet group by owner;
+--------+--------------+
| owner  | count(owner) |
+--------+--------------+
| Harold |            2 |
| Gwen   |            3 |
| Benny  |            2 |
| Diane  |            1 |
| Chinku |            1 |
+--------+--------------+
5 rows in set (0.00 sec)

The preceding query uses GROUP BY to group all records for each owner. The use of COUNT() in conjunction with GROUP BY is useful for characterizing your data under various groupings. The following examples show different ways to perform animal census operations.

Number of animals per species:
mysql> select species, count(species) from pet group by species;
+---------+----------------+
| species | count(species) |
+---------+----------------+
| cat     |              2 |
| dog     |              4 |
| bird    |              2 |
| snake   |              1 |
+---------+----------------+
4 rows in set (0.01 sec)

Number of animals per sex:
mysql> select sex, count(sex) from pet group by sex;
+------+------------+
| sex  | count(sex) |
+------+------------+
| F    |          3 |
| M    |          5 |
| NULL |          0 |
+------+------------+
3 rows in set (0.00 sec)

OR -
mysql> select sex, count(*) from pet group by sex;
+------+----------+
| sex  | count(*) |
+------+----------+
| F    |        3 |
| M    |        5 |
| NULL |        1 |
+------+----------+
3 rows in set (0.00 sec)

(In this output, NULL indicates that the sex is unknown.)

Number of animals per combination of species and sex:
mysql> select species, sex, count(*) from pet group by species, sex;
+---------+------+----------+
| species | sex  | count(*) |
+---------+------+----------+
| cat     | F    |        1 |
| cat     | M    |        1 |
| dog     | F    |        1 |
| dog     | M    |        3 |
| bird    | F    |        1 |
| bird    | NULL |        1 |
| snake   | M    |        1 |
+---------+------+----------+

You need not retrieve an entire table when you use COUNT(). For example, the previous query, when performed just on dogs and cats, looks like this:
mysql> select species, sex, count(*) from pet where species = 'dog' or species = 'cat' group by species, sex;
+---------+------+----------+
| species | sex  | count(*) |
+---------+------+----------+
| cat     | F    |        1 |
| cat     | M    |        1 |
| dog     | F    |        1 |
| dog     | M    |        3 |
+---------+------+----------+
4 rows in set (0.00 sec)

OR -
mysql> select species, sex, count(*) from pet group by species, sex having species='dog' or species='cat';
+---------+------+----------+
| species | sex  | count(*) |
+---------+------+----------+
| cat     | F    |        1 |
| cat     | M    |        1 |
| dog     | F    |        1 |
| dog     | M    |        3 |
+---------+------+----------+
4 rows in set (0.00 sec)

Or, if you wanted the number of animals per sex only for animals whose sex is known:
mysql> select species, sex, count(sex) from pet where sex is not null group by species, sex;
+---------+------+------------+
| species | sex  | count(sex) |
+---------+------+------------+
| cat     | F    |          1 |
| cat     | M    |          1 |
| dog     | F    |          1 |
| dog     | M    |          3 |
| bird    | F    |          1 |
| snake   | M    |          1 |
+---------+------+------------+
6 rows in set (0.00 sec)

mysql> select species, sex, count(*) from pet where sex is not null group by species, sex;
+---------+------+----------+
| species | sex  | count(*) |
+---------+------+----------+
| cat     | F    |        1 |
| cat     | M    |        1 |
| dog     | F    |        1 |
| dog     | M    |        3 |
| bird    | F    |        1 |
| snake   | M    |        1 |
+---------+------+----------+
6 rows in set (0.00 sec)

If you name columns to select in addition to the COUNT() value, a GROUP BY clause should be present that names those same columns. Otherwise, the following occurs:

If the ONLY_FULL_GROUP_BY SQL mode is enabled, an error occurs:

mysql> SET sql_mode = 'ONLY_FULL_GROUP_BY';
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT owner, COUNT(*) FROM pet;
ERROR 1140 (42000): In aggregated query without GROUP BY, expression
#1 of SELECT list contains nonaggregated column 'menagerie.pet.owner';
this is incompatible with sql_mode=only_full_group_by
If ONLY_FULL_GROUP_BY is not enabled, the query is processed by treating all rows as a single group, but the value selected for each named column is nondeterministic. The server is free to select the value from any row:

mysql> SET sql_mode = '';
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT owner, COUNT(*) FROM pet;
+--------+----------+
| owner  | COUNT(*) |
+--------+----------+
| Harold |        8 |
+--------+----------+
1 row in set (0.00 sec)

See also Section 12.20.3, “MySQL Handling of GROUP BY”. See Section 12.20.1, “Aggregate Function Descriptions” for information about COUNT(expr) behavior and related optimizations.

3.3.4.9 Using More Than one Table
---------------------------------
The pet table keeps track of which pets you have. If you want to record other information about them, such as events in their lives like visits to the vet or when litters are born, you need another table. What should this table look like? It needs to contain the following information:

The pet name so that you know which animal each event pertains to.
A date so that you know when the event occurred.
A field to describe the event.
An event type field, if you want to be able to categorize events.
Given these considerations, the CREATE TABLE statement for the event table might look like this:

mysql> create table event (name varchar(20), date DATE, type varchar(15), remark varchar(255));
Query OK, 0 rows affected (0.02 sec)

mysql> SET GLOBAL local_infile = 1;
mysql> load data local infile '/Users/utsav/Desktop/repos/SQLLearning/te.csv' into table event  fields terminated by '|';

Based on what you have learned from the queries that you have run on the pet table, you should be able to perform retrievals on the records in the event table; the principles are the same. But when is the event table by itself insufficient to answer questions you might ask?

Suppose that you want to find out the ages at which each pet had its litters. We saw earlier how to calculate ages from two dates. The litter date of the mother is in the event table, but to calculate her age on that date you need her birth date, which is stored in the pet table. This means the query requires both tables:

mysql> select pet.name, TIMESTAMPDIFF(YEAR, birth, date) as age, remark
    -> from pet join event on pet.name = event.name
    -> where event.type = 'litter';

OR
mysql> select p.name, TIMESTAMPDIFF(YEAR, p.birth, e.date) as age, e.remark
from pet p
join event e
on p.name=e.name
where e.type='litter';

There are several things to note about this query:

The FROM clause joins two tables because the query needs to pull information from both of them.

When combining (joining) information from multiple tables, you need to specify how records in one table can be matched to records in the other. This is easy because they both have a name column. The query uses an ON clause to match up records in the two tables based on the name values.

The query uses an INNER JOIN to combine the tables. An INNER JOIN permits rows from either table to appear in the result if and only if both tables meet the conditions specified in the ON clause. In this example, the ON clause specifies that the name column in the pet table must match the name column in the event table. If a name appears in one table but not the other, the row does not appear in the result because the condition in the ON clause fails.

Because the name column occurs in both tables, you must be specific about which table you mean when referring to the column. This is done by prepending the table name to the column name.

You need not have two different tables to perform a join. Sometimes it is useful to join a table to itself, if you want to compare records in a table to other records in that same table. For example, to find breeding pairs among your pets, you can join the pet table with itself to produce candidate pairs of live males and females of like species:

select p1.name, p1.sex, p2.name, p2.sex, p1.species
from pet p1
join pet p2
on p1.species = p2.species
and p1.sex = 'f' AND p1.death is null
and p2.sex = 'm' AND p2.death is null;

OR
SELECT p1.name, p1.sex, p2.name, p2.sex, p1.species
       FROM pet AS p1 INNER JOIN pet AS p2
         ON p1.species = p2.species
         AND p1.sex = 'f' AND p1.death IS NULL
         AND p2.sex = 'm' AND p2.death IS NULL;

In this query, we specify aliases for the table name to refer to the columns and keep straight which instance of the table each column reference is associated with.

3.4 Getting Information About Databases and Tables
---------------------------------------------------
What if you forget the name of a database or table, or what the structure of a given table is (for example, what its columns are called)? MySQL addresses this problem through several statements that provide information about the databases and tables it supports.

You have previously seen SHOW DATABASES, which lists the databases managed by the server. To find out which database is currently selected, use the DATABASE() function:

mysql> use menagerie;
Database changed
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| menagerie          |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
6 rows in set (0.00 sec)

mysql> select database();
+------------+
| database() |
+------------+
| menagerie  |
+------------+
1 row in set (0.00 sec)

If you have not yet selected any database, the result is NULL.

To find out what tables the default database contains (for example, when you are not sure about the name of a table), use this statement:
mysql> show tables;
+---------------------+
| Tables_in_menagerie |
+---------------------+
| event               |
| mytable             |
| pet                 |
+---------------------+
3 rows in set (0.00 sec)

The name of the column in the output produced by this statement is always Tables_in_db_name, where db_name is the name of the database. See Section 13.7.7.39, “SHOW TABLES Statement”, for more information.

If you want to find out about the structure of a table, the DESCRIBE statement is useful; it displays information about each of a table's columns:
mysql> describe pet;
+---------+---------------+------+-----+---------+-------+
| Field   | Type          | Null | Key | Default | Extra |
+---------+---------------+------+-----+---------+-------+
| name    | varchar(20)   | YES  |     | NULL    |       |
| owner   | varchar(20)   | YES  |     | NULL    |       |
| species | varchar(20)   | YES  |     | NULL    |       |
| sex     | enum('M','F') | YES  |     | NULL    |       |
| birth   | date          | YES  |     | NULL    |       |
| death   | date          | YES  |     | NULL    |       |
+---------+---------------+------+-----+---------+-------+
6 rows in set (0.02 sec)

Field indicates the column name, Type is the data type for the column, NULL indicates whether the column can contain NULL values, Key indicates whether the column is indexed, and Default specifies the column's default value. Extra displays special information about columns: If a column was created with the AUTO_INCREMENT option, the value is auto_increment rather than empty.

DESC is a short form of DESCRIBE. See Section 13.8.1, “DESCRIBE Statement”, for more information.

mysql> desc pet;
+---------+---------------+------+-----+---------+-------+
| Field   | Type          | Null | Key | Default | Extra |
+---------+---------------+------+-----+---------+-------+
| name    | varchar(20)   | YES  |     | NULL    |       |
| owner   | varchar(20)   | YES  |     | NULL    |       |
| species | varchar(20)   | YES  |     | NULL    |       |
| sex     | enum('M','F') | YES  |     | NULL    |       |
| birth   | date          | YES  |     | NULL    |       |
| death   | date          | YES  |     | NULL    |       |
+---------+---------------+------+-----+---------+-------+
6 rows in set (0.01 sec)

You can obtain the CREATE TABLE statement necessary to create an existing table using the SHOW CREATE TABLE statement. See Section 13.7.7.10, “SHOW CREATE TABLE Statement”.

If you have indexes on a table, SHOW INDEX FROM tbl_name produces information about them. See Section 13.7.7.22, “SHOW INDEX Statement”, for more about this statement.

mysql> show create table;
mysql> show index from pet;

3.5 Using mysql in Batch Mode
------------------------------
In the previous sections, you used mysql interactively to enter statements and view the results. You can also run mysql in batch mode. To do this, put the statements you want to run in a file, then tell mysql to read its input from the file:
3.5 Using mysql in Batch Mode

In the previous sections, you used mysql interactively to enter statements and view the results. You can also run mysql in batch mode. To do this, put the statements you want to run in a file, then tell mysql to read its input from the file:

shell> mysql < batch-file
If you are running mysql under Windows and have some special characters in the file that cause problems, you can do this:

C:\> mysql -e "source batch-file"
If you need to specify connection parameters on the command line, the command might look like this:

shell> mysql -h host -u user -p < batch-file
Enter password: ********

Example:
(base) Utsavs-MacBook-Air:~ utsav$ mysql < /Users/utsav/Desktop/repos/SQLLearning/batch-file.sql
(base) Utsavs-MacBook-Air:~ utsav$ mysql -u root -p < /Users/utsav/Desktop/repos/SQLLearning/batch-file.sql
Enter password:
name	owner	species	sex	birth	death
Fluffy	Harold	cat	F	1993-02-04	NULL
Claws	Gwen	cat	M	1994-03-17	NULL
Buffy	Harold	dog	F	1989-05-13	NULL
Fang	Benny	dog	M	1990-08-27	NULL
Bowser	Diane	dog	M	1989-08-31	1995-07-29
Chirpy	Gwen	bird	F	1998-09-11	NULL
Whistler	Gwen	bird	NULL	1997-12-09	NULL
Slim	Benny	snake	M	1996-04-29	NULL
bruzo	Chinku	dog	M	2019-01-04	NULL

When you use mysql this way, you are creating a script file, then executing the script.

If you want the script to continue even if some of the statements in it produce errors, you should use the --force command-line option.

Why use a script? Here are a few reasons:

If you run a query repeatedly (say, every day or every week), making it a script enables you to avoid retyping it each time you execute it.

You can generate new queries from existing ones that are similar by copying and editing script files.

Batch mode can also be useful while you're developing a query, particularly for multiple-line statements or multiple-statement sequences. If you make a mistake, you don't have to retype everything. Just edit your script to correct the error, then tell mysql to execute it again.

If you have a query that produces a lot of output, you can run the output through a pager rather than watching it scroll off the top of your screen:

shell> mysql < batch-file | more
You can catch the output in a file for further processing:


shell> mysql < batch-file > mysql.out

Example:
(base) Utsavs-MacBook-Air:~ utsav$ mysql -u root -p  < /Users/utsav/Desktop/repos/SQLLearning/batch-file.sql > /Users/utsav/Desktop/repos/SQLLearning/batch-file_output.csv
Enter password:

If you want to get the interactive output format in batch mode, use mysql -t. To echo to the output the statements that are executed, use mysql -v.
(base) Utsavs-MacBook-Air:~ utsav$ mysql -u root -p  -t < /Users/utsav/Desktop/repos/SQLLearning/batch-file.sql
Enter password:
+----------+--------+---------+------+------------+------------+
| name     | owner  | species | sex  | birth      | death      |
+----------+--------+---------+------+------------+------------+
| Fluffy   | Harold | cat     | F    | 1993-02-04 | NULL       |
| Claws    | Gwen   | cat     | M    | 1994-03-17 | NULL       |
| Buffy    | Harold | dog     | F    | 1989-05-13 | NULL       |
| Fang     | Benny  | dog     | M    | 1990-08-27 | NULL       |
| Bowser   | Diane  | dog     | M    | 1989-08-31 | 1995-07-29 |
| Chirpy   | Gwen   | bird    | F    | 1998-09-11 | NULL       |
| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |
| Slim     | Benny  | snake   | M    | 1996-04-29 | NULL       |
| bruzo    | Chinku | dog     | M    | 2019-01-04 | NULL       |
+----------+--------+---------+------+------------+------------+

(base) Utsavs-MacBook-Air:~ utsav$ mysql -u root -p  -t -v < /Users/utsav/Desktop/repos/SQLLearning/batch-file.sql
Enter password:
--------------
select * from pet limit 2
--------------

+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | F    | 1993-02-04 | NULL  |
| Claws  | Gwen   | cat     | M    | 1994-03-17 | NULL  |
+--------+--------+---------+------+------------+-------+
--------------
show tables
--------------

+---------------------+
| Tables_in_menagerie |
+---------------------+
| event               |
| mytable             |
| pet                 |
+---------------------+
--------------
select * from event limit 2
--------------

+--------+------------+--------+-----------------------------+
| name   | date       | type   | remark                      |
+--------+------------+--------+-----------------------------+
| Fluffy | 1995-05-15 | litter | 4 kittens, 3 female, 1 male |
| Buffy  | 1993-06-23 | litter | 5 puppies, 2 female, 3 male |
+--------+------------+--------+-----------------------------+

You can also use scripts from the mysql prompt by using the source command or \. command(# Don't terminate with semi-colon):
mysql> source /Users/utsav/Desktop/repos/SQLLearning/batch-file.sql
Database changed
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | F    | 1993-02-04 | NULL  |
| Claws  | Gwen   | cat     | M    | 1994-03-17 | NULL  |
+--------+--------+---------+------+------------+-------+
2 rows in set (0.00 sec)

+---------------------+
| Tables_in_menagerie |
+---------------------+
| event               |
| mytable             |
| pet                 |
+---------------------+
3 rows in set (0.00 sec)

+--------+------------+--------+-----------------------------+
| name   | date       | type   | remark                      |
+--------+------------+--------+-----------------------------+
| Fluffy | 1995-05-15 | litter | 4 kittens, 3 female, 1 male |
| Buffy  | 1993-06-23 | litter | 5 puppies, 2 female, 3 male |
+--------+------------+--------+-----------------------------+
2 rows in set (0.00 sec)

mysql> \. /Users/utsav/Desktop/repos/SQLLearning/batch-file.sql # Don't terminate with semi-colon
Database changed
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | F    | 1993-02-04 | NULL  |
| Claws  | Gwen   | cat     | M    | 1994-03-17 | NULL  |
+--------+--------+---------+------+------------+-------+
2 rows in set (0.00 sec)

+---------------------+
| Tables_in_menagerie |
+---------------------+
| event               |
| mytable             |
| pet                 |
+---------------------+
3 rows in set (0.00 sec)

+--------+------------+--------+-----------------------------+
| name   | date       | type   | remark                      |
+--------+------------+--------+-----------------------------+
| Fluffy | 1995-05-15 | litter | 4 kittens, 3 female, 1 male |
| Buffy  | 1993-06-23 | litter | 5 puppies, 2 female, 3 male |
+--------+------------+--------+-----------------------------+
2 rows in set (0.00 sec)

mysql> source filename;
mysql> \. filename
See Section 4.5.1.5, “Executing SQL Statements from a Text File”, for more information.

3.6 Examples of Common Queries
-------------------------------
Here are examples of how to solve some common problems with MySQL.

Some of the examples use the table shop to hold the price of each article (item number) for certain traders (dealers). Supposing that each trader has a single fixed price per article, then (article, dealer) is a primary key for the records.

Start the command-line tool mysql and select a database:
To create and populate the example table, use these statements:
create table shop(
	article INT UNSIGNED  DEFAULT '0000' NOT NULL,
    dealer  CHAR(20)      DEFAULT ''     NOT NULL,
    price   DECIMAL(16,2) DEFAULT '0.00' NOT NULL,
	PRIMARY KEY(article, dealer)
);

INSERT INTO shop
VALUES (1,'A',3.45),(1,'B',3.99),(2,'A',10.99),(3,'B',1.45),
	(3,'C',1.69),(3,'D',1.25),(4,'D',19.95);

After issuing the statements, the table should have the following contents:
mysql> select * from shop order by article;
+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|       1 | A      |  3.45 |
|       1 | B      |  3.99 |
|       2 | A      | 10.99 |
|       3 | B      |  1.45 |
|       3 | C      |  1.69 |
|       3 | D      |  1.25 |
|       4 | D      | 19.95 |
+---------+--------+-------+
7 rows in set (0.00 sec)

3.6.1 The Maximum Value for a Column

“What is the highest item number?”
mysql> select MAX(article) as article from shop;
+---------+
| article |
+---------+
|       4 |
+---------+
1 row in set (0.01 sec)

3.6.2 The Row Holding the Maximum of a Certain Column

Task: Find the number, dealer, and price of the most expensive article.
mysql> select * from shop where price=(select max(price) from shop);
+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|       4 | D      | 19.95 |
+---------+--------+-------+
1 row in set (0.00 sec)

mysql> select * from shop order by price desc limit 1;
+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|       4 | D      | 19.95 |
+---------+--------+-------+
1 row in set (0.00 sec)

mysql> select s1.article, s1.dealer, s1.price from shop s1 left join shop s2 on s1.price < s2.price where s2.article is null;
+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|       4 | D      | 19.95 |
+---------+--------+-------+
1 row in set (0.00 sec)

Note
If there were several most expensive articles, each with a price of 19.95, the LIMIT solution would show only one of them.

3.6.3 Maximum of Column per Group
Task: Find the highest price per article.
mysql> select article, max(price) as price from shop group by article order by article;
+---------+-------+
| article | price |
+---------+-------+
|       1 |  3.99 |
|       2 | 10.99 |
|       3 |  1.69 |
|       4 | 19.95 |
+---------+-------+
4 rows in set (0.00 sec)

3.6.4 The Rows Holding the Group-wise Maximum of a Certain Column
Task: For each article, find the dealer or dealers with the most expensive price.

mysql> select * from shop where price in (select max(price) as price from shop group by article);
+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|       1 | B      |  3.99 |
|       2 | A      | 10.99 |
|       3 | C      |  1.69 |
|       4 | D      | 19.95 |
+---------+--------+-------+
4 rows in set (0.00 sec)

select * from shop s1 where price = (select max(s2.price) from shop s2 where s1.article=s2.article) order by article;

The preceding example uses a correlated subquery, which can be inefficient (see Section 13.2.11.7, “Correlated Subqueries”). Other possibilities for solving the problem are to use an uncorrelated subquery in the FROM clause, a LEFT JOIN, or a common table expression with a window function.

Uncorrelated subquery:
select * from shop as s1
JOIN (select article, max(price) as price from shop group by article) as s2
on s1.article=s2.article AND s1.price=s2.price
order by s1.article;

LEFT JOIN
select s1.article, s1.dealer, s1.price, s2.article from shop s1
left join shop s2
on s1.price < s2.price AND s1.article = s2.article
where s2.article is null
order by s1.article;

The LEFT JOIN works on the basis that when s1.price is at its maximum value, there is no s2.price with a greater value and thus the corresponding s2.article value is NULL. See Section 13.2.10.2, “JOIN Clause”.

3.6.5 Using User-Defined Variables

You can employ MySQL user variables to remember results without having to store them in temporary variables in the client. (See Section 9.4, “User-Defined Variables”.)

For example, to find the articles with the highest and lowest price you can do this:
select @min_price:=MIN(price), @max_price:=MAX(price) FROM shop;
select * from shop where price=@min_price or price=@max_price;

Note
It is also possible to store the name of a database object such as a table or a column in a user variable and then to use this variable in an SQL statement; however, this requires the use of a prepared statement. See Section 13.5, “Prepared Statements”, for more information.

3.6.6 Using Foreign Keys
==========================
In MySQL, InnoDB tables support checking of foreign key constraints. See Chapter 15, The InnoDB Storage Engine, and Section 1.7.2.3, “FOREIGN KEY Constraint Differences”.
In MySQL, InnoDB tables support checking of foreign key constraints. See Chapter 15, The InnoDB Storage Engine, and Section 1.7.2.3, “FOREIGN KEY Constraint Differences”.

A foreign key constraint is not required merely to join two tables. For storage engines other than InnoDB, it is possible when defining a column to use a REFERENCES tbl_name(col_name) clause, which has no actual effect, and serves only as a memo or comment to you that the column which you are currently defining is intended to refer to a column in another table. It is extremely important to realize when using this syntax that:

MySQL does not perform any sort of check to make sure that col_name actually exists in tbl_name (or even that tbl_name itself exists).

MySQL does not perform any sort of action on tbl_name such as deleting rows in response to actions taken on rows in the table which you are defining; in other words, this syntax induces no ON DELETE or ON UPDATE behavior whatsoever. (Although you can write an ON DELETE or ON UPDATE clause as part of the REFERENCES clause, it is also ignored.)

This syntax creates a column; it does not create any sort of index or key.

create table person (
	id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    name VARCHAR(60) NOT NULL,
    PRIMARY KEY (id)
);

CREATE TABLE shirt(
	id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    style ENUM('t-shirt', 'polo', 'dress') NOT NULL,
    color ENUM('red', 'blue', 'orange', 'white', 'black') NOT NULL,
    owner SMALLINT UNSIGNED NOT NULL REFERENCES person(id),
    PRIMARY KEY (id)
);

INSERT INTO person VALUES(NULL,'Antonio Paz');
SELECT @last := LAST_INSERT_ID();

INSERT INTO shirt VALUES
(NULL, 'polo', 'blue', @last),
(NULL, 'dress', 'white', @last),
(NULL, 't-shirt', 'blue', @last);

INSERT INTO person VALUES(NULL,'Lilliana Angelovska');
SELECT @last := LAST_INSERT_ID();

INSERT INTO shirt VALUES
(NULL, 'dress', 'orange', @last),
(NULL, 'polo', 'red', @last),
(NULL, 'dress', 'blue', @last),
(NULL, 't-shirt', 'white', @last);

Fetch all rows from person and shirt table where name is Lilliana and color is not white.
select s.* from person p
join shirt s
on s.owner = p.id
where p.name like 'Lilliana%' and s.color <> 'white';

When used in this fashion, the REFERENCES clause is not displayed in the output of SHOW CREATE TABLE or DESCRIBE:
mysql> show create table shirt\G
*************************** 1. row ***************************
       Table: shirt
Create Table: CREATE TABLE `shirt` (
  `id` smallint(5) unsigned NOT NULL AUTO_INCREMENT,
  `style` enum('t-shirt','polo','dress') NOT NULL,
  `color` enum('red','blue','orange','white','black') NOT NULL,
  `owner` smallint(5) unsigned NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
1 row in set (0.00 sec)

mysql> show create table shirt;
+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table | Create Table                                                                                                                                                                                                                                                                                                                                     |
+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| shirt | CREATE TABLE `shirt` (
  `id` smallint(5) unsigned NOT NULL AUTO_INCREMENT,
  `style` enum('t-shirt','polo','dress') NOT NULL,
  `color` enum('red','blue','orange','white','black') NOT NULL,
  `owner` smallint(5) unsigned NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |
+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.01 sec)

The use of REFERENCES in this way as a comment or “reminder” in a column definition works with MyISAM tables.

Inorder to see REFERENCES in show create table, the table should be created as:
CREATE TABLE shirt(
	id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    style ENUM('t-shirt', 'polo', 'dress') NOT NULL,
    color ENUM('red', 'blue', 'orange', 'white', 'black') NOT NULL,
    owner SMALLINT UNSIGNED NOT NULL,
    PRIMARY KEY (id),
    FOREIGN KEY (owner) REFERENCES person(id) ON DELETE CASCADE
);

mysql> show create table shirt\G
*************************** 1. row ***************************
       Table: shirt
Create Table: CREATE TABLE `shirt` (
  `id` smallint(5) unsigned NOT NULL AUTO_INCREMENT,
  `style` enum('t-shirt','polo','dress') NOT NULL,
  `color` enum('red','blue','orange','white','black') NOT NULL,
  `owner` smallint(5) unsigned NOT NULL,
  PRIMARY KEY (`id`),
  KEY `owner` (`owner`),
  CONSTRAINT `shirt_ibfk_1` FOREIGN KEY (`owner`) REFERENCES `person` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
1 row in set (0.00 sec)

3.6.7 Searching on Two Keys
===========================
An OR using a single key is well optimized, as is the handling of AND.

The one tricky case is that of searching on two different keys combined with OR:

SELECT field1_index, field2_index FROM test_table
WHERE field1_index = '1' OR  field2_index = '1'
This case is optimized. See Section 8.2.1.3, “Index Merge Optimization”.

You can also solve the problem efficiently by using a UNION that combines the output of two separate SELECT statements. See Section 13.2.10.3, “UNION Clause”.

Each SELECT searches only one key and can be optimized:

SELECT field1_index, field2_index
    FROM test_table WHERE field1_index = '1'
UNION
SELECT field1_index, field2_index
    FROM test_table WHERE field2_index = '1';

OR query normally seems to be faster than UNION, tested on small table.

3.6.8 Calculating Visits Per Day
=================================
The following example shows how you can use the bit group functions to calculate the number of days per month a user has visited a Web page.
create table t1(
	year YEAR,
    month TINYINT UNSIGNED,
    day TINYINT UNSIGNED
);

INSERT INTO t1 VALUES(2000,1,1),(2000,1,20),(2000,1,30),(2000,2,2),
            (2000,2,23),(2000,2,23);

select * from t1;

The example table contains year-month-day values representing visits by users to the page. To determine how many different days in each month these visits occur, use this query:
mysql> select year, month, bit_count(BIT_OR(1<<day)) as days  from t1 group by year, month;
+------+-------+------+
| year | month | days |
+------+-------+------+
| 2000 |     1 |    3 |
| 2000 |     2 |    2 |
+------+-------+------+
2 rows in set (0.00 sec)

The query calculates how many different days appear in the table for each year/month combination, with automatic removal of duplicate entries.


3.6.9 Using AUTO_INCREMENT
===========================
The AUTO_INCREMENT attribute can be used to generate a unique identity for new rows:

CREATE TABLE animals (
     id MEDIUMINT NOT NULL AUTO_INCREMENT,
     name CHAR(30) NOT NULL,
     PRIMARY KEY (id)
);

INSERT INTO animals (name) VALUES
    ('dog'),('cat'),('penguin'),
    ('lax'),('whale'),('ostrich');

SELECT * FROM animals;

No value was specified for the AUTO_INCREMENT column, so MySQL assigned sequence numbers automatically. You can also explicitly assign 0 to the column to generate sequence numbers, unless the NO_AUTO_VALUE_ON_ZERO SQL mode is enabled. For example:
INSERT INTO animals (id,name) VALUES(0,'groundhog');

If the column is declared NOT NULL, it is also possible to assign NULL to the column to generate sequence numbers. For example
INSERT INTO animals (id,name) VALUES(NULL,'squirrel');

When you insert any other value into an AUTO_INCREMENT column, the column is set to that value and the sequence is reset so that the next automatically generated value follows sequentially from the largest column value. For example:

INSERT INTO animals (id,name) VALUES(100,'rabbit');
INSERT INTO animals (id,name) VALUES(NULL,'mouse');
SELECT * FROM animals;
+-----+-----------+
| id  | name      |
+-----+-----------+
|   1 | dog       |
|   2 | cat       |
|   3 | penguin   |
|   4 | lax       |
|   5 | whale     |
|   6 | ostrich   |
|   7 | groundhog |
|   8 | squirrel  |
| 100 | rabbit    |
| 101 | mouse     |
+-----+-----------+

Updating an existing AUTO_INCREMENT column value also resets the AUTO_INCREMENT sequence.

You can retrieve the most recent automatically generated AUTO_INCREMENT value with the LAST_INSERT_ID() SQL function or the mysql_insert_id() C API function. These functions are connection-specific, so their return values are not affected by another connection which is also performing inserts.

Use the smallest integer data type for the AUTO_INCREMENT column that is large enough to hold the maximum sequence value you require. When the column reaches the upper limit of the data type, the next attempt to generate a sequence number fails. Use the UNSIGNED attribute if possible to allow a greater range. For example, if you use TINYINT, the maximum permissible sequence number is 127. For TINYINT UNSIGNED, the maximum is 255. See Section 11.1.2, “Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT” for the ranges of all the integer types.


Note
For a multiple-row insert, LAST_INSERT_ID() and mysql_insert_id() actually return the AUTO_INCREMENT key from the first of the inserted rows. This enables multiple-row inserts to be reproduced correctly on other servers in a replication setup.

To start with an AUTO_INCREMENT value other than 1, set that value with CREATE TABLE or ALTER TABLE, like this:

mysql> ALTER TABLE tbl AUTO_INCREMENT = 100;

InnoDB Notes
For information about AUTO_INCREMENT usage specific to InnoDB, see Section 15.6.1.6, “AUTO_INCREMENT Handling in InnoDB”.

MyISAM Notes

For MyISAM tables, you can specify AUTO_INCREMENT on a secondary column in a multiple-column index. In this case, the generated value for the AUTO_INCREMENT column is calculated as MAX(auto_increment_column) + 1 WHERE prefix=given-prefix. This is useful when you want to put data into ordered groups.

CREATE TABLE animals (
    grp ENUM('fish','mammal','bird') NOT NULL,
    id MEDIUMINT NOT NULL AUTO_INCREMENT,
    name CHAR(30) NOT NULL,
    PRIMARY KEY (grp,id)
) ENGINE=MyISAM;

INSERT INTO animals (grp,name) VALUES
    ('mammal','dog'),('mammal','cat'),
    ('bird','penguin'),('fish','lax'),('mammal','whale'),
    ('bird','ostrich');

SELECT * FROM animals ORDER BY grp,id;
Which returns:

+--------+----+---------+
| grp    | id | name    |
+--------+----+---------+
| fish   |  1 | lax     |
| mammal |  1 | dog     |
| mammal |  2 | cat     |
| mammal |  3 | whale   |
| bird   |  1 | penguin |
| bird   |  2 | ostrich |
+--------+----+---------+

In this case (when the AUTO_INCREMENT column is part of a multiple-column index), AUTO_INCREMENT values are reused if you delete the row with the biggest AUTO_INCREMENT value in any group. This happens even for MyISAM tables, for which AUTO_INCREMENT values normally are not reused.

If the AUTO_INCREMENT column is part of multiple indexes, MySQL generates sequence values using the index that begins with the AUTO_INCREMENT column, if there is one. For example, if the animals table contained indexes PRIMARY KEY (grp, id) and INDEX (id), MySQL would ignore the PRIMARY KEY for generating sequence values. As a result, the table would contain a single sequence, not a sequence per grp value.

Further Reading

More information about AUTO_INCREMENT is available here:

How to assign the AUTO_INCREMENT attribute to a column: Section 13.1.20, “CREATE TABLE Statement”, and Section 13.1.9, “ALTER TABLE Statement”.

How AUTO_INCREMENT behaves depending on the NO_AUTO_VALUE_ON_ZERO SQL mode: Section 5.1.11, “Server SQL Modes”.

How to use the LAST_INSERT_ID() function to find the row that contains the most recent AUTO_INCREMENT value: Section 12.16, “Information Functions”.

Setting the AUTO_INCREMENT value to be used: Section 5.1.8, “Server System Variables”.

Section 15.6.1.6, “AUTO_INCREMENT Handling in InnoDB”

AUTO_INCREMENT and replication: Section 17.5.1.1, “Replication and AUTO_INCREMENT”.

Server-system variables related to AUTO_INCREMENT (auto_increment_increment and auto_increment_offset) that can be used for replication: Section 5.1.8, “Server System Variables”.


3.7 Using MySQL with Apache
============================
There are programs that let you authenticate your users from a MySQL database and also let you write your log files into a MySQL table.

You can change the Apache logging format to be easily readable by MySQL by putting the following into the Apache configuration file:

LogFormat \
        "\"%h\",%{%Y%m%d%H%M%S}t,%>s,\"%b\",\"%{Content-Type}o\",  \
        \"%U\",\"%{Referer}i\",\"%{User-Agent}i\""
To load a log file in that format into MySQL, you can use a statement something like this:

LOAD DATA INFILE '/local/access_log' INTO TABLE tbl_name
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' ESCAPED BY '\\'
The named table should be created to have columns that correspond to those that the LogFormat line writes to the log file.

Chapter 4 MySQL Programs
=========================
This chapter provides a brief overview of the MySQL command-line programs provided by Oracle Corporation. It also discusses the general syntax for specifying options when you run these programs. Most programs have options that are specific to their own operation, but the option syntax is similar for all of them. Finally, the chapter provides more detailed descriptions of individual programs, including which options they recognize.

4.2.2.1 Using Options on the Command Line
For a long option that takes a value, separate the option name and the value by an = sign. For a short option that takes a value, the option value can immediately follow the option letter, or there can be a space between: -hlocalhost and -h localhost are equivalent. An exception to this rule is the option for specifying your MySQL password. This option can be given in long form as --password=pass_val or as --password. In the latter case (with no password value given), the program interactively prompts you for the password. The password option also may be given in short form as -ppass_val or as -p. However, for the short form, if the password value is given, it must follow the option letter with no intervening space: If a space follows the option letter, the program has no way to tell whether a following argument is supposed to be the password value or some other kind of argument. Consequently, the following two commands have two completely different meanings:

mysql -ptest
mysql -p test
The first command instructs mysql to use a password value of test, but specifies no default database. The second instructs mysql to prompt for the password value and to use test as the default database.

Within option names, dash (-) and underscore (_) may be used interchangeably. For example, --skip-grant-tables and --skip_grant_tables are equivalent. (However, the leading dashes cannot be given as underscores.)

The MySQL server has certain command options that may be specified only at startup, and a set of system variables, some of which may be set at startup, at runtime, or both. System variable names use underscores rather than dashes, and when referenced at runtime (for example, using SET or SELECT statements), must be written using underscores:

SET GLOBAL general_log = ON;
SELECT @@GLOBAL.general_log;

At server startup, the syntax for system variables is the same as for command options, so within variable names, dashes and underscores may be used interchangeably. For example, --general_log=ON and --general-log=ON are equivalent. (This is also true for system variables set within option files.)

For options that take a numeric value, the value can be given with a suffix of K, M, or G to indicate a multiplier of 1024, 10242 or 10243. As of MySQL 8.0.14, a suffix can also be T, P, and E to indicate a multiplier of 10244, 10245 or 10246. Suffix letters can be uppercase or lowercase.

For example, the following command tells mysqladmin to ping the server 1024 times, sleeping 10 seconds between each ping:

mysqladmin --count=1K --sleep=10 ping
When specifying file names as option values, avoid the use of the ~ shell metacharacter. It might not be interpreted as you expect.

Option values that contain spaces must be quoted when given on the command line. For example, the --execute (or -e) option can be used with mysql to pass one or more semicolon-separated SQL statements to the server. When this option is used, mysql executes the statements in the option value and exits. The statements must be enclosed by quotation marks. For example:
(base) Utsavs-MacBook-Air:~ utsav$ mysql -u root -p --local-infile menagerie -e "SELECT VERSION(); SELECT NOW()"
Enter password:
+-----------+
| VERSION() |
+-----------+
| 8.0.18    |
+-----------+
+---------------------+
| NOW()               |
+---------------------+
| 2021-07-11 08:44:52 |
+---------------------+
(base) Utsavs-MacBook-Air:~ utsav$

Note
The long form (--execute) is followed by an equal sign (=).

To use quoted values within a statement, you must either escape the inner quotation marks, or use a different type of quotation marks within the statement from those used to quote the statement itself. The capabilities of your command processor dictate your choices for whether you can use single or double quotation marks and the syntax for escaping quote characters. For example, if your command processor supports quoting with single or double quotation marks, you can use double quotation marks around the statement, and single quotation marks for any quoted values within the statement.

mysql> select user();
+----------------+
| user()         |
+----------------+
| root@localhost |
+----------------+
1 row in set (0.00 sec)

Chapter 8 Optimization
======================
This chapter explains how to optimize MySQL performance and provides examples. Optimization involves configuring, tuning, and measuring performance, at several levels. Depending on your job role (developer, DBA, or a combination of both), you might optimize at the level of individual SQL statements, entire applications, a single database server, or multiple networked database servers. Sometimes you can be proactive and plan in advance for performance, while other times you might troubleshoot a configuration or code issue after a problem occurs. Optimizing CPU and memory usage can also improve scalability, allowing the database to handle more load without slowing down.

8.1 Optimization Overview

Database performance depends on several factors at the database level, such as tables, queries, and configuration settings. These software constructs result in CPU and I/O operations at the hardware level, which you must minimize and make as efficient as possible. As you work on database performance, you start by learning the high-level rules and guidelines for the software side, and measuring performance using wall-clock time. As you become an expert, you learn more about what happens internally, and start measuring things such as CPU cycles and I/O operations.

Typical users aim to get the best database performance out of their existing software and hardware configurations. Advanced users look for opportunities to improve the MySQL software itself, or develop their own storage engines and hardware appliances to expand the MySQL ecosystem.

Optimizing at the Database Level

Optimizing at the Hardware Level

Balancing Portability and Performance

Optimizing at the Database Level

The most important factor in making a database application fast is its basic design:

Are the tables structured properly? In particular, do the columns have the right data types, and does each table have the appropriate columns for the type of work? For example, applications that perform frequent updates often have many tables with few columns, while applications that analyze large amounts of data often have few tables with many columns.

Are the right indexes in place to make queries efficient?

Are you using the appropriate storage engine for each table, and taking advantage of the strengths and features of each storage engine you use? In particular, the choice of a transactional storage engine such as InnoDB or a nontransactional one such as MyISAM can be very important for performance and scalability.

Note
InnoDB is the default storage engine for new tables. In practice, the advanced InnoDB performance features mean that InnoDB tables often outperform the simpler MyISAM tables, especially for a busy database.

Does each table use an appropriate row format? This choice also depends on the storage engine used for the table. In particular, compressed tables use less disk space and so require less disk I/O to read and write the data. Compression is available for all kinds of workloads with InnoDB tables, and for read-only MyISAM tables.

Does the application use an appropriate locking strategy? For example, by allowing shared access when possible so that database operations can run concurrently, and requesting exclusive access when appropriate so that critical operations get top priority. Again, the choice of storage engine is significant. The InnoDB storage engine handles most locking issues without involvement from you, allowing for better concurrency in the database and reducing the amount of experimentation and tuning for your code.

Are all memory areas used for caching sized correctly? That is, large enough to hold frequently accessed data, but not so large that they overload physical memory and cause paging. The main memory areas to configure are the InnoDB buffer pool and the MyISAM key cache.

Optimizing at the Hardware Level

Any database application eventually hits hardware limits as the database becomes more and more busy. A DBA must evaluate whether it is possible to tune the application or reconfigure the server to avoid these bottlenecks, or whether more hardware resources are required. System bottlenecks typically arise from these sources:

Disk seeks. It takes time for the disk to find a piece of data. With modern disks, the mean time for this is usually lower than 10ms, so we can in theory do about 100 seeks a second. This time improves slowly with new disks and is very hard to optimize for a single table. The way to optimize seek time is to distribute the data onto more than one disk.

Disk reading and writing. When the disk is at the correct position, we need to read or write the data. With modern disks, one disk delivers at least 10–20MB/s throughput. This is easier to optimize than seeks because you can read in parallel from multiple disks.

CPU cycles. When the data is in main memory, we must process it to get our result. Having large tables compared to the amount of memory is the most common limiting factor. But with small tables, speed is usually not the problem.

Memory bandwidth. When the CPU needs more data than can fit in the CPU cache, main memory bandwidth becomes a bottleneck. This is an uncommon bottleneck for most systems, but one to be aware of.

Balancing Portability and Performance

To use performance-oriented SQL extensions in a portable MySQL program, you can wrap MySQL-specific keywords in a statement within /*! */ comment delimiters. Other SQL servers ignore the commented keywords. For information about writing comments, see Section 9.7, “Comments”.

8.2 Optimizing SQL Statements
-----------------------------
The core logic of a database application is performed through SQL statements, whether issued directly through an interpreter or submitted behind the scenes through an API. The tuning guidelines in this section help to speed up all kinds of MySQL applications. The guidelines cover SQL operations that read and write data, the behind-the-scenes overhead for SQL operations in general, and operations used in specific scenarios such as database monitoring.

8.2.1 Optimizing SELECT Statements
-----------------------------------
Queries, in the form of SELECT statements, perform all the lookup operations in the database. Tuning these statements is a top priority, whether to achieve sub-second response times for dynamic web pages, or to chop hours off the time to generate huge overnight reports.

Besides SELECT statements, the tuning techniques for queries also apply to constructs such as CREATE TABLE...AS SELECT, INSERT INTO...SELECT, and WHERE clauses in DELETE statements. Those statements have additional performance considerations because they combine write operations with the read-oriented query operations.

NDB Cluster supports a join pushdown optimization whereby a qualifying join is sent in its entirety to NDB Cluster data nodes, where it can be distributed among them and executed in parallel. For more information about this optimization, see Conditions for NDB pushdown joins.

The main considerations for optimizing queries are:

To make a slow SELECT ... WHERE query faster, the first thing to check is whether you can add an index. Set up indexes on columns used in the WHERE clause, to speed up evaluation, filtering, and the final retrieval of results. To avoid wasted disk space, construct a small set of indexes that speed up many related queries used in your application.

Indexes are especially important for queries that reference different tables, using features such as joins and foreign keys. You can use the EXPLAIN statement to determine which indexes are used for a SELECT. See Section 8.3.1, “How MySQL Uses Indexes” and Section 8.8.1, “Optimizing Queries with EXPLAIN”.

Isolate and tune any part of the query, such as a function call, that takes excessive time. Depending on how the query is structured, a function could be called once for every row in the result set, or even once for every row in the table, greatly magnifying any inefficiency.

Minimize the number of full table scans in your queries, particularly for big tables.

Keep table statistics up to date by using the ANALYZE TABLE statement periodically, so the optimizer has the information needed to construct an efficient execution plan.

Learn the tuning techniques, indexing techniques, and configuration parameters that are specific to the storage engine for each table. Both InnoDB and MyISAM have sets of guidelines for enabling and sustaining high performance in queries. For details, see Section 8.5.6, “Optimizing InnoDB Queries” and Section 8.6.1, “Optimizing MyISAM Queries”.

You can optimize single-query transactions for InnoDB tables, using the technique in Section 8.5.3, “Optimizing InnoDB Read-Only Transactions”.

Avoid transforming the query in ways that make it hard to understand, especially if the optimizer does some of the same transformations automatically.

If a performance issue is not easily solved by one of the basic guidelines, investigate the internal details of the specific query by reading the EXPLAIN plan and adjusting your indexes, WHERE clauses, join clauses, and so on. (When you reach a certain level of expertise, reading the EXPLAIN plan might be your first step for every query.)

Adjust the size and properties of the memory areas that MySQL uses for caching. With efficient use of the InnoDB buffer pool, MyISAM key cache, and the MySQL query cache, repeated queries run faster because the results are retrieved from memory the second and subsequent times.

Even for a query that runs fast using the cache memory areas, you might still optimize further so that they require less cache memory, making your application more scalable. Scalability means that your application can handle more simultaneous users, larger requests, and so on without experiencing a big drop in performance.

Deal with locking issues, where the speed of your query might be affected by other sessions accessing the tables at the same time.

INDEX
------
A data structure that provides a fast lookup capability for rows of a table, typically by forming a tree structure (B-tree) representing all the values of a particular column or set of columns.

InnoDB tables always have a clustered index representing the primary key. They can also have one or more secondary indexes defined on one or more columns. Depending on their structure, secondary indexes can be classified as partial, column, or composite indexes.

Indexes are a crucial aspect of query performance. Database architects design tables, queries, and indexes to allow fast lookups for data needed by applications. The ideal database design uses a covering index where practical; the query results are computed entirely from the index, without reading the actual table data. Each foreign key constraint also requires an index, to efficiently check whether values exist in both the parent and child tables.

Although a B-tree index is the most common, a different kind of data structure is used for hash indexes, as in the MEMORY storage engine and the InnoDB adaptive hash index. R-tree indexes are used for spatial indexing of multi-dimensional information.

B-tree
------
A tree data structure that is popular for use in database indexes. The structure is kept sorted at all times, enabling fast lookup for exact matches (equals operator) and ranges (for example, greater than, less than, and BETWEEN operators). This type of index is available for most storage engines, such as InnoDB and MyISAM.

Because B-tree nodes can have many children, a B-tree is not the same as a binary tree, which is limited to 2 children per node.

Contrast with hash index, which is only available in the MEMORY storage engine. The MEMORY storage engine can also use B-tree indexes, and you should choose B-tree indexes for MEMORY tables if some queries use range operators.

The use of the term B-tree is intended as a reference to the general class of index design. B-tree structures used by MySQL storage engines may be regarded as variants due to sophistications not present in a classic B-tree design. For related information, refer to the InnoDB Page Structure Fil Header section of the MySQL Internals Manual.


adaptive hash index
--------------------
An optimization for InnoDB tables that can speed up lookups using = and IN operators, by constructing a hash index in memory. MySQL monitors index searches for InnoDB tables, and if queries could benefit from a hash index, it builds one automatically for index pages that are frequently accessed. In a sense, the adaptive hash index configures MySQL at runtime to take advantage of ample main memory, coming closer to the architecture of main-memory databases. This feature is controlled by the innodb_adaptive_hash_index configuration option. Because this feature benefits some workloads and not others, and the memory used for the hash index is reserved in the buffer pool, typically you should benchmark with this feature both enabled and disabled.

The hash index is always built based on an existing B-tree index on the table. MySQL can build a hash index on a prefix of any length of the key defined for the B-tree, depending on the pattern of searches against the index. A hash index can be partial; the whole B-tree index does not need to be cached in the buffer pool.

In MySQL 5.6 and higher, another way to take advantage of fast single-value lookups with InnoDB tables is to use the InnoDB memcached plugin. See Section 15.20, “InnoDB memcached Plugin” for details.

hash index
----------
A type of index intended for queries that use equality operators, rather than range operators such as greater-than or BETWEEN. It is available for MEMORY tables. Although hash indexes are the default for MEMORY tables for historic reasons, that storage engine also supports B-tree indexes, which are often a better choice for general-purpose queries.

MySQL includes a variant of this index type, the adaptive hash index, that is constructed automatically for InnoDB tables if needed based on runtime conditions.

InnoDB
-------
A MySQL component that combines high performance with transactional capability for reliability, robustness, and concurrent access. It embodies the ACID design philosophy. Represented as a storage engine; it handles tables created or altered with the ENGINE=INNODB clause. See Chapter 15, The InnoDB Storage Engine for architectural details and administration procedures, and Section 8.5, “Optimizing for InnoDB Tables” for performance advice.

In MySQL 5.5 and higher, InnoDB is the default storage engine for new tables and the ENGINE=INNODB clause is not required.

InnoDB tables are ideally suited for hot backups. See Section 30.2, “MySQL Enterprise Backup Overview” for information about the MySQL Enterprise Backup product for backing up MySQL servers without interrupting normal processing.

ACID
----
An acronym standing for atomicity, consistency, isolation, and durability. These properties are all desirable in a database system, and are all closely tied to the notion of a transaction. The transactional features of InnoDB adhere to the ACID principles.

Transactions are atomic units of work that can be committed or rolled back. When a transaction makes multiple changes to the database, either all the changes succeed when the transaction is committed, or all the changes are undone when the transaction is rolled back.

The database remains in a consistent state at all times — after each commit or rollback, and while transactions are in progress. If related data is being updated across multiple tables, queries see either all old values or all new values, not a mix of old and new values.

Transactions are protected (isolated) from each other while they are in progress; they cannot interfere with each other or see each other's uncommitted data. This isolation is achieved through the locking mechanism. Experienced users can adjust the isolation level, trading off less protection in favor of increased performance and concurrency, when they can be sure that the transactions really do not interfere with each other.

The results of transactions are durable: once a commit operation succeeds, the changes made by that transaction are safe from power failures, system crashes, race conditions, or other potential dangers that many non-database applications are vulnerable to. Durability typically involves writing to disk storage, with a certain amount of redundancy to protect against power failures or software crashes during write operations. (In InnoDB, the doublewrite buffer assists with durability.)

atomic
-----
In the SQL context, transactions are units of work that either succeed entirely (when committed) or have no effect at all (when rolled back). The indivisible ("atomic") property of transactions is the “A” in the acronym ACID.

commit
-------
A SQL statement that ends a transaction, making permanent any changes made by the transaction. It is the opposite of rollback, which undoes any changes made in the transaction.

InnoDB uses an optimistic mechanism for commits, so that changes can be written to the data files before the commit actually occurs. This technique makes the commit itself faster, with the tradeoff that more work is required in case of a rollback.

By default, MySQL uses the autocommit setting, which automatically issues a commit following each SQL statement.

autocommit
-----------
A setting that causes a commit operation after each SQL statement. This mode is not recommended for working with InnoDB tables with transactions that span several statements. It can help performance for read-only transactions on InnoDB tables, where it minimizes overhead from locking and generation of undo data, especially in MySQL 5.6.4 and up. It is also appropriate for working with MyISAM tables, where transactions are not applicable.

optimistic
----------
A methodology that guides low-level implementation decisions for a relational database system. The requirements of performance and concurrency in a relational database mean that operations must be started or dispatched quickly. The requirements of consistency and referential integrity mean that any operation could fail: a transaction might be rolled back, a DML operation could violate a constraint, a request for a lock could cause a deadlock, a network error could cause a timeout. An optimistic strategy is one that assumes most requests or attempts succeed, so that relatively little work is done to prepare for the failure case. When this assumption is true, the database does little unnecessary work; when requests do fail, extra work must be done to clean up and undo changes.

InnoDB uses optimistic strategies for operations such as locking and commits. For example, data changed by a transaction can be written to the data files before the commit occurs, making the commit itself very fast, but requiring more work to undo the changes if the transaction is rolled back.

The opposite of an optimistic strategy is a pessimistic one, where a system is optimized to deal with operations that are unreliable and frequently unsuccessful. This methodology is rare in a database system, because so much care goes into choosing reliable hardware, networks, and algorithms.

concurrency
------------
The ability of multiple operations (in database terminology, transactions) to run simultaneously, without interfering with each other. Concurrency is also involved with performance, because ideally the protection for multiple simultaneous transactions works with a minimum of performance overhead, using efficient mechanisms for locking.

locking
-------
The system of protecting a transaction from seeing or changing data that is being queried or changed by other transactions. The locking strategy must balance reliability and consistency of database operations (the principles of the ACID philosophy) against the performance needed for good concurrency. Fine-tuning the locking strategy often involves choosing an isolation level and ensuring all your database operations are safe and reliable for that isolation level.

rollback
--------
A SQL statement that ends a transaction, undoing any changes made by the transaction. It is the opposite of commit, which makes permanent any changes made in the transaction.

By default, MySQL uses the autocommit setting, which automatically issues a commit following each SQL statement. You must change this setting before you can use the rollback technique.

transaction
------------
Transactions are atomic units of work that can be committed or rolled back. When a transaction makes multiple changes to the database, either all the changes succeed when the transaction is committed, or all the changes are undone when the transaction is rolled back.

Database transactions, as implemented by InnoDB, have properties that are collectively known by the acronym ACID, for atomicity, consistency, isolation, and durability.

8.2.1.1 WHERE Clause Optimization
----------------------------------
This section discusses optimizations that can be made for processing WHERE clauses. The examples use SELECT statements, but the same optimizations apply for WHERE clauses in DELETE and UPDATE statements.

You might be tempted to rewrite your queries to make arithmetic operations faster, while sacrificing readability. Because MySQL does similar optimizations automatically, you can often avoid this work, and leave the query in a more understandable and maintainable form. Some of the optimizations performed by MySQL follow:

Removal of unnecessary parentheses:
   ((a AND b) AND c OR (((a AND b) AND (c AND d))))
-> (a AND b AND c) OR (a AND b AND c AND d)

Constant folding:
   (a<b AND b=c) AND a=5
-> b>5 AND b=c AND a=5

Constant condition removal:
   (b>=5 AND b=5) OR (b=6 AND 5=5) OR (b=7 AND 5=6)
-> b=5 OR b=6

Constant expressions used by indexes are evaluated only once.

Beginning with MySQL 8.0.16, comparisons of columns of numeric types with constant values are checked and folded or removed for invalid or out-of-rage values:

Little knowledge of bit wise operators:
mysql> select 1 | 2, 1 << 2;
+-------+--------+
| 1 | 2 | 1 << 2 |
+-------+--------+
|     3 |      4 |
+-------+--------+
1 row in set (0.00 sec)

mysql> select 1 | 2, 1 << 2, BIT_COUNT(2);
+-------+--------+--------------+
| 1 | 2 | 1 << 2 | BIT_COUNT(2) |
+-------+--------+--------------+
|     3 |      4 |            1 |
+-------+--------+--------------+
1 row in set (0.00 sec)

mysql> select 1 | 2, 1 << 2, BIT_COUNT(3);
+-------+--------+--------------+
| 1 | 2 | 1 << 2 | BIT_COUNT(3) |
+-------+--------+--------------+
|     3 |      4 |            2 |
+-------+--------+--------------+
1 row in set (0.00 sec)

COUNT(*) on a single table without a WHERE is retrieved directly from the table information for MyISAM and MEMORY tables. This is also done for any NOT NULL expression when used with only one table.
Early detection of invalid constant expressions. MySQL quickly detects that some SELECT statements are impossible and returns no rows.
HAVING is merged with WHERE if you do not use GROUP BY or aggregate functions (COUNT(), MIN(), and so on).
For each table in a join, a simpler WHERE is constructed to get a fast WHERE evaluation for the table and also to skip rows as soon as possible.
 All constant tables are read first before any other tables in the query. A constant table is any of the following:
An empty table or a table with one row.
A table that is used with a WHERE clause on a PRIMARY KEY or a UNIQUE index, where all index parts are compared to constant expressions and are defined as NOT NULL.
All of the following tables are used as constant tables:

SELECT * FROM t WHERE primary_key=1;
SELECT * FROM t1,t2
  WHERE t1.primary_key=1 AND t2.primary_key=t1.id;

The best join combination for joining the tables is found by trying all possibilities. If all columns in ORDER BY and GROUP BY clauses come from the same table, that table is preferred first when joining.

If there is an ORDER BY clause and a different GROUP BY clause, or if the ORDER BY or GROUP BY contains columns from tables other than the first table in the join queue, a temporary table is created.

If you use the SQL_SMALL_RESULT modifier, MySQL uses an in-memory temporary table.

Each table index is queried, and the best index is used unless the optimizer believes that it is more efficient to use a table scan. At one time, a scan was used based on whether the best index spanned more than 30% of the table, but a fixed percentage no longer determines the choice between using an index or a scan. The optimizer now is more complex and bases its estimate on additional factors such as table size, number of rows, and I/O block size.

In some cases, MySQL can read rows from the index without even consulting the data file. If all columns used from the index are numeric, only the index tree is used to resolve the query.

Before each row is output, those that do not match the HAVING clause are skipped.

Some examples of queries that are very fast:


SELECT COUNT(*) FROM tbl_name;

SELECT MIN(key_part1),MAX(key_part1) FROM tbl_name;

SELECT MAX(key_part2) FROM tbl_name
  WHERE key_part1=constant;

SELECT ... FROM tbl_name
  ORDER BY key_part1,key_part2,... LIMIT 10;

SELECT ... FROM tbl_name
  ORDER BY key_part1 DESC, key_part2 DESC, ... LIMIT 10;

 MySQL resolves the following queries using only the index tree, assuming that the indexed columns are numeric:

  SELECT key_part1,key_part2 FROM tbl_name WHERE key_part1=val;

  SELECT COUNT(*) FROM tbl_name
    WHERE key_part1=val1 AND key_part2=val2;

  SELECT MAX(key_part2) FROM tbl_name GROUP BY key_part1;

The following queries use indexing to retrieve the rows in sorted order without a separate sorting pass:

SELECT ... FROM tbl_name
  ORDER BY key_part1,key_part2,... ;

SELECT ... FROM tbl_name
  ORDER BY key_part1 DESC, key_part2 DESC, ... ;

Chapter 9 Language Structure
==============================
This chapter discusses the rules for writing the following elements of SQL statements when using MySQL:
Literal values such as strings and numbers
Identifiers such as database, table, and column names
Keywords and reserved words
User-defined and system variables
Expressions
Query attributes
Comments

9.1 Literal Values
------------------
This section describes how to write literal values in MySQL. These include strings, numbers, hexadecimal and bit values, boolean values, and NULL. The section also covers various nuances that you may encounter when dealing with these basic types in MySQL.

9.1.1 String Literals
----------------------
A string is a sequence of bytes or characters, enclosed within either single quote (') or double quote (") characters. Examples:
'a string'
"another string"

Quoted strings placed next to each other are concatenated to a single string. The following lines are equivalent:
'a string'
'a' ' ' 'string'

mysql> select 'a string';
+----------+
| a string |
+----------+
| a string |
+----------+
1 row in set (0.00 sec)

mysql> select 'a string' 'concatenate string';
+----------------------------+
| a string                   |
+----------------------------+
| a stringconcatenate string |
+----------------------------+
1 row in set (0.00 sec)

mysql> select 'a string', 'concatenate string';
+----------+--------------------+
| a string | concatenate string |
+----------+--------------------+
| a string | concatenate string |
+----------+--------------------+
1 row in set (0.00 sec)

If the ANSI_QUOTES SQL mode is enabled, string literals can be quoted only within single quotation marks because a string quoted within double quotation marks is interpreted as an identifier.

A binary string is a string of bytes. Every binary string has a character set and collation named binary. A nonbinary string is a string of characters. It has a character set other than binary and a collation that is compatible with the character set.

For both types of strings, comparisons are based on the numeric values of the string unit. For binary strings, the unit is the byte; comparisons use numeric byte values. For nonbinary strings, the unit is the character and some character sets support multibyte characters; comparisons use numeric character code values. Character code ordering is a function of the string collation.

A character string literal may have an optional character set introducer and COLLATE clause, to designate it as a string that uses a particular character set and collation:

[_charset_name]'string' [COLLATE collation_name]

Within a string, certain sequences have special meaning unless the NO_BACKSLASH_ESCAPES SQL mode is enabled. Each of these sequences begins with a backslash (\), known as the escape character. MySQL recognizes the escape sequences shown in Table 9.1, “Special Character Escape Sequences”. For all other escape sequences, backslash is ignored. That is, the escaped character is interpreted as if it was not escaped. For example, \x is just x. These sequences are case-sensitive. For example, \b is interpreted as a backspace, but \B is interpreted as B. Escape processing is done according to the character set indicated by the character_set_connection system variable. This is true even for strings that are preceded by an introducer that indicates a different character set, as discussed in

Table 9.1 Special Character Escape Sequences

Escape Sequence	Character Represented by Sequence
\0	An ASCII NUL (X'00') character
\'	A single quote (') character
\"	A double quote (") character
\b	A backspace character
\n	A newline (linefeed) character
\r	A carriage return character
\t	A tab character
\Z	ASCII 26 (Control+Z); see note following the table
\\	A backslash (\) character
\%	A % character; see note following the table
\_	A _ character; see note following the table

The ASCII 26 character can be encoded as \Z to enable you to work around the problem that ASCII 26 stands for END-OF-FILE on Windows. ASCII 26 within a file causes problems if you try to use mysql db_name < file_name.

The \% and \_ sequences are used to search for literal instances of % and _ in pattern-matching contexts where they would otherwise be interpreted as wildcard characters. See the description of the LIKE operator in Section 12.8.1, “String Comparison Functions and Operators”. If you use \% or \_ outside of pattern-matching contexts, they evaluate to the strings \% and \_, not to % and _.

There are several ways to include quote characters within a string:

A ' inside a string quoted with ' may be written as ''.

A " inside a string quoted with " may be written as "".

Precede the quote character by an escape character (\).

A ' inside a string quoted with " needs no special treatment and need not be doubled or escaped. In the same way, " inside a string quoted with ' needs no special treatment.

The following SELECT statements demonstrate how quoting and escaping work:

mysql> SELECT 'hello', '"hello"', '""hello""', 'hel''lo', '\'hello';
+-------+---------+-----------+--------+--------+
| hello | "hello" | ""hello"" | hel'lo | 'hello |
+-------+---------+-----------+--------+--------+
| hello | "hello" | ""hello"" | hel'lo | 'hello |
+-------+---------+-----------+--------+--------+
1 row in set (0.00 sec)

mysql> SELECT 'hello', '"hello"', '""hello""', 'hel' 'lo', '\'hello';
+-------+---------+-----------+-------+--------+
| hello | "hello" | ""hello"" | hel   | 'hello |
+-------+---------+-----------+-------+--------+
| hello | "hello" | ""hello"" | hello | 'hello |
+-------+---------+-----------+-------+--------+
1 row in set (0.00 sec)

mysql> SELECT "hello", "'hello'", "''hello''", "hel""lo", "\"hello";
+-------+---------+-----------+--------+--------+
| hello | 'hello' | ''hello'' | hel"lo | "hello |
+-------+---------+-----------+--------+--------+

mysql> SELECT 'This\nIs\nFour\nLines';
+--------------------+
| This
Is
Four
Lines |
+--------------------+

mysql> SELECT 'disappearing\ backslash';
+------------------------+
| disappearing backslash |
+------------------------+

To insert binary data into a string column (such as a BLOB column), you should represent certain characters by escape sequences. Backslash (\) and the quote character used to quote the string must be escaped. In certain client environments, it may also be necessary to escape NUL or Control+Z. The mysql client truncates quoted strings containing NUL characters if they are not escaped, and Control+Z may be taken for END-OF-FILE on Windows if not escaped. For the escape sequences that represent each of these characters, see Table 9.1, “Special Character Escape Sequences”.

When writing application programs, any string that might contain any of these special characters must be properly escaped before the string is used as a data value in an SQL statement that is sent to the MySQL server. You can do this in two ways:

Process the string with a function that escapes the special characters. In a C program, you can use the mysql_real_escape_string_quote() C API function to escape characters. See mysql_real_escape_string_quote(). Within SQL statements that construct other SQL statements, you can use the QUOTE() function. The Perl DBI interface provides a quote method to convert special characters to the proper escape sequences. See Section 29.9, “MySQL Perl API”. Other language interfaces may provide a similar capability.

As an alternative to explicitly escaping special characters, many MySQL APIs provide a placeholder capability that enables you to insert special markers into a statement string, and then bind data values to them when you issue the statement. In this case, the API takes care of escaping special characters in the values for you.

9.1.2 Numeric Literals
----------------------
Number literals include exact-value (integer and DECIMAL) literals and approximate-value (floating-point) literals.

Integers are represented as a sequence of digits. Numbers may include . as a decimal separator. Numbers may be preceded by - or + to indicate a negative or positive value, respectively. Numbers represented in scientific notation with a mantissa and exponent are approximate-value numbers.

Exact-value numeric literals have an integer part or fractional part, or both. They may be signed. Examples: 1, .2, 3.4, -5, -6.78, +9.10.

Approximate-value numeric literals are represented in scientific notation with a mantissa and exponent. Either or both parts may be signed. Examples: 1.2E3, 1.2E-3, -1.2E3, -1.2E-3.

Two numbers that look similar may be treated differently. For example, 2.34 is an exact-value (fixed-point) number, whereas 2.34E0 is an approximate-value (floating-point) number.

The DECIMAL data type is a fixed-point type and calculations are exact. In MySQL, the DECIMAL type has several synonyms: NUMERIC, DEC, FIXED. The integer types also are exact-value types. For more information about exact-value calculations, see Section 12.25, “Precision Math”.

The FLOAT and DOUBLE data types are floating-point types and calculations are approximate. In MySQL, types that are synonymous with FLOAT or DOUBLE are DOUBLE PRECISION and REAL.

An integer may be used in floating-point context; it is interpreted as the equivalent floating-point number.

9.1.3 Date and Time Literals
------------------------------
Date and time values can be represented in several formats, such as quoted strings or as numbers, depending on the exact type of the value and other factors. For example, in contexts where MySQL expects a date, it interprets any of '2015-07-21', '20150721', and 20150721 as a date.

Date and time values can be represented in several formats, such as quoted strings or as numbers, depending on the exact type of the value and other factors. For example, in contexts where MySQL expects a date, it interprets any of '2015-07-21', '20150721', and 20150721 as a date.

This section describes the acceptable formats for date and time literals. For more information about the temporal data types, such as the range of permitted values.

Standard SQL and ODBC Date and Time Literals.  Standard SQL requires temporal literals to be specified using a type keyword and a string. The space between the keyword and string is optional.

DATE 'str'
TIME 'str'
TIMESTAMP 'str'

MySQL recognizes but, unlike standard SQL, does not require the type keyword. Applications that are to be standard-compliant should include the type keyword for temporal literals.

MySQL also recognizes the ODBC syntax corresponding to the standard SQL syntax:

{ d 'str' }
{ t 'str' }
{ ts 'str' }

MySQL uses the type keywords and the ODBC constructions to produce DATE, TIME, and DATETIME values, respectively, including a trailing fractional seconds part if specified. The TIMESTAMP syntax produces a DATETIME value in MySQL because DATETIME has a range that more closely corresponds to the standard SQL TIMESTAMP type, which has a year range from 0001 to 9999. (The MySQL TIMESTAMP year range is 1970 to 2038.)

String and Numeric Literals in Date and Time Context.  MySQL recognizes DATE values in these formats:

As a string in either 'YYYY-MM-DD' or 'YY-MM-DD' format. A “relaxed” syntax is permitted: Any punctuation character may be used as the delimiter between date parts. For example, '2012-12-31', '2012/12/31', '2012^12^31', and '2012@12@31' are equivalent.

As a string with no delimiters in either 'YYYYMMDD' or 'YYMMDD' format, provided that the string makes sense as a date. For example, '20070523' and '070523' are interpreted as '2007-05-23', but '071332' is illegal (it has nonsensical month and day parts) and becomes '0000-00-00'.

As a number in either YYYYMMDD or YYMMDD format, provided that the number makes sense as a date. For example, 19830905 and 830905 are interpreted as '1983-09-05'.

A DATETIME or TIMESTAMP value can include a trailing fractional seconds part in up to microseconds (6 digits) precision. The fractional part should always be separated from the rest of the time by a decimal point; no other fractional seconds delimiter is recognized. For information about fractional seconds support in MySQL, see Section 11.2.6, “Fractional Seconds in Time Values”.

Dates containing two-digit year values are ambiguous because the century is unknown. MySQL interprets two-digit year values using these rules:

Year values in the range 70-99 become 1970-1999.

Year values in the range 00-69 become 2000-2069.

See also Section 11.2.8, “2-Digit Years in Dates”.

For values specified as strings that include date part delimiters, it is unnecessary to specify two digits for month or day values that are less than 10. '2015-6-9' is the same as '2015-06-09'. Similarly, for values specified as strings that include time part delimiters, it is unnecessary to specify two digits for hour, minute, or second values that are less than 10. '2015-10-30 1:2:3' is the same as '2015-10-30 01:02:03'.

Values specified as numbers should be 6, 8, 12, or 14 digits long. If a number is 8 or 14 digits long, it is assumed to be in YYYYMMDD or YYYYMMDDhhmmss format and that the year is given by the first 4 digits. If the number is 6 or 12 digits long, it is assumed to be in YYMMDD or YYMMDDhhmmss format and that the year is given by the first 2 digits. Numbers that are not one of these lengths are interpreted as though padded with leading zeros to the closest length.

Values specified as nondelimited strings are interpreted according their length. For a string 8 or 14 characters long, the year is assumed to be given by the first 4 characters. Otherwise, the year is assumed to be given by the first 2 characters. The string is interpreted from left to right to find year, month, day, hour, minute, and second values, for as many parts as are present in the string. This means you should not use strings that have fewer than 6 characters. For example, if you specify '9903', thinking that represents March, 1999, MySQL converts it to the “zero” date value. This occurs because the year and month values are 99 and 03, but the day part is completely missing. However, you can explicitly specify a value of zero to represent missing month or day parts. For example, to insert the value '1999-03-00', use '990300'.

MySQL recognizes TIME values in these formats:

As a string in 'D hh:mm:ss' format. You can also use one of the following “relaxed” syntaxes: 'hh:mm:ss', 'hh:mm', 'D hh:mm', 'D hh', or 'ss'. Here D represents days and can have a value from 0 to 34.

As a string with no delimiters in 'hhmmss' format, provided that it makes sense as a time. For example, '101112' is understood as '10:11:12', but '109712' is illegal (it has a nonsensical minute part) and becomes '00:00:00'.

As a number in hhmmss format, provided that it makes sense as a time. For example, 101112 is understood as '10:11:12'. The following alternative formats are also understood: ss, mmss, or hhmmss.

A trailing fractional seconds part is recognized in the 'D hh:mm:ss.fraction', 'hh:mm:ss.fraction', 'hhmmss.fraction', and hhmmss.fraction time formats, where fraction is the fractional part in up to microseconds (6 digits) precision. The fractional part should always be separated from the rest of the time by a decimal point; no other fractional seconds delimiter is recognized. For information about fractional seconds support in MySQL, see Section 11.2.6, “Fractional Seconds in Time Values”.

For TIME values specified as strings that include a time part delimiter, it is unnecessary to specify two digits for hours, minutes, or seconds values that are less than 10. '8:3:2' is the same as '08:03:02'.

Beginning with MySQL 8.0.19, you can specify a time zone offset when inserting TIMESTAMP and DATETIME values into a table. The offset is appended to the time part of a datetime literal, with no intravening spaces, and uses the same format used for setting the time_zone system variable, with the following exceptions:

For hour values less than than 10, a leading zero is required.

The value '-00:00' is rejected.

Time zone names such as 'EET' and 'Asia/Shanghai' cannot be used; 'SYSTEM' also cannot be used in this context.

The value inserted must not have a zero for the month part, the day part, or both parts. This is enforced beginning with MySQL 8.0.22, regardless of the server SQL mode setting.

This example illustrates inserting datetime values with time zone offsets into TIMESTAMP and DATETIME columns using different time_zone settings, and then retrieving them:

mysql> CREATE TABLE ts (
    ->     id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,
    ->     col TIMESTAMP NOT NULL
    -> ) AUTO_INCREMENT = 1;

mysql> CREATE TABLE dt (
    ->     id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    ->     col DATETIME NOT NULL
    -> ) AUTO_INCREMENT = 1;

mysql> SET @@time_zone = 'SYSTEM';

mysql> INSERT INTO ts (col) VALUES ('2020-01-01 10:10:10'),
    ->     ('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00');

mysql> SET @@time_zone = '+00:00';

mysql> INSERT INTO ts (col) VALUES ('2020-01-01 10:10:10'),
    ->     ('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00');

mysql> SET @@time_zone = 'SYSTEM';

mysql> INSERT INTO dt (col) VALUES ('2020-01-01 10:10:10'),
    ->     ('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00');

mysql> SET @@time_zone = '+00:00';

mysql> INSERT INTO dt (col) VALUES ('2020-01-01 10:10:10'),
    ->     ('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00');

mysql> SET @@time_zone = 'SYSTEM';

mysql> SELECT @@system_time_zone;
+--------------------+
| @@system_time_zone |
+--------------------+
| EST                |
+--------------------+

mysql> SELECT col, UNIX_TIMESTAMP(col) FROM dt ORDER BY id;
+---------------------+---------------------+
| col                 | UNIX_TIMESTAMP(col) |
+---------------------+---------------------+
| 2020-01-01 10:10:10 |          1577891410 |
| 2019-12-31 23:40:10 |          1577853610 |
| 2020-01-01 13:10:10 |          1577902210 |
| 2020-01-01 10:10:10 |          1577891410 |
| 2020-01-01 04:40:10 |          1577871610 |
| 2020-01-01 18:10:10 |          1577920210 |
+---------------------+---------------------+

mysql> SELECT col, UNIX_TIMESTAMP(col) FROM ts ORDER BY id;
+---------------------+---------------------+
| col                 | UNIX_TIMESTAMP(col) |
+---------------------+---------------------+
| 2020-01-01 10:10:10 |          1577891410 |
| 2019-12-31 23:40:10 |          1577853610 |
| 2020-01-01 13:10:10 |          1577902210 |
| 2020-01-01 05:10:10 |          1577873410 |
| 2019-12-31 23:40:10 |          1577853610 |
| 2020-01-01 13:10:10 |          1577902210 |
+---------------------+---------------------+

The offset is not displayed when selecting a datetime value, even if one was used when inserting it.
The range of supported offset values is -13:59 to +14:00, inclusive.
Datetime literals that include time zone offsets are accepted as parameter values by prepared statements.


