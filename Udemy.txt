SQL Theory -

It's a declarative language i.e you don't have to tell sql how to divide the task and get the things done. It has SQL optimizer to create sub task and do the job.
You just need to tell SQL, get me this data and you are done.
Concentration is what you require rather then how to find what you require.

As a declarative language, it has following 4 components:
1. DDL - Data Definition Language
2. DML - Data Manipulation Language
3. DCL - Data Control Language
4. TCL - Transaction Control Language

DDL
----
SQLs Syntax - Comprises of several types of statements that allow you to perform various commands and operations.

DDL - A set of statements that allow the user to define or modify data structures and objects, such as tables.

Create Statement - Create Database and Database objects like tables.
-----------------
Syntax :
    CREATE OBJECT_TYPE object_name;

Eg. CREATE TABLE table_name (column_name, datetype);
CREATE TABLE  sales (purchare_number, INT);

It is a common practise to have same name of the database and its main table.

Alter Statement - Alter a table by adding removing renaming column names
---------------
Eg. ALTER TABLE sales
ADD COLUMN purchase_date DATE;


DROP/Delete a table/database:
-----------------------------
DROP OBJECT object_name;
DROP TABLE sales;

RENAME - To rename a table/column etc.
-------
RENAME TABLE sales TO customer_sales;

TRUNCATE Statement:
-------------------
To clear all data i.e elements of the table but the keep the schema of the table, we can go with TRUNCATE statement.
TRUNCATE OBJECT object_name;
TRUNCATE TABLE customers;

SQL Keywords: ~ RESERVED WORDS
-------------
ADD, RENAME, ALTER(ADD, REMOVE), DROP, TRUNCATE etc

Keywords in SQL cannot be variable names - objects and databases cannot have names that coincides with SQL keywords.


DML - Data Manipulation Language
================================
The statements that allows us to manipulate data in the tables of a database.

SELECT Statement - used to retrieve data from db objects like tables.
----------------- Eg: SELECT * FROM TABLE;
SELECT * FROM sales;

Generalized version
SELECT ... FROM ... WHERE

INSERT Statement - used to insert data into tables.
-----------------
It goes hand in hand with keywords -- INTO and VALUES

Generalized version
INSERT INTO ... VALUES

Eg
INSERT INTO sales (purchare_number, purchase_date) VALUES (1, '2021-01-01')  -- OR
INSERT INTO sales VALUES (2, '2021-03-02') -- Since we have two columns, values will be entered in positional sequence.

UPDATE Statement - allows you to update/renew existing data of your tables.
----------------
It goes hand in hand with

Generalized version
UPDATE .... SET .... WHERE

Eg. UPDATE sales
    SET  purchase_date='2021-03-01'
    WHERE purchare_number=1;

DELETE Statement - It works similar to the TRUNCATE statement from DDL.
----------------
With a diff - DELETE vs TRUNCATE
TRUNCATE removes all the data from the table i.e clear all elements from the table whereas
DELETE can either remove all elements or we can precisely specify what all rows are to be removed by providing the condition with where clause.

DELETE FROM sale; -- works similar to TRUNCATE i.e
TRUNCATE TABLE sales;

Generalized version -- DELETE ... FROM ... WHERE

But if we want to delete a row based on condition then we can go with:
DELETE FROM sales
WHERE purchase_date='2021-03-01'; -- This will remove only one horizontal entity from the table.

Generalized versions of DML Language Statements:
SELECT -- SELECT ... FROM ... WHERE
INSERT -- INSERT INTO ... VALUES
UPDATE -- UPDATE ... SET ... WHERE
DELETE -- DELETE ... FROM ... WHERE

DCL - Data Control Language
=============================
It includes two statements
GRANT and REVOKE - allows us to make rights users have in a db.

GRANT - GRANT gives or grants certain permissions to users
-------
Syntax - GRANT type_of_permission
         ON database_name.table_name
         TO 'username'@'localhost'

From this statement a user can be granted a certain permission (SELECT/INSERT/UPDATE/DELETE/CREATE/ALTER(ADD,REMOVE)/DROP/TRUNCATE/RENAME) to one of many tables of a db.

Eg. GRANT SELECT
    ON salesDb.customers_table
    TO 'frank'@'euhost'

This statement will provide ONLY select permission to user frank on table customers_table of salesDb database.

To grant all permission to frank on salesDb we can use:
GRANT ALL
ON salesdb.*
TO 'frank'@'euhost'

Database Admin - People who have complete rights to the db are db admin they can grant access to users and can revoke it.
---------------

REVOKE - used to revoke permissions of the users, it is the exact opposite of GRANT.
-------
Eg. REVOKE SELECT
    ON salesdb.customers_table
    FROM 'frank'@'euhost'


TCL - Transaction Control Language
===================================
Not every change you make to a db is saved automatically.

COMMIT Statement - All the changes which you have made related to INSERT, UPDATE, DELETE will not be saved permanently until you commit them.
----------------
Commit will save the changes you have made and will have other users have access to the modified version of the database.
Once Commit is run, changes cannot be undone.

Eg. To Update last name of a user
UPDATE customer_table
SET lastname = 'Kumar'
WHERE firstname='Ramesh';

After running above statement, rest of the users using the db won't know that you have updated the lastname. In order to reflect the changes to other users, you will have to add commit to the statement.

UPDATE customer_table
SET lastname='Kumar'
WHERE firstname='Ramesh'
COMMIT;

Now the updated information will be available to the users.
If you are db admin, u might have to run Commit 20 times a day hence committed states can accrue.

ROLLBACK clause - This clause will let you make a step back.
---------------
It allows you to undo any changes you have made an don't want to save permanently.

eg. ROLLBACK;

This will remove all changes and move to last committed state.


Revision:
DDL - CREATE/DESCRIBE DATA
    CREATE - CREATE TABLE table_name;
    ALTER - ALTER TABLE table_name ADD COLUMN column_name column_type;
    RENAME - RENAME TABLE table_name;
    DROP - DROP TABLE table_name;
    TRUNCATE - TRUNCATE TABLE table_name;

DML - MANIPULATE DATA
    SELECT - SELECT * FROM table_name  WHERE condition;
    INSERT - INSERT INTO table_name  WHERE condition;
    UPDATE - UPDATE table_name SET values WHERE condition;
    DELETE - DELETE cols FROM table_name WHERE condition;

DCL - CONTROL DATA THROUGH ACCESS
    GRANT - GRANT SELECT ON table_name TO 'user_name'@'hostname';
    REVOKE - REVOKE SELECT ON table_name FROM  'user_name'@'hostname';

TCL - COMMIT AND REVOKE CHANGES
    COMMIT - COMMIT;
    ROLLBACK - ROLLBACK;

Basic Database Terminology
==========================
The goal of the db is is to organize huge amounts of data that can be quickly retrieved.

What is relational database?
Database where there is relationship between tables also called as relations in the form of primary - foreign key. Hence when we need data from k of n tables then we work with only k tables(i.e only k tables are loaded) hence data is efficiently retrieved.
It is based on relational algebra.
i.e 3 tables == 3 relations
The smallest unit in the entire system that can carry integral logical meaning.

Two ways to design a DB:
------------------------
ER Diagram - Draw a diagram(like flowchart) showing the mappings of all tables and their connections through arrows.
Relational Schema - Create a rectangle for each table with tablename at the top and columns in rectangle, do same for all tables in a db and connect them through arrows.
When we combine relational schema it forms the database schema.


Primary Key:
============
A column or a set of columns whose value exists and is unique for every record in a table is a candidate of primary key.
Each table can have one and only one Primary key. In one table we cannot have 3-4 primary keys.
That Primary key can be a single Field(Column) like Purchase_id in sales table where purchase_id will have unique sequence of numbers.
Or two columns together can be combined to form a primary key eg purchase_number + date_of_purchase.
Only condition being Primary key should be unique.
Primary keys are also called unique identifiers of a table.
Primary keys cannot contain null values.

In Relational schema -
Table Name is at the top.
Then the primary key column is placed at the to of all other columns as is underlined.
Relational schema for a sales table having purchase_id as a primary key.

        Sales
 =======================
|    purchase_id        |
|    ------------       |
|    date_of_purchase   |
|    customer_id        |
|    item_code          |
 -----------------------

Not all tables you work with will have a primary key.

Foreign Key:
-----------
Suppose we have customers info like firstname, lastname, emailaddress, numberofcomplaints which is required in more than one table then other then having redundant info in different tables we can create Customers table with a primary key as customer_id and this can be mapped to other tables where it will behave as Foreign key.
primary key customer_id can have different column name in different tables like ID, cust_id etc but it can be mapped as Foreign key and Primary key combination.
Eg. In sales table we same name for column customer_id for foreign key which maps to primary key customer_id of Customers table.

Relational schema:
Foreign key in one table should be shown by (FK) around the column name and it should point an arrow to the primary key of other table it is mapping.
Eg. customer_id which is FK in Sales will point to primary key customer_id of Customer table.
Similarly there can be other tables like Items with item_code as FK in Sales table and primary key in Items table

                                             Customers
                                      =================================
        Sales              |-------> |      customer_id                 |
 =======================   |         |      ------------                |
|    purchase_id        |  |         |      first_name                  |
|    ------------       |  |         |      last_name                   |
|    date_of_purchase   |  |         |      email_address               |
|    customer_id  (FK)  |--          |      number_of_complaints        |
|    item_code    (FK)  |--|          ----------------------------------
 -----------------------   |
                           |
                           |                    Items
                           |         ===================================
                           |------->|           item_code               |
                                    |           ----------              |
                                    |           item                    |
                                    |           unit_price              |
                                    |           company_id              |
                                     -----------------------------------

 if the foreign key inserted in the Sales table does not have a corresponding value in Customers table then sql will raise an error.

 HENCE, FOREIGN KEYS ARE IDENTIFIERS THAT IDENTIFIES RELATIONS BETWEEN TABLES BUT NOT THE TABLES THEMSELVES.

 Relational Schema - Unique Keys and Null Values
 ================================================
 Unique key is used whenever you would like to specify that you don't want to see duplicate data in a given field.
 Unique keys are columns which should have unique values but unlike primary key
 1. It can contain null values
 2. There can be more than one unique columns in a table.

 Similar to primary key:- Unique key can be formed by combination of one or more columns.

                                             Customers
                                       =================================
         Sales              |-------> |      customer_id                 |
  =======================   |         |      ------------                |
 |    purchase_id        |  |         |      first_name                  |
 |    ------------       |  |         |      last_name                   |
 |    date_of_purchase   |  |         |      email_address               |
 |    customer_id  (FK)  |--          |      number_of_complaints        |
 |    item_code    (FK)  |--|          ----------------------------------
  -----------------------   |
                            |
                            |                    Items
                            |         ===================================
                            |------->|           item_code               |                      Companies
                                     |           ----------              |               ===================================
                                     |           item                    |      |--->   |       company_id                  |
                                     |           unit_price              |      |       |       -----------                 |
                                     |           company_id   (FK)       |------|       |       headquarters_phone_number   |
                                      -----------------------------------               |       company_name                |
                                                                                         -----------------------------------

Relationships
==============
Relationships tell you how much of the data from a foreign key field can be seen in the primary key column of the table the data is related to and vice versa.

customer_id column in Sales can have many duplicates as a customer can buy many items but each customer can have a single entry(customer_id) in Customers table.
Hence Customers to Sales is - One to Many relationship AND
Sales to Customers is - Many to One relationship

In relational diagram, one to many relationship is shown as >| AND
many to one relationship is shown as ||

                                             Customers
                               Many-One  =================================
         Sales                 |---||->|      customer_id                 |
  =======================      |       |      ------------                |
 |    purchase_id        |     |       |      first_name                  |
 |    ------------       |     |       |      last_name                   |
 |    date_of_purchase   |     |       |      email_address               |
 |    customer_id  (FK)  |\|---|       |      number_of_complaints        |
 |    item_code    (FK)  |/|             ----------------------------------
  ----------------------- One-Many

These are called cardinality constraints.
 > | define max and min relationship respectively.
 M N - define infinite relationship
 O - Optional Relationship which in this case when it was not necessary for a registered person to purchase an item.

 Few types of relationship-
 one to one
 one to many
 many to many
 many to one

Hence, Relational Schemas
- represents the concept db admins must implement
- depict how a database is organized
- blueprints, or a plan for a db

Relational Schemas will help you immensely while writing your queries.

Section 5 - First Steps in SQL
------------------------------
Let's create a db first.

Syntax: CREATE DATABASE [IF NOT EXISTS] dbname; -- OR
CREATE SCHEMA IF NOT EXISTS dbname;


Let's dissect the above statement.

CREATE DATABASE - Creates a db as an abstract unit it means after this statement db will not create any data but act as an object which is ready to persist information.

IF NOT EXISTS - verifies if the db with the same name exists already.
This won't prevent(impede) us from creating a db with the same name. The bracket around mean the statement is optional (we can either type or omit the statement),even if we don't include it, it will run anyway. It is always useful to include it because when we are working with large amount of datasets it reduces potential errors

dbname - It is always suggested to give a short name but at the same time as related to content of data as possible.

The SQL code is not case sensitive.
We can use quotes around dbname or without quotes.

; - Semi colon is the statement terminator. It is often true that the statement will run properly without it but in longer scripts when the code contains more than one statement. The semi colon is indispensable.
make a habit of using semi colon.

There can be many db when working through Workbench, in that case we can apply USE command to use a particular db.
USE Sales;

Introduction to Datatypes:
--------------------------
We must specify the type of the data that will be inserted in each column of the table.
Different datatypes represent different types of information that can be contained in a specific column.

String Data Types: The text format is sql is called string.
Datatypes containing strings are also called alphanumeric datatypes.
Eg. James will be treated a string datatype.

CHAR - character string - Fixed length string or called FIXED STORAGE DATATYPE
    max (size)limit is 255
    For CHAR(5) - Here 5 means the max symbols(chars) we are allowed to use in writing a value in this format.
    if a string -
        'James' is stored, it will take 5 bytes storage
        'Bob' is stored, it will also take 5 bytes storage
    Then why use CHAR when it takes fixed bytes?
        Two reasons -
            It is around 50% faster compared to VARCHAR.
            It can be used in situations where we need to store company acronyms with 4 chars like GOOG, AMZN, MSFT then we can go with CHAR(4).

VARCHAR - Variable Character - Variable length string
    Max (size)limit is 65535
    For VARCHAR(5)
    if a string -
            'James' is stored, it will take 5 bytes storage
            'Bob' is stored, it will also take 3 bytes storage
    Example - Store password which is not more than 10 chars, we can use VARCHAR as it will use storage based on size of password.

ENUM - Enumerate - It is particularly useful when we know beforehand what type of column are we going to deal with.
    It is same as choice, like to insert the Gender of a person you can define ENUM('M', 'F') then mysql will show error if you want to store value other than M or F.
    MySql will show an error if you attempt to insert any value different from M or F.

Numeric Types -
===============
INTEGERS
FIXED-POINT
FLOATING-POINT

INTEGERS - When we want to store whole numbers with no decimal points. Eg - 5, 15, -200, 1000
--------
Integers(signed/unsigned) signed includes negative values, then we can go with Integers.
Integers are further divided into few types based on size.
By default, INTEGER type are signed.
If we want to use a range containing only positive, 'unsigned' values, we will have to specify this in our query.

INT Type       size(bytes)              minimum value(signed/unsigned)                     maximum value(signed/unsigned)
TINYINT         1                           -128                                                127
                                               0                                                255
SMALLINT        2                         -32768                                              32767
                                               0                                              65535
MEDIUMINT       3                     -8,388,608                                          8,388,607
                                               0                                         16,777,215
INT             4                 -2,147,483,648                                      2,147,483,647
                                               0                                      4,294,967,295
BIGINT          8     -9,223,372,036,854,775,808                          9,223,372,036,854,775,807
                                               0                         18,446,744,073,709,551,615

Why not just use BIGINT all the time?
Answers comes in computer's processing speed, if in a field you are sure that you won't need an integer smaller than 0 and greater than 100, TINYINT will do the job perfectly and you would not need more storage space per data point.
A smaller integer type may suffice and increase the processing speed.


FIXED-POINT
-----------
DECIMAL
NUMERIC

Let's first get used to two concepts -
precision and scale.
precision - refers to number of digits in a number.
scale - number of digits right to the decimal point in a number.

Eg. DECIMAL(5,3) has precision 5 and scale 3 i.e it can have 5 values and 3 of to the right of decimal.

Fixed Point data represents exact values i.e in case of

DECIMAL(5,3) if the value 10.5 is inserted then mysql will convert it to 10.500.
DECIMAL(5,3) if the value is 10.5247516 then it will be rounded to 10.525 and a warning will be raised for FIXED POINT Number.

When only one digit is placed inside the parentheses, it will be treated as the precision of that data type.
Like DECIMAL(7) will be treated as DECIMAL(7,0) Eg - 1234567

NUMERIC is also defined as
NUMERIC(p,s) -- where p is precision and s is scale
These are good for storing salaries like
NUMERIC(8,2) - 300000.50

FLOATING-POINT
--------------
FLOAT
DOUBLE

It is used for approximate values only
Aims to balance between range and precision ( ==> floating)

When we have FLOAT(5,3) then 10.5 will be stored as is an not 10.500
and 10.524678 will be stored as 10.525 without any warning.

Hence the main difference between the fixed and floating point type is in the way the value is represented in the memory of the computer.
Where fixed point will raise a warning when its structure is not respected but floating point won't.

FLOAT and DOUBLE diff

Floating Point Type     size(bytes)         precision       maximum number of digits
FLOAT                   4                   single          23
DOUBLE                  8                   double          43


What is the difference between DECIMAL and NUMERIC FIXED POINT type? OR
How can I store a variable precision and fixed precision in mysql?
There is a small difference between NUMERIC(p,s) and DECIMAL(p,s) SQL numeric data type. NUMERIC determines the exact precision and scale. DECIMAL specifies only the exact scale; the precision is equal or greater than what is specified by the coder. DECIMAL columns can have a larger-than-specified precision if this is more convenient or efficient for the database system.
In other words, DECIMAL gives you some leeway.
Keep in mind that financial data such as account balances must be stored as NUMERIC or DECIMAL data types.

In statistics numerals are of 4 types:
Nominal - Like customer id, phone numbers etc These numbers are labelled but we don't do calculations on them like we cannot say that id 100 is better then id 90 or by adding two phone numbers we generate an amazing phone number.

Ordinal - These numbers have orders/categories attached to them like on the scale of 1-5, 1 being satisfied 5 being unsatisfied etc

Interval - Interval values shows the exact difference like yesterday the share volume was 100, today its 60 hence the difference is 40.

Ratio - Ratio values are intervals with a defined value as zero.

Each SQL numeric data type is used to represent all of the above values, especially intervals and ratios. You can compare character values in SQL, so one could argue that character values can also represent interval data. However, that's a topic for another article.

In SQL, numbers are defined as either exact or approximate.

The exact numeric data types are SMALLINT, INTEGER, BIGINT, NUMERIC(p,s), and DECIMAL(p,s). Exact SQL numeric data type means that the value is stored as a literal representation of the number's value.

The approximate numeric data types are FLOAT(p), REAL, and DOUBLE PRECISION. These represent real numbers, but they are not represented as exact numbers in the database. Rather, they are an approximation of the real number because of the way that computer systems represent numbers. If this sounds confusing, rest assured that we'll explain it in detail later.

Other Data types:
-----------------
Temporal Types
DATE
DATETIME
TIMESTAMP

DATE - Stores Date is YYYY-MM-DD Format, Range is 1000-01-01 To 9999-12-31. Eg - 2021-06-09
DATETIME - Stores Date + Time in YYYY-MM-DD HH:MM:SS[.MICROS] precision. Eg. - 2021-06-09 10:32:45.36945
TIMESTAMP - Unix timestamps - Epoch time stamps, Range - 1970-01-01 - 2038-01-19.   Useful in time calculations like subtracting one time from another. It is more capable of storing timezones which datetime in not very capable of doing.

Hence -
STRING AND TEMPORAL - CHAR, VARCHAR, DATE, DATETIME, TIMESTAMP might be written in quotes.
NUMERIC - TINYINT, SMALLINT, MIDINT, INT, BIGINT, DECIMAL, NUMERIC, FLOAT, DOUBLE can be written without quotes.


BLOB - Binary Large OBject
For File objects, jpegs, wav etc
Refers to a file of binary data with 1s and 0s.
Involves saving files in a record.
Eg. *.doc, *.xlsx, *.xml, *.jpg, *.wav


Constraints -
NOT NULL - Defines the constraint that column should not be null else an error will be thrown.
AUTO INCREMENT - Increment the values of the column automatically like i column in kdb.
Frees you from having to insert all purchase numbers manually through the INSERT command at the later stage,
assign 1 to the first record of the table and automatically increments by 1 for every subsequent row.

Creating a table in Sales DB
----------------------------
We will create tables as we have created in Relational Schema i.e sales, customers, items, companies.
Let's start with sales table.

Compulsory requirement - While creating a table we must provide atleast one column name, else we will get an error.

Syntax:
CREATE TABLE table_name
(
    col1 datatype constraint,
    col2 datatype constraint,

    coln datatype constraint
);

Eg:
CREATE TABLE sales
(
	purchase_id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
    date_of_purchase DATE NOT NULL,
    customer_id INT,
    item_code VARCHAR(10) NOT NULL
);


CREATE TABLE customers
(
	customer_id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
    first_name VARCHAR(255) NOT NULL,
    last_name VARCHAR(255),
    email_address VARCHAR(255),
    number_of_complaints SMALLINT
);

Queries:
========
query - a command to write in SQL with the idea of either retrieving information from db on which you are working, or, alternatively, to insert, delete, update data from it.
Semi-colon acts as a terminator.
After creating a db Sales, we used 'Use Sales' to let mysql know that we want to use mysql objects(like tables) from Sales db and run query over them.

queries -
one of the main feature of the query is to manipulate data within database.
eg.
USE Sales;
SELECT * FROM customers;

When using multiple databases and tables:
Whenever we want to refer to a SQL object in our queries, we must specify to the db it is applied.
SQL objects are like tables, indexes, views, stored procedures, functions.
We can do it in two ways:
1. set a default db:
    USE Sales;
    SELECT * FROM customers;
2. Call a dbobject directly from dbname using dot operator.
    Syntax: dbname.dbobject
    dot operator - signals the existence of a connection between the two object types.
Eg. SELECT * FROM Sales.customers;


To delete a table:
DROP TABLE table_name;
DROP TABLE sales;


MYSQL Constraints:
------------------
What are constraints?
    specific rules, or limits, that we define in our tables.
    The role of constraints is to outline the existing relationships between different tables in our database.
    eg. NOT NULL, AUTO_INCREMENT, PRIMARY KEY, FOREIGN KEY, UNIQUE KEY

    AUTO_INCREMENT(Extra Constraint) works only with PRIMARY KEY, UNIQUE KEY, INDEX

PRIMARY KEY -
    PRIMARY KEY can be assigned in two ways:

   1. How we did earlier:
    CREATE TABLE sales
    (
    	purchase_id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
        date_of_purchase DATE NOT NULL,
        customer_id INT,
        item_code VARCHAR(10) NOT NULL
    );

   2. Another way:
    CREATE TABLE sales
    (
       	purchase_id INT NOT NULL  AUTO_INCREMENT,
        date_of_purchase DATE NOT NULL,
        customer_id INT,
        item_code VARCHAR(10) NOT NULL,
    PRIMARY KEY(purchase_id)
    );

Eg: customers table
CREATE TABLE customers
(
	customer_id INT NOT NULL AUTO_INCREMENT,
    first_name VARCHAR(255) NOT NULL,
    last_name VARCHAR(255),
    email_address VARCHAR(255),
    number_of_complaints SMALLINT,
PRIMARY KEY(customer_id)
);


FOREIGN KEY
===========
Points to a column of another table and thus links the two tables.

It is a column in one table(Child table / referencing table) which refers to a column in another table(Parent table / referenced table)
In our example child table in sales and parent table in customers when customer_id column(foreign key) of sales table is referred by customer_id(Primary key) of customers table.

Remember, it is not an obligatory requirement - these two keys can have completely different names. What's imp is that the data types and the information match! It's just common practice to use, if not the same, then similar names for both keys.

A foreign key in sql is defined through a foreign key constraint.
Hence the connection between two tables is maintained using foreign keys.
The foreign key maintains the referential integrity within the database.

SYNTAX -
    FOREIGN KEY(foreign key col) REFERENCE parent_table_name(primary key col) ON DELETE CASCADE

ON DELETE CASCADE constraint is used in practice which means if the primary key record is deleted from referenced table then its corresponding records will be deleted from referencing tables.


Three ways to add foreign key constraint:
1. While creating the table:

CREATE TABLE sales
(
    purchase_id         INT NOT NULL AUTO_INCREMENT,
    date_of_purchase    DATE NOT NULL,
    customer_id         INT,
    item_code           INT NOT NULL,
PRIMARY KEY(purchase_id),
FOREIGN KEY(customer_id) REFERENCES customers(customer_id) ON DELETE CASCADE
);

2. ADD foreign key constraint by altering the table
ALTER TABLE sales
ADD FOREIGN KEY(customer_id) REFERENCES customers(customer_id) ON DELETE CASCADE;

Internally ddl for Sales.sales table looks like this
CREATE TABLE `sales` (
  `purchase_id` int NOT NULL AUTO_INCREMENT,
  `date_of_purchase` date NOT NULL,
  `customer_id` int DEFAULT NULL,
  `item_code` int NOT NULL,
  PRIMARY KEY (`purchase_id`),
  KEY `customer_id` (`customer_id`),
  CONSTRAINT `sales_ibfk_1` FOREIGN KEY (`customer_id`) REFERENCES `customers` (`customer_id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci

we can use the foreign key CONSTRAINT name sales_ibfk_1 to drop the foreign key

DROP foreign key
-----------------
ALTER table sales
DROP FOREIGN KEY `sales_ibfk_1`;

OR without backtick
ALTER table sales
DROP FOREIGN KEY sales_ibfk_1;

3. From MySql Workbench
Right click on table name and click 'Alter table' -- Foreign key tab -- Reference table customers --referenced column -- On DELETE cascade - apply
IF you want there is option for on update cascade as well


UNIQUE KEY
===========
Used whenever we would like to specify that we don't want duplicate records in a given field.
It ensures that all values in a column or a set of columns are different.
Just like Primary key and foreign key, unique keys are implemented in SQL through a constraint - UNIQUE KEY.
Hence, if we try to insert a duplicate value in a unique key column then sql with display an error.

Eg. email_address in customers table should be unique.

CREATE TABLE customers
(
	customer_id INT NOT NULL AUTO_INCREMENT,
	first_name VARCHAR(255),
    last_name VARCHAR(255),
    email_address VARCHAR(255),
    number_of_complaints SMALLINT,
PRIMARY KEY(customer_id),
UNIQUE KEY(email_address)
);

Another way is through ALTER table, to add unique key constraint to an existing table.
ALTER TABLE customers
ADD UNIQUE KEY(email_address);

To drop a unique key constraint -
Unique key in mysql has same role as indexes but reverse isn't true.

Index of a table - an organizational unit which helps retrieve data more easily.
Unique key is same as an index to a column which supports faster searching of elements hence to drop unique key we use INDEX.
Indexing comes with a cost, it takes more time to update a table with indexes because indexes must be updated too and it is time consuming.
ALTER TABLE customers
DROP INDEX email_address;

If we will try to add a unique key constraint to an existing table which already have unique key on same Field then mysql will not display an error rather it will just show a warning like below and add one more unique key constaint.
"0 row(s) affected, 1 warning(s): 1831 Duplicate index 'email_address_2' defined on the table 'sales.customers'. This is deprecated and will be disallowed in a future release. Records: 0  Duplicates: 0  Warnings: 1"

DDL
CREATE TABLE `customers` (
  `customer_id` int NOT NULL AUTO_INCREMENT,
  `first_name` varchar(255) DEFAULT NULL,
  `last_name` varchar(255) DEFAULT NULL,
  `email_address` varchar(255) DEFAULT NULL,
  `number_of_complaints` smallint DEFAULT NULL,
  PRIMARY KEY (`customer_id`),
  UNIQUE KEY `email_address` (`email_address`),
  UNIQUE KEY `email_address_2` (`email_address`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci


After dropping index email_address
ALTER TABLE customers
DROP INDEX email_address;

Still one unique key constraint(email_address_2) is applied, let remove that as well

DDL
CREATE TABLE `customers` (
  `customer_id` int NOT NULL AUTO_INCREMENT,
  `first_name` varchar(255) DEFAULT NULL,
  `last_name` varchar(255) DEFAULT NULL,
  `email_address` varchar(255) DEFAULT NULL,
  `number_of_complaints` smallint DEFAULT NULL,
  PRIMARY KEY (`customer_id`),
  UNIQUE KEY `email_address_2` (`email_address`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_c

ALTER TABLE customers
DROP INDEX email_address_2;

DDL
CREATE TABLE `customers` (
  `customer_id` int NOT NULL AUTO_INCREMENT,
  `first_name` varchar(255) DEFAULT NULL,
  `last_name` varchar(255) DEFAULT NULL,
  `email_address` varchar(255) DEFAULT NULL,
  `number_of_complaints` smallint DEFAULT NULL,
  PRIMARY KEY (`customer_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci


Let's play a little with customers table.
CREATE TABLE customers (
    customer_id INT NOT NULL AUTO_INCREMENT,
    first_name VARCHAR(255),
    last_name VARCHAR(255),
    email_address VARCHAR(255),
    number_of_complaints INT,
PRIMARY KEY (customer_id)
);

ALTER TABLE customers
ADD COLUMN gender ENUM('M','F') AFTER last_name;

INSERT INTO customers (first_name, last_name, gender, email_address, number_of_complaints)
VALUES ('Ramesh', 'Kumar', 'M', 'rameshk@ramesha.com',1000);

SELECT * FROM customers;

To get a list of columns in mysql use INFORMATION.SCHEMA
SELECT * FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_NAME='customers';

or to get an empty table with just column names
SELECT * FROM customers WHERE 1=0; -- quick and dirty

DEFAULT Constraint
===================
It is used to add default values to all records of a column.

If we need to add a value other than default value then we will have to specify in separately.

Eg. number_of_complaints column in customers table can be set to 0.

(
	customer_id INT NOT NULL AUTO_INCREMENT,
	first_name VARCHAR(255),
    last_name VARCHAR(255),
    email_address VARCHAR(255),
    number_of_complaints SMALLINT DEFAULT 0,
PRIMARY KEY(customer_id),
UNIQUE KEY(email_address)
);

OR

If we want to add default constraint after creation of table

ALTER TABLE customers
CHANGE COLUMN number_of_complaints number_of_complaints SMALLINT DEFAULT 0;

Test changes by adding a new record:
INSERT INTO customers (first_name, last_name, gender)
VALUES ('Chandu', 'Thakur', 'M');

SELECT * FROM customers;

How can we drop the DEFAULT constraint?
ALTER TABLE customers
ALTER COLUMN number_of_complaints DROP DEFAULT;

NOT NULL Constraint:
====================
In a primary key all records should be not null but in case of unique key duplicate values are not allowed but we can have NULL values.
The 'not null' restriction is applied through NOT NULL constraint.
which means when you insert values in the table, you cannot leave the respective field empty.
If we leave it empty, mysql will display an error.

Let's go with examples:
CREATE TABLE companies
(
	company_id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
	company_name VARCHAR(255) NOT NULL,
    headquarters_phone_number VARCHAR(255)
);

OR
ALTER TABLE companies
CHANGE COLUMN company_name company_name VARCHAR(255) NOT NULL;

MODIFY NOT NULL to NULL (There is nothing like drop NOT NULL Constraint)
ALTER TABLE companies
MODIFY company_name VARCHAR(255) NULL;

Insert values:
INSERT INTO companies (headquarters_phone_number, company_name)
values ('5327385-358', 'Company A');

Select values:
SELECT * FROM companies;

EXERCISE:
ALTER TABLE companies
CHANGE COLUMN headquarters_phone_number headquarters_phone_number VARCHAR(255) NOT NULL;

ALTER TABLE companies
MODIFY headquarters_phone_number VARCHAR(255) NULL;

GOTCHAS of NOT NULL CONSTRAINT:
-------------------------------
Don't confuse a NULL values with a numeral value 0 or a string value NONE.
If a record has 0 value its a valid value and not null value like no_of_complaints
If a record had NONE value its a valid value like in feedback column if a person does not wish to give feedback we can place NONE value.

If the record in no_of_complaints or feedback is empty then we can say it as NULL.


Coding Practices:
Good code is not what computers understand, it's the one that humans understand.

When assigning names to variables or SQL objects, always choose shorter, meaningful names, conveying specific information.
meaningful means pronounceable - where one word per concept has been picked.

[column] names will constitute more then 80% of your code, choose them wisely.

Use uppercase for SQL keywords.

=================
DML Statements===
=================
SELECT
========
It allows to extract complete or a fraction of a dataset.
It is used to retrieve data from db objects, like tables.
Used to query data from a db.

Basic select statement:(But it can become very complex if you are a pro)
select col1, col2.... coln
from tablename;

Practically from keyword is mandatory, it tells us from which table the data is to be retrieved.

When extracting info, SELECT always goes with FROM.

To select first and last name from the employees table.
USE employees;
SELECT
    first_name, last_name
FROM
    employees;


select all records and cols from employees table.
'*' is a wildcard characters which mean all 'all' or 'everything'.
SELECT
    *
FROM
    employees;

Exercise:
-- departments table  dept_name
SELECT
    dept_name
FROM
    departments;

WHERE Clause
-------------
It allows us to set a condition upon which we will specify what part of the data we want to retrieve from the database.

Syntax
SELECT col1, col2.... coln
FROM tablename WHERE condition;

Eg. Select employees from employees table whose first name is Denis.
SELECT
    *
FROM
    employees
WHERE
    first_name = 'Denis';


In above where clause we have use equal '=' operator to match a string.
In SQL, there are many other linking keywords and symbols, called operators, that you can use with the where clause.

Eg:
AND         OR
IN          NOT IN
LIKE        NOT LIKE
BETWEEN...AND(Used together)
NOT BETWEEN...AND
EXISTS      NOT EXISTS
IS NULL     IS NOT NULL
comparison operators etc


AND Operator
============
allows you to logically combine two statements in the condition code block.
It allows us to narrow the output we would like to extract from the data. Hence
AND binds SQL to meet both conditions enlisted in the WHERE clause simultaneously.

Syntax:
SELECT col1, col2.... coln
FROM tablename WHERE condition1 AND cond2;

Eg: Find all employees name 'Saniya' and have gender 'F'
SELECT
    *
FROM
    employees
WHERE
    first_name = 'Saniya' AND gender = 'F';

OR Operator
===========
Applies OR condition

SELECT col1, col2.... coln
FROM tablename WHERE condition1 OR cond2;

Eg: Select emps with firstname as Elvis or Saniya
SELECT
    *
FROM
    employees
WHERE
    first_name = 'Saniya'
        OR first_name = 'Elvis';

Operator Precedence:
--------------------
AND has precedence over OR.

SELECT
    *
FROM
    employees
WHERE
    last_name = 'Denis'
        AND (gender = 'M' OR gender = 'F');

IN and NOT IN
----------------
IN operator can be used along with list to fetch elements IN a column.
We can use OR operator but if there are more than 2 elements to check then we can go with IN operator.
Also, using IN is faster than using OR.

Eg. select all employees whose first name is Cathie, Mark or Nathan.

SELECT
    *
FROM
    employees
WHERE
    first_name IN ('Cathie' , 'Mark', 'Nathan');


Eg of NOT IN:
SELECT
    *
FROM
    employees
WHERE
    first_name NOT IN ('Cathie' , 'Mark', 'Nathan');

LIKE or NOT LIKE
================
It is used for pattern matching.
% - is used for matching 0 or more chars
_ - is used for matching one character

Also, mysql is case insensitive meaning, you can pass 'Mar%' or 'mar%' to search for all strings starting with 'Mar'

Eg:
SELECT
    *
FROM
    employees
WHERE
    first_name LIKE 'Mar%';

SELECT
    *
FROM
    employees
WHERE
    first_name LIKE 'Mar_';

Eg. - Not like
SELECT
    *
FROM
    employees
WHERE
    first_name NOT LIKE '%Ma%';

Retrieve a list with all employees who have been hired in the year 2000.
SELECT
    *
FROM
    employees
WHERE
    hire_date LIKE '2000%';

Retrieve a list with all employees whose employee number is written with 5 characters, and starts with “1000”.
SELECT
    *
FROM
    employees
WHERE
    emp_no LIKE '1000_';

Wildcard Characters:
====================
% - 0 or more matches
_ - 1 match
* - for selecting all columns, can be used to count all rows of a table.


BETWEEN AND -- NOT BETWEEN AND
-------------------------------
Helps us designate the interval to which a given value belong:
It is always used in combination with AND operator.
It can be used with all data types i.e Strings, Numerical and DATE.
Output includes both start and end values.

Eg: Obtain a list of people hired between 1990-01-01 and 1999-12-31
SELECT
    *
FROM
    employees
WHERE
    hire_date BETWEEN '1990-01-01' AND '1999-12-31';


NOT BETWEEN AND -- will refer to an interval composed of two parts:
    an interval below the first value indicated
    a second interval above the second value
Here both start and end values are not included in the output.

Eg. Obtain employees not hired between '1990-01-01' AND '1999-12-31'
SELECT
    *
FROM
    employees
WHERE
    hire_date NOT BETWEEN '1990-01-01' AND '1999-12-31';

Exercise:
Select all the information from the “salaries” table regarding contracts from 66,000 to 70,000 dollars per year.
SELECT
    *
FROM
    salaries
WHERE
    salary BETWEEN 66000 AND 70000;

Retrieve a list with all individuals whose employee number is not between ‘10004’ and ‘10012’.
SELECT
    *
FROM
    employees
WHERE
    emp_no NOT BETWEEN 10004 AND 10012;

GOTCHA - If you give first upper limit and then lower limit then sql won't raise error rather return all records
SELECT
    *
FROM
    employees
WHERE
    emp_no NOT BETWEEN 11012 AND 10004;

Select the names of all departments with numbers between ‘d003’ and ‘d006’.
SELECT
    *
FROM
    departments
WHERE
    dept_no BETWEEN 'd003' AND 'd006';

IS NULL / IS NOT NULL
=====================
As it is intuitive, IS NOT NULL constraint is used to fetch all the records where none of the value is None.
SELECT col1, col2, ... coln
FROM tabname,
WHERE colname IS NOT NULL;

Eg. Select all emp whose last name is not null
SELECT
    *
FROM
    employees
WHERE
    last_name IS NOT NULL;

We can check the opposite with IS NULL
SELECT
    *
FROM
    employees
WHERE
    last_name IS NULL;

Exercise:
Select the names of all departments whose department number value is not null.
SELECT
    *
FROM
    departments
WHERE
    dept_no IS NOT NULL;

The SQL EXISTS Operator
------------------------
The EXISTS operator is used to test for the existence of any record in a subquery.
The EXISTS operator returns TRUE if the subquery returns one or more records.


Other Comparison Operators:
---------------------------
= > >= < <=
Not equal - <> !=

Eg: Select all employees whose first name is not Saniya
SELECT
    *
FROM
    employees
WHERE
    first_name <> 'Saniya';

Select the employees hiresd after Jan 1st 2000
SELECT
    *
FROM
    employees
WHERE
    hire_date > '2000.01.01';

Retrieve a list with data about all female employees who were hired in the year 2000 or after.
SELECT
    *
FROM
    employees
WHERE
    hire_date >= '2000.01.01' AND Gender = 'F';

SELECT Distinct
================
To select distinct values from a column we can use
Syntax: SELECT DISTINCT col1, col2, col3...coln
from table where condition

SELECT DISTINCT
    gender
FROM
    employees;

Exercise: Obtain a list with all different “hire dates” from the “employees” table.
SELECT DISTINCT
    hire_date
FROM
    employees;

Aggregate Functions:
---------------------
They are applied on multiple rows of a single column of a table and return an output of a single value.

COUNT() - counts the number of non-null records in a field.
    It is frequency used with the combination of reserved word DISTINCT.
    Imp Note - The parentheses after COUNT should start right after the keyword and not after white space. This condition is related to clean code i.e if a column is related to COUNT keyword it should be applied without space in between.
    SYNTAX: SELECT COUNT(col)
            FROM table;
    Eg. : SELECT
              COUNT(DISTINCT hire_date)
          FROM
              employees;
    Eg. How many employees are registered in our db when emp_no is primary key
    SELECT
        COUNT(emp_no)
    FROM
        employees;
    Eg. Get distinct names from employees
    SELECT
        COUNT(DISTINCT first_name, last_name)
    FROM
        employees;
    Eg. Get count of first name from employees
    SELECT
        COUNT(DISTINCT first_name)
    FROM
        employees;

    Exercise: How many annual contracts with a value higher than or equal to $100,000 have been registered in the salaries table?
    SELECT
        COUNT(salary)
    FROM
        salaries
    WHERE
        salary > 100000;

    How many managers do we have in the “employees” database? Use the star symbol (*) in your code to solve this exercise.
    SELECT
        COUNT(*)
    FROM
        dept_manager;

SUM() - sums all the non-null values of a column.
MIN() - returns the min value from the entire list.
MAX() - returns the max value from the entire list.
AVG() - calculates the avg of all non-null values belonging to a certain column of a table.


ORDER BY
--------
We want to sort a table by a column in ascending or descending order, we can use ORDER BY.
ASC for ascending which is default.
DESC is used for descending order.

Eg: Get all the employees in the ascending order of their first name
SELECT
    *
FROM
    employees
ORDER BY first_name ;

Eg: Get all the employees in the descending order of their hire date
SELECT
    *
FROM
    employees
ORDER BY hire_date DESC;

descending emp_no
SELECT
    *
FROM
    employees
ORDER BY emp_no DESC;

Order by can be applied on more than one columns
Eg. Order all employees by their first and last name
SELECT
    *
FROM
    employees
ORDER BY first_name, last_name;

GROUP BY - Very useful
========
When working in sql, results can be grouped together according to a specific field or fields.
groupby must be placed exactly after the where clause(if any) and before order by clause (if any)
It is a common practise to place the group by column also with the select column.

Syntax: select col1, col2, .. coln
        from table
        where conditions
        group by column name(s)
        order by column name(s);

Eg. Get count of distinct employees by their first name
SELECT
    first_name, COUNT(first_name)
FROM
    employees
GROUP BY first_name;

Eg. get count of names by first_name, last_name where hiredate is after 1998-01-01
SELECT
    first_name, last_name, COUNT(first_name)
FROM
    employees
WHERE
    hire_date > '1998-01-01'
GROUP BY first_name , last_name
ORDER BY first_name DESC;

Using Aliases - AS keyword
-------------
When we look at the ouput of count(colname) the output column name is also COUNT(colname) which has two issues:
1. It is not very clear to the person looking the output as to what the column contains.
2. Using that output column name as is (like Count(fist_name)) will raise an error 'Error Code: 1248. Every derived table must have its own alias
'

This issue can be solved using AS keyword through which we can assign the output col a new name.
Eg:
SELECT
    first_name, COUNT(first_name) AS name_counts
FROM
    employees
WHERE
    hire_date > '1998-01-01'
GROUP BY first_name
ORDER BY name_counts DESC;

Exercise:
Write a query that obtains two columns. The first column must contain annual salaries higher than 80,000 dollars. The second column, renamed to “emps_with_same_salary”, must show the number of employees contracted to that salary. Lastly, sort the output by the first column.
SELECT
    salary, COUNT(emp_no) AS 'emps_with_same_salary'
FROM
    salaries
WHERE
    salary > 80000
GROUP BY salary
ORDER BY salary;

HAVING
========
Whenever we want to apply an aggregate function over a groupby clause, we have to use HAVING.
Sometimes HAVING can be used instead of where clause but that's not what it is designed to be used for.
Having clause is to be placed between group by and order by clause.
Syntax:
Select col1, col2..coln
from table
where condition
group by col
having condition
order by col;

Eg. List all employees first name whose first name appreared more than 250 times in the table and arrange them by names_count in desc order.
SELECT
    first_name, COUNT(first_name) AS names_count
FROM
    employees
where hire_date < '1999-01-01'
GROUP BY first_name
HAVING names_count > 250
ORDER BY names_count DESC;

Exercise:
Select all employees whose average salary is higher than $120,000 per annum.
SELECT
    emp_no, AVG(salary) AS avg_sal
FROM
    salaries
GROUP BY emp_no
HAVING AVG(salary) > 120000
ORDER BY avg_sal;

WHere vs Having
---------------
Where allows us to set conditions that refer to subsets of individual rows, these conditions are applied before re-organizing the output into groups.
Once records are filtered using where clause then they can be grouped using distinct values of a column and then a condition can be applied on the aggregate values of the grouped elements using HAving clause.

having can be applied to non-aggregated data also as a filter but there can't be two conditions applied in having one being aggregated and other being non-aggregated.
Eg. SELECT
        first_name, COUNT(first_name) AS names_count
    FROM
        employees
    WHERE
        hire_date > '1999-01-01'
    GROUP BY first_name
    HAVING names_count < 200
    ORDER BY first_name;

Exercise: Select the employee numbers of all individuals who have signed more than 1 contract after the 1st of January 2000.
SELECT
    emp_no, COUNT(emp_no) AS emp_no_counts
FROM
    dept_emp
WHERE
    from_date > '2000-01-01'
GROUP BY emp_no
having emp_no_counts > 1;

LIMIT
=====
Limit the no of records in the output.
No matter how long the query is, the LIMIT statement is placed at the end.
Syntax:
Select col1, col2 .. coln
from tab
where condition
LIMIT INT;

Eg. Get details of emps who get max salary
SELECT
    *
FROM
    salaries
ORDER BY salary DESC
LIMIT 10;

INSERT Statement
=================
Insert statement is used to insert values to an existing table.

Syntax: INSERT INTO table (col1, col2 ... coln)
        VALUES (val1, va2 ... valn);

Eg: Insert an element in employees table
INSERT INTO employees
(
	emp_no,
    birth_date,
    first_name,
    last_name,
    gender,
    hire_date
)
VALUES
(	999901,
	'1986-04-01',
    'John',
    'Smith',
    'M',
    '2011-01-01'
);

Test if the record is entered
SELECT
    *
FROM
    employees
ORDER BY emp_no DESC
LIMIT 10;

Integers in Mysql can be placed within quotes, if the column is of int type even if you try to insert ints within quotes then mysql will convert it to int and store it as int.
BUT it is alway good to type ints as plain numbers, without using quotes. It save mysql time to do the conversion and is a good practise to have ints as plain text.

When inserting a row in a table, it is not necessary to provide column names in order like we can put birth_date before emp_no while inserting a row in employees table.
INSERT INTO employees
(
	birth_date,
	emp_no,
    first_name,
    last_name,
    gender,
    hire_date
)
VALUES
(
	'1973-3-26',
	999902,
    'Patricia',
    'Lawrence',
    'F',
    '2005-01-01'
);

When inserting a record to a table without providing the column names, 2 things should be kept in mind.
- specify as many data values as there are columns in the data table.
- add them in the same order in which they appear in the table.
Else Mysql will raise an error:
Error Code: 1136. Column count doesn't match value count at row 1

Correct statement will be:
INSERT INTO employees
VALUES
(
	999903,
    '1977-9-14',
    'Johnathan',
    'Creek',
    'M',
    '1999-1-1'
);

Insert data into a table from another table:
--------------------------------------------
We can insert data into a table from another table directly using insert and select.
Syntax:
INSERT INTO table2 (col1, col2)
SELECT (col1, col2)
FROM table 1
WHERE cond;

Eg: Create a new table departments_dup and insert into it values from departments table where dept_no < 'd005'
SELECT * FROM departments;

CREATE TABLE departments_dup
(
    dept_no CHAR(4) NOT NULL PRIMARY KEY,
    dept_name VARCHAR(40) NOT NULL
);

INSERT INTO departments_dup (dept_no, dept_name)
select * from departments where dept_no < 'd005'; -- OR

INSERT INTO departments_dup
select * from departments where dept_no < 'd005';

SELECT * FROM departments_dup;

Exercise:
Create a new department called “Business Analysis”. Register it under number ‘d010’.
INSERT INTO departments
VALUES ('d010', 'Business Analysis');

TCL - Transaction Control Language
==================================
The COMMIT STATEMENT:
    Saves the transactions in the database
    Changes cannot be undone.
Can be used to save the state of the data in the database at the moment of its execution.


The ROLLBACK Clause:
    allows you to take a step back
    the last change(s) made will not count
    reverts to the last non-committed state.
It refers to the state corresponding to the last time you executed COMMIT.

UPDATE Statement
-----------------
It is used to update the values of existing records in a table.

Syntax:
UPDATE table
SET col1=val1, col2=val2
WHERE condition;

Update employees table for emp_no=999901
UPDATE employees
SET
    first_name = 'Stella',
    last_name = 'Parkinson',
    birth_date = '1990-12-31',
    gender = 'F'
WHERE
    emp_no = 999901;

If we try to update the row based a where condition which does not pass like update employees for emp_no='not existing', SQL won't raise error but won't updte any row as well as where condition was false.

In update statement, where clause if very imp, if we don't provide a where condition, all rows of th table will be updated.
If the changes are commited we can rollback,
Eg - If by mistake we have updated all rows of a table then we can rollback the changes to previous commit using rollback command.
SELECT * FROM departments_dup;
COMMIT;

update departments_dup
set
	dept_no='d011',
    dept_name = 'QC';

ROLLBACK;

Exercise: Change the “Business Analysis” department name to “Data Analysis”.
UPDATE departments_dup
SET
    dept_name = 'Data Analysis'
WHERE
    dept_name = 'Business Analysis'; -- OR better way 'where dept_no='d010'

DELETE STATEMENT
---------------
delete statement is used to DELETE records from a table.
Hence first run commit command so that at the end, we can rollback.

Syntax:
DELETE FROM table_name
WHERE conditions;

Eg: Delete employee with emp_no 999903 from employees table
COMMIT;

select * from employees where emp_no = 999903;
select * from titles where emp_no = 999903;


DELETE FROM employees
WHERE
    emp_no = 999903;

ROLLBACK;

When we delete this record, a record is deleted from titles tables as well because of relationship between employees and titles table which has constraint ON DELETE CASCADE.
CONSTRAINT `titles_ibfk_1` FOREIGN KEY (`emp_no`) REFERENCES `employees` (`emp_no`) ON DELETE CASCADE

ON DELETE CASCADE
-----------------
If a specific value from a parent table's primary key has been deleted, all the records from the child table rederring to this value will be removed as well.

UNSAFE delete operation: which can delete all records of a table
------------------------
Always use where conditions while using DELETE or UPDATE.
In case of delete, all rows will be deleted if proper filter condition is not placed.

SELECT * FROM departments_dup;
COMMIT;

DELETE FROM departments_dup;

ROLLBACK;

Exercise:
Remove the department number 10 record from the “departments” table.
SELECT * FROM departments;
COMMIT;

DELETE FROM departments
WHERE
    dept_no = 'd010';

ROLLBACK;

DROP vs DELETE vs TRUNCATE:
---------------------------
DROP - DROP the complete table, you won't be able to roll back to its initial state, or the last COMMIT statement.
Use DROP TABLE only where you are sure you aren't going to se the table in question anymore.

TRUNCATE - it will delete all records from a table similar to delete from table without a where clause.
When truncating, auto-increment values will be reset.
i.e after truncating all records from a table once will start filling the table again the column value will start from 1.

DELETE - IT REMOVES records row by row. If where condition is ommited it will remove all records like truncate but with certain differences.
TRUNCATE VS DELETE WITHOUT WHERE
- sql optimizer will implement different programmatic approached when e are using TRUNCATE or DELETE. TRUNCATE delete the output much faster than DELETE as it does not remove information row by row.
- auto-increment values are not reset with delete i.e if you delete all rows using delete and then again start filling the table then the column with start filling values from last filled value + 1.

Aggregation Functions:
======================
Gather data from many rows of a table, then aggregate it into a single value.
Input - the information contained in multiple rows
Output -  single value.
Also called summarizing function.

Why do these functions exist?
They are a response to the information requirements of a company's different organizational levels.
Top Management executives are typically interested in summarized figures and rarely in detailed data.

COUNT -
--------
Count the number of non-null(null values can also be counted) values in a column of a table.
Count is applicable to both numeric and non-numeric data.
Eg:
SELECT
    COUNT(DISTINCT salary)
FROM
    salaries;

If we want null values also to be counted, then we can use COUNT(*)
COUNT(*) - returns the number of all rows of the table, NULL values included.
SELECT
    COUNT(*)
FROM
    salaries;

Exercise:
How many departments are there in the “employees” database? Use the ‘dept_emp’ table to answer the question.
SELECT
    COUNT(DISTINCT dept_no)
FROM
    dept_emp;

SUM()
-----
Sum all the values of rows in a column of a table.
Works only with numeric data.
Eg: Sum all the salaries from salaries table to know how much money company spends in salary.
SELECT
    SUM(salary)
FROM
    salaries;

Can we pass SUM(*)?
No, we cannot sum null values hence why include it, so we can say that (*) goes well with COUNT but not with SUM.

Exercise: What is the total amount of money spent on salaries for all contracts starting after the 1st of January 1997?
SELECT
    SUM(salary)
FROM
    salaries
WHERE
    from_date > '1997-01-01';

MIN() and MAX() -
-----------------
Returns min and max value of a column.
Eg: Find the max and min salary from salaries table.
SELECT
    MAX(salary) as max_sal, MIN(salary) as min_sal
FROM
    salaries;
Exercise:
1. Which is the lowest employee number in the database?
2. Which is the highest employee number in the database?
SELECT
    MAX(emp_no), MIN(emp_no)
FROM
    employees;

AVG() -
-------
extracts the average value of all non-null values in a field.
Eg: Average annual salary the company employees received
SELECT
    from_date, AVG(salary)
FROM
    salaries
GROUP BY from_date;

Aggregate functions can be applied to any group of data values within a certain column. Frequently used together with GROUPBY clause.

Exercise: What is the average annual salary paid to employees who started after the 1st of January 1997?
SELECT
    AVG(salary)
FROM
    salaries
WHERE
    from_date = '1997-01-01';

ROUND(#, decimal places)
-------------------------
numeric, or math, function can be used
usually applied to the single values that aggregate function returns
If we want to round to the closest integer.
SELECT
    ROUND(AVG(salary))
FROM
    salaries;

If we want to round the number to n decimal places
SELECT
    ROUND(AVG(salary), 2) as rounded_sal
FROM
    salaries;

Exercise: Round the average amount of money spent on salaries for all contracts that started after the 1st of January 1997 to a precision of cents.
SELECT
    ROUND(AVG(salary), 2) AS rounded_sal
FROM
    salaries
WHERE
    from_date > '1997-01-01';

IFNULL and COALESCE:
======================
Below setup is required to have null values in department_dup table with NULL values to work with IF NULL and COALESCE:
SELECT
    *
FROM
    departments_dup
ORDER BY dept_no ASC;

ALTER TABLE departments_dup
CHANGE COLUMN dept_name dept_name VARCHAR(40) NULL;

INSERT INTO departments_dup(dept_no)
VALUES ('d010'), ('d011');

ALTER TABLE departments_dup
ADD COLUMN dept_manager VARCHAR(255) NULL AFTER dept_name;

COMMIT;

Now, we need to change NULL values in dept_name column with 'Department Name Not Provided' string, IF NULL we come to rescue.

IFNULL(expr_1, expr_2)
returns the first of the two indicated values if the data value found in the table is not null, and returns the second value if there is a null value.

SELECT
    dept_no,
    IFNULL(dept_name,
            'Department Name Not Provided') as dept_name
FROM
    departments_dup;

IFNULL Limitations - It cannot contain more than 2 parameters. This is where COALESCE comes in.

COALESCE(expr_1, expr_2,... expr_N) - allows you to insert N arguments in the parentheses.
-------------------------------------
    We can think of COALESCE() as IFNULL with more than two parameters.
    COALESCE() will always return a single value of the ones we have within parentheses, and this value will be the first non-null value of this list, reading teh values from left to right.
    If COALESCE() has two args, it will works precisely like IFNULL().

Eg: SELECT
        dept_no,
        COALESCE(dept_name,
                'Department Name Not Provided') AS dept_name
    FROM
        departments_dup;

Eg: dept_manager IFNULL fill it with dept_name else 'N/A'
SELECT
    dept_no,
    dept_name,
    COALESCE(dept_manager, dept_name, 'N/A') AS dept_manager
FROM
    departments_dup
ORDER BY dept_no ASC;

IMP NOTE - IFNULL and COALESCE do not make changes to the original dataset. They merely create an output(returns a copy) where certain data values appear in place of NULL values.

Another intereseting way if which we can use COALESCE
COALESCE(expr_1) - We can pass just a single value to COALESCE, how is it interpreted. Create new cols with dummy values.
SELECT
    dept_no,
    dept_name,
    COALESCE('dept manager name') AS fake_col,
    COALESCE('dept name') AS another_fake_col
FROM
    departments_dup
ORDER BY dept_no ASC;

Exercise: Select the department number and name from the ‘departments_dup’ table and add a third column where you name the department number (‘dept_no’) as ‘dept_info’. If ‘dept_no’ does not have a value, use ‘dept_name’.
SELECT
    dept_no,
    dept_name,
    COALESCE(dept_no, dept_name) AS dept_info
FROM
    departments_dup
ORDER BY dept_no ASC;

Exercise: Modify the code obtained from the previous exercise in the following way. Apply the IFNULL() function to the values from the first and second column, so that ‘N/A’ is displayed whenever a department number has no value, and ‘Department name not provided’ is shown if there is no value for ‘dept_name’.
SELECT
    IFNULL(dept_no, 'N/A') as dept_no,
    IFNULL(dept_name,'Dept Name Not Provided') as dept_name,
    COALESCE(dept_no, dept_name) AS dept_info
FROM
    departments_dup
ORDER BY dept_no ASC;

JOINS:
======
The SQL tool that allow us to construct a relationship between objects.
Relational schemas are the perfect tool that will help you find a strategy for linking tables.
A join shows a resultset, containing fields derived from two or more tables.
Steps:
    We must find a related column from the two tables that contains the same type of data.
    We will be free to add columns from these two tables to our output.
Conditions:
    The column you use to relate tables must represent the same object, such as id.
    The tables you are considering need not be logically adjacent(mean directly connected through keys) Both tables should have just a column connecting them.

Inner Join:
===========
Common(Matching) records of a columns for two or more tables.
Default join is inner join.

Syntax:
SELECT
    table1.colNames, table2.colNames
FROM
    table1
JOIN
    table2 ON table1.colName = table2.colName;

Professional use Aliases:
SELECT
    t1.col1, t1.col2, t2.col1
FROM
    table1 t1
JOIN
    table2 t2
ON
    t1.coln=t2.coln

Eg:
Without Aliases:
SELECT
    departments_dup.dept_no,
    departments_dup.dept_name,
    dept_manager_dup.emp_no,
    dept_manager_dup.from_date
FROM
    departments_dup
        JOIN
    dept_manager_dup ON departments_dup.dept_no = dept_manager_dup.dept_no;

With Aliases:
SELECT
    d.dept_no,
    d.dept_name,
    m.emp_no,
    m.from_date
FROM
    departments_dup d
        INNER JOIN
    dept_manager_dup m ON d.dept_no = m.dept_no;

Exercise - Extract a list containing information about all managers’ employee number, first and last name, department number, and hire date.
SELECT
    e.emp_no, e.first_name, e.last_name, m.dept_no, m.from_date
FROM
    employees e
        JOIN
    dept_manager m ON e.emp_no = m.emp_no
ORDER BY e.emp_no;


Duplicate Records:
------------------
Duplicate Records, also known as duplicate rows are identical rows in an SQL table.
    - for a pair of duplicate records, the values in each column coincide.
Duplicate rows are not always allowed in a database or a data table.
    - they are sometimes encountered, especially in new, raw and uncontrolled data.

Adding duplicate rows in tables:
select * from dept_manager_dup order by emp_no;
select * from departments_dup order by dept_no;

insert into dept_manager_dup
values ('110228', 'd003', '1992-03-21', '9999-01-01');

insert into departments_dup
values ('d009', 'Customer Service');


To remove duplicate orders, use Group by
SELECT
    m.dept_no, m.emp_no, d.dept_name
FROM
    departments_dup d
        JOIN
    dept_manager_dup m ON d.dept_no = m.dept_no
GROUP BY m.emp_no
ORDER BY dept_no;

If you get error while group non aggregated columns like:
Error Code: 1055. Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'employees.m.dept_no' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

Then use below code:
SET sql_mode=(SELECT REPLACE(@@sql_mode,'ONLY_FULL_GROUP_BY',''));

Note - When dealing with millions of rows or even small dataset, it is always preferable to use group by to remove any duplicate record other than assuming that there are no duplicate rows in your data.

LEFT JOIN
==========
Get all matching values from the two table +
all values from the left table that match no values from the right table.

When working with left join, the order of the table on which tables are join matter A LOT.

When working with left join, keep in mind to select the common column(on which equals is operated) to be fetched from the left table

Removing duplicates:
# Delete dupes
delete from dept_manager_dup where emp_no='110228';
delete from departments_dup where dept_no = 'd009';

# Add back initial records
insert into departments_dup
values ('d009', 'Customer Service');

insert into dept_manager_dup
values ('110228', 'd003', '1992-03-21', '9999-01-01');

Left Join Ex:
SELECT
    m.emp_no, m.dept_no, d.dept_name
FROM
    dept_manager_dup m
        LEFT JOIN
    departments_dup d ON m.dept_no = d.dept_no
GROUP BY m.emp_no
ORDER BY dept_no;

Interchange the table(fetch dept_no from d table now)
SELECT
    m.emp_no, d.dept_no, d.dept_name
FROM
    departments_dup d
        LEFT JOIN
    dept_manager_dup m ON m.dept_no = d.dept_no
GROUP BY m.emp_no
ORDER BY dept_no;

Why is inner join, called inner join?
Because the result set is in the inner part of the Venn diagram.

Why is left join, called left join?
Because the result set is output obtained from the outer (left) too along with inner(common) part of the Venn diagram.
Hence, we can use LEFT OUTER JOIN instead of left join and we will obtain same result.
Remember, LEFT JOIN and LEFT OUTER JOIN are same, hence professionally there is no option to use OUTER keyword.

SELECT
    m.emp_no, d.dept_no, d.dept_name
FROM
    departments_dup d
        LEFT OUTER JOIN
    dept_manager_dup m ON m.dept_no = d.dept_no
GROUP BY m.emp_no
ORDER BY dept_no;

With Left join, we can also fetch only the records from the left table that do not match any rows from the right table. Hence excluding the inner part of venn diagram.
The trick here is to apply WHERE clause passing the column of right table as IS NULL (dept_name in below example).

SELECT
    m.emp_no, m.dept_no, d.dept_name
FROM
    dept_manager_dup m
        LEFT JOIN
    departments_dup d ON m.dept_no = d.dept_no
WHERE
    dept_name IS NULL
GROUP BY m.emp_no
ORDER BY dept_no;

Exercise: Join the 'employees' and the 'dept_manager' tables to return a subset of all the employees whose last name is Markovitch. See if the output contains a manager with that name.
          Hint: Create an output containing information corresponding to the following fields: ‘emp_no’, ‘first_name’, ‘last_name’, ‘dept_no’, ‘from_date’. Order by 'dept_no' descending, and then by 'emp_no'.

SELECT
    e.emp_no, e.first_name, e.last_name, m.dept_no
FROM
    employees e
        LEFT JOIN
    dept_manager m ON e.emp_no = m.emp_no
WHERE
    e.last_name = 'Markovitch'
GROUP BY e.emp_no
ORDER BY m.dept_no DESC, e.emp_no;


RIGHT JOIN
----------
Their functionality is identical to LEFT JOINs, with the only difference being that the direction of the operation is inverted.
Same as RIGHT OUTER JOIN.
RIGHT JOINs are seldom used in practise.

SELECT
    m.emp_no, e.first_name, e.last_name, m.dept_no
FROM
    employees e
        RIGHT JOIN
    dept_manager m ON e.emp_no = m.emp_no
WHERE
    e.last_name = 'Markovitch'
GROUP BY e.emp_no
ORDER BY m.dept_no DESC, e.emp_no;

Left and Right join are examples of one to many relationships.
Entries which are common to two tables are called connection points.

OLD JOIN syntax where join keyword was not used, the output is generated using where: PRACTICALLY NOT USED AS IT IS TIME CONSUMING
-------------------------------------------------
Syntax:
SELECT
    t1.col1, t1.col2, t2.col1
FROM
    tab1 t1,
    tab2 t2
WHERE t1.col = t2.col;

Eg: Inner Join can replaced by
SELECT
    d.dept_no,
    d.dept_name,
    m.emp_no,
    m.from_date
FROM
    departments_dup d, # Here we have a comma
    dept_manager_dup m
WHERE
	d.dept_no = m.dept_no;

IT IS NOT USED IN PRACTICE:
It is the same as JOIN as the retreived output is identical.
For small tables Where can be faster but for large tables always use JOIN as it is much faster.
The WHERE syntax is perceived as morally old and is rately employed by professionals.
The Join syntax allows you to modify the connection between tables easily.
It can be used from more than two tables.
WHERE + EXIST will be used in future which will do wonders.

Exercise:
Extract a list containing information about all managers’ employee number, first and last name, department number, and hire date. Use the old type of join syntax to obtain the result.
Old Join method
select
	e.emp_no, e.first_name, e.last_name, m.dept_no, m.from_date
from
employees e,
dept_manager m
where
e.emp_no = m.emp_no;

New Join method
SELECT
    e.emp_no, e.first_name, e.last_name, m.dept_no, m.from_date
FROM
    employees e
        JOIN
    dept_manager m ON e.emp_no = m.emp_no;

JOIN + WHERE:
=============
If in a query you encounter both Join and Where then
Join - is used for connecting the Employees and Salaries table
Where - is used to define the condition or conditions that will determine which will be the connecting points between the two tables.

Eg. Say, we want to get employee's first name and last name whose salary is greater than $145000
SELECT
    e.emp_no, e.first_name, e.last_name, s.salary
FROM
    employees e
        JOIN
    salaries s ON e.emp_no = s.emp_no
WHERE
    s.salary > 145000
GROUP BY emp_no
ORDER BY salary DESC , emp_no;

It's always a good practise to include a column in output(select) which are part of JOIN ON and Where.

Exercise:
Select the first and last name, the hire date, and the job title of all employees whose first name is “Margareta” and have the last name “Markovitch”.
SELECT
    e.emp_no, e.first_name, e.last_name, e.hire_date, t.from_date, t.title
FROM
    employees e
        JOIN
    titles t ON e.emp_no = t.emp_no
WHERE
    e.first_name = 'Margareta'
        AND e.last_name = 'Markovitch'
GROUP BY e.emp_no
ORDER BY e.emp_no;

CROSS JOIN
-----------
Each value of from one table will be crossed(joined) with every value of another table. i.e
Each row of one table is mapped to every row of another table.

It is like
for i in range(n):
    for j in range(m)
        i*j

It's is somewhat similar to join in pandas
'ABC '.join('abc')

Example: Cross join dept_manager and departments table on emp_no to get m*n mapping
SELECT
    m.*, d.*
FROM
    dept_manager m
        CROSS JOIN
    departments d
ORDER BY m.emp_no , d.dept_no;

With old style join, removing where works like cross join.
SELECT
    m.*, d.*
FROM
    dept_manager m,
    departments d
ORDER BY m.emp_no , d.dept_no;

Other way to get cross join is to use join withoout ON
SELECT
    m.*, d.*
FROM
    dept_manager m
    JOIN
    departments d
ORDER BY m.emp_no , d.dept_no;

 But the best practice is to use CROSS Join and not Inner Join without ON or old join without where.
 Because clarity is a substantial part of writing good code.

 Example: Get cross product of departments and dept_manager where dept_no of departments is not dept_no equal to dept_manager
 SELECT
     m.*, d.*
 FROM
     dept_manager m
         JOIN
     departments d
 WHERE
     m.dept_no <> d.dept_no
 ORDER BY m.emp_no , d.dept_no;

 We can CROSS Join more than TWO tables.
 But the result set might become too big so be careful.

 Cross Join 3 tables:
 employees, departments and dept_manager
 SELECT
     e.*, m.*, d.*
 FROM
     employees e
         CROSS JOIN
     dept_manager m
         CROSS JOIN
     departments d
 WHERE
     e.emp_no = m.emp_no
 ORDER BY m.emp_no , d.dept_no;

 OR
 SELECT
     e.*, m.*, d.*
 FROM
     employees e
         CROSS JOIN
     dept_manager m
         JOIN
     departments d ON e.emp_no = m.emp_no
 ORDER BY m.emp_no , d.dept_no;

 Exercise:Use a CROSS JOIN to return a list with all possible combinations between managers from the dept_manager table and department number 9.

SELECT
    m.*, d.*
FROM
    dept_manager m
        CROSS JOIN
    departments d
WHERE
    d.dept_no = 'd009'
ORDER BY m.emp_no , d.dept_no;

Exercise: Return a list with the first 10 employees with all the departments they can be assigned to.
          Hint: Don’t use LIMIT; use a WHERE clause.
SELECT
    e.*, d.*
FROM
    employees e
        CROSS JOIN
    departments d
WHERE
    e.emp_no < '10011'
ORDER BY e.emp_no , d.dept_no;

Aggregate functions with Joins:
-------------------------------
Find avg salaries of men aand women in the company.
SELECT
    e.gender, ROUND(AVG(s.salary),2) AS avg_salary
FROM
    employees e
        JOIN
    salaries s ON e.emp_no = s.emp_no
GROUP BY gender;

Just be careful with the select statement column, if you would have used e.emp_no as well then mysql would have returned first emp_no of each gender in output. Other sql servers would have raised error.
Which is not what you would have expected.
SELECT
    e.emp_no, e.gender, AVG(s.salary) AS avg_salary
FROM
    employees e
        JOIN
    salaries s ON e.emp_no = s.emp_no
GROUP BY gender;

# emp_no, gender, avg_salary
'10001', 'M', '63755.9134'
'10002', 'F', '63769.1222'

Joins should be handled with care:
--------------------------------
SQL allows to join more than two tables - when creating a query that joins multiple tables, you must back it with string intuition and a crystal-clear idea of how you would like the tables to be connected.
SELECT
    e.emp_no,
    e.first_name,
    e.last_name,
    m.from_date,
    d.dept_name
FROM
    employees e
        JOIN
    dept_manager m ON e.emp_no = m.emp_no
        JOIN
    departments d ON m.dept_no = d.dept_no;

OR
SELECT
    e.emp_no,
    e.first_name,
    e.last_name,
    m.from_date,
    d.dept_name
FROM
    employees e
        JOIN
    dept_manager m
        JOIN
    departments d ON m.dept_no = d.dept_no AND e.emp_no = m.emp_no;

Same query can be used with left and rights join.

Exercise - Select all managers’ first and last name, hire date, job title, start date, and department name.
SELECT
    e.emp_no,
    e.first_name,
    e.last_name,
    e.hire_date,
    t.title,
    m.from_date AS start_date,
    d.dept_name
FROM
    employees e
        JOIN
    titles t ON e.emp_no = t.emp_no
        JOIN
    dept_manager m ON t.emp_no = m.emp_no
        JOIN
    departments d ON m.dept_no = d.dept_no
WHERE
    t.title = 'Manager'
ORDER BY e.emp_no;

Tips and Tricks on Join
------------------------
While joining tables, one should look for key columns, which are common between the tables involved in the analysis and are necessary to solve the task at hand i.e we don't have to find a proper linking between relational schema we can search for common cols across required tables to join and join them.
The columns may not be Pk or FK

Q. Get avg salary of all managers by departments
SELECT
    d.dept_name, AVG(s.salary) AS avg_salary
FROM
    dept_manager m
        JOIN
    departments d ON m.dept_no = d.dept_no
        JOIN
    salaries s ON m.emp_no = s.emp_no
GROUP BY d.dept_name
HAVING avg_salary > 60000
ORDER BY avg_salary DESC;

AS AN ANALYST YOU JOB IS FOR FIND ACCURATE DATE QUICKLY.

Exercise:   How many male and how many female managers do we have in the ‘employees’ database?
SELECT
    e.gender, COUNT(dm.emp_no)
FROM
    employees e
        JOIN
    dept_manager dm ON e.emp_no = dm.emp_no
GROUP BY gender;

OR
SELECT
    e.gender, COUNT(e.emp_no)
FROM
    employees e
        JOIN
    titles t ON e.emp_no = t.emp_no
WHERE
    t.title = 'Manager'
GROUP BY e.gender;

UNION vs UNION ALL
==================
# Creating employees_dup table
DROP table if exists employees_dup;

CREATE TABLE employees_dup (
    emp_no INT,
    birth_date DATE,
    first_name VARCHAR(14),
    last_name VARCHAR(16),
    gender ENUM('M', 'F'),
    hire_date DATE
);

insert into employees_dup
select * from employees limit 20;

select * from employees_dup;

# inserting duplicate first row
insert into employees_dup values
('10001', '1953-09-02', 'Georgi', 'Facello', 'M', '1986-06-26');

UNION ALL
---------
Used to combine few select statement in a single output.
we can think of it as a tool that allows you to unify tables.

Syntax:
SELECT
    N columns
FROM
    table1
UNION ALL
SELECT
    N columns
FROM
    table2

Conditions:
We have to select same number of columns from each table.
These columns should have the same name, should be in the same order, and should contain related datatypes.

Let's union all employees_dup and dept_managers table but since the col names for both tables should be same, we will have to add null cols of 1 table to another.
SELECT
    e.emp_no,
    e.first_name,
    e.last_name,
    NULL AS dept_no,
    NULL AS from_date
FROM
    employees_dup e
UNION ALL SELECT
    NULL AS emp_no,
    NULL AS first_name,
    NULL AS last_name,
    m.dept_no,
    m.from_date
FROM
    dept_manager m;

UNION - is same as UNION ALL, replace UNION ALL with UNION

SELECT
    e.emp_no,
    e.first_name,
    e.last_name,
    NULL AS dept_no,
    NULL AS from_date
FROM
    employees_dup e
UNION SELECT
    NULL AS emp_no,
    NULL AS first_name,
    NULL AS last_name,
    m.dept_no,
    m.from_date
FROM
    dept_manager m;

Only difference in the output being no duplicate entry in the output of UNION.

Hence, when uniting two identically organized tables:
- UNION displays only distinct values in the output and UNION ALL provides the duplicates as well.
- Since UNION does not supports duplicates, it required more computational power and storage especially large tables.

Exercise - Go forward to the solution and execute the query. What do you think is the meaning of the minus sign before subset A in the last row (ORDER BY -a.emp_no DESC)?
SELECT
    *
FROM
    (SELECT
        e.emp_no,
            e.first_name,
            e.last_name,
            NULL AS dept_no,
            NULL AS from_date
    FROM
        employees e
    WHERE
        last_name = 'Denis' UNION SELECT
        NULL AS emp_no,
            NULL AS first_name,
            NULL AS last_name,
            dm.dept_no,
            dm.from_date
    FROM
        dept_manager dm) AS a
ORDER BY  -a.emp_no DESC;

-ve support start of emp_no from non-null value. i.e it basically ignores nulls and place them at the end.

SQL Subqueries
---------------
subqueries - queries embedded in a query.
These are also called nested queries or inner queries or inner select and they are part of another query called an outer query or outer select.
In most cases sub-query is embedded in where clause of select statement.

Eg:
SELECT
    e.first_name, e.last_name
FROM
    employees e
WHERE
    e.emp_no IN (SELECT
            dm.emp_no
        FROM
            dept_manager dm)

a subquery should always be placed within parentheses.
From processing points of view, the sql engine:
1. The sql engine starts by running the inner query.
2. Then it uses its returned output, which is intermediate, to execute the outer query.

A subquery main return a single value(a scaler), a single row, a single column or and entire table.
We can have lot many queries in the outer query.
it is possible to nest inner queries within other inner queries - in that case the SQL engine would execute the innermost query first, and then each subsequent query, until it runs the outermost query last.

Exercise: Extract the information about all department managers who were hired between the 1st of January 1990 and the 1st of January 1995.
SELECT
    *
FROM
    dept_manager
WHERE
    emp_no IN (SELECT
            emp_no
        FROM
            employees
        WHERE
            hire_date BETWEEN '1990-01-01' AND '1994-12-31');

Select the entire information for all employees whose job title is “Assistant Engineer” - USE EXISTS
SELECT
    *
FROM
    employees e
WHERE
    EXISTS( SELECT
            *
        FROM
            titles t
        WHERE
            t.emp_no = e.emp_no
                AND title = 'Assistant Engineer');

The SQL EXISTS Operator
------------------------
The EXISTS operator is used to test for the existence of any record in a subquery.
The EXISTS operator returns TRUE if the subquery returns one or more records.

Syntax:
SELECT column_name(s)
FROM table_name
WHERE EXISTS
(SELECT column_name FROM table_name WHERE condition);

Subqueries can be placed in Select and From clause as well
-----------------------------------------------------------
Make emp_id 110022 as manager of 110001 to 110020 and emp_id 110039 as manager of 110021 to 110040
SELECT
    A.*
FROM
    (SELECT
        e.emp_no AS employee_ID,
            MIN(de.dept_no) AS department_code,
            (SELECT
                    emp_no
                FROM
                    dept_manager
                WHERE
                    emp_no = '110022') AS manager_ID
    FROM
        employees e
    JOIN dept_emp de ON e.emp_no = de.emp_no
    WHERE
        e.emp_no <= 10020
    GROUP BY e.emp_no
    ORDER BY e.emp_no) AS A
UNION SELECT
    B.*
FROM
    (SELECT
        e.emp_no AS employee_ID,
            MIN(de.dept_no) AS department_code,
            (SELECT
                    emp_no
                FROM
                    dept_manager
                WHERE
                    emp_no = '110039') AS manager_ID
    FROM
        employees e
    JOIN dept_emp de ON e.emp_no = de.emp_no
    WHERE
        e.emp_no > 10020
    GROUP BY e.emp_no
    ORDER BY e.emp_no
    LIMIT 20) AS B;

Exercise - Starting your code with “DROP TABLE”, create a table called “emp_manager” (emp_no – integer of 11, not null; dept_no – CHAR of 4, null; manager_no – integer of 11, not null).

DROP TABLE IF EXISTS emp_manager;

Create table emp_manager (
	emp_no INT NOT NULL,
    dept_no CHAR(4) NULL,
    manger_no INT NOT NULL
);

Exercise -
SQL Subqueries nested in SELECT and FROM - exercise 2
Fill emp_manager with data about employees, the number of the department they are working in, and their managers.
Your query skeleton must be:
Insert INTO emp_manager SELECT
U.*
FROM
(A)
UNION (B) UNION (C) UNION (D) AS U;
A and B should be the same subsets used in the last lecture (SQL Subqueries Nested in SELECT and FROM). In other words, assign employee number 110022 as a manager to all employees from 10001 to 10020 (this must be subset A), and employee number 110039 as a manager to all employees from 10021 to 10040 (this must be subset B).
Use the structure of subset A to create subset C, where you must assign employee number 110039 as a manager to employee 110022.
Following the same logic, create subset D. Here you must do the opposite - assign employee 110022 as a manager to employee 110039.
Your output must contain 42 rows.

INSERT INTO emp_manager
(SELECT
    U.*
FROM
    ((SELECT
        A.*
    FROM
        (SELECT
        e.emp_no AS employee_ID,
            MIN(de.dept_no) AS department_code,
            (SELECT
                    emp_no
                FROM
                    dept_manager
                WHERE
                    emp_no = 110022) AS manager_ID
    FROM
        employees e
    JOIN dept_emp de ON e.emp_no = de.emp_no
    WHERE
        e.emp_no <= 10020
    GROUP BY e.emp_no
    ORDER BY e.emp_no) AS A) UNION (SELECT
        B.*
    FROM
        (SELECT
        e.emp_no AS employee_ID,
            MIN(de.dept_no) AS department_code,
            (SELECT
                    emp_no
                FROM
                    dept_manager
                WHERE
                    emp_no = '110039') AS manager_ID
    FROM
        employees e
    JOIN dept_emp de ON e.emp_no = de.emp_no
    WHERE
        e.emp_no > 10020
    GROUP BY e.emp_no
    ORDER BY e.emp_no
    LIMIT 20) AS B) UNION (SELECT
        C.*
    FROM
        (SELECT
        e.emp_no AS employee_ID,
            MIN(de.dept_no) AS department_code,
            (SELECT
                    emp_no
                FROM
                    dept_manager
                WHERE
                    emp_no = 110039) AS manager_ID
    FROM
        employees e
    JOIN dept_emp de ON e.emp_no = de.emp_no
    WHERE
        e.emp_no = 110022
    GROUP BY e.emp_no
    ORDER BY e.emp_no) AS C) UNION (SELECT
        D.*
    FROM
        (SELECT
        e.emp_no AS employee_ID,
            MIN(de.dept_no) AS department_code,
            (SELECT
                    emp_no
                FROM
                    dept_manager
                WHERE
                    emp_no = 110022) AS manager_ID
    FROM
        employees e
    JOIN dept_emp de ON e.emp_no = de.emp_no
    WHERE
        e.emp_no = 110039
    GROUP BY e.emp_no
    ORDER BY e.emp_no) AS D)) AS U);

select * from emp_manager;

SQL Self Join:
---------------
Applied when a table must join itself.
If you'd like to combine certain rows of a table with other rows of the same table, you need a self-join.
It is same as inner join which will be applied on same table.
The 2 tables will be identical to the table you'll be using the self-join.
You can think of them as virtual projections of the underlying base table.
The data use will come from a single source, which is the underlying table that stores data physically.
In this case using alias(like employees as e1 or employees as e2) is obligatory.
These reference(e1 and e2) to the original table let you use different blocks of the available data. You can either filter both in the join or you can filter on of them in WHERE clause and the other one, in the join.

Task - From emp_manager table, extract the record data only of those employees who are managers as well.
select e1.* from
emp_manager e1
JOIN emp_manager e2
ON e1.emp_no = e2.manager_no
where e2.emp_no IN (select manager_no from emp_manager);

Another way - less sophisticated
select e1.* from
emp_manager e1
JOIN emp_manager e2
ON e1.emp_no = e2.manager_no
where e2.emp_no IN (select manager_no from emp_manager);

SQL Views
----------
A virtual table whose contents are obtained from an existing table or tables, called base tables.
The retrieval happens through an SQL statement, incorporated into the view.

Think of the view object as a view into the base table.
The view itself does not contain any real data; the data is physically stored in the base table.
The view simply shos the data contained in the base table.

Syntax of View -
CREATE [OR REPLACE] VIEW view_name AS ## general practise to start view names as v_ or w_
SELECT
    col1, col2, ... coln
from
    tablename;

Create a view of dept_emp table, with max from_date and to_date.
CREATE OR REPLACE VIEW v_dept_emp_latest_date AS
    SELECT
        emp_no, MAX(from_date) AS from_date, MAX(to_date) AS to_date
    FROM
        dept_emp
    GROUP BY emp_no;

SELECT
    *
FROM
    v_dept_emp_latest_date;

Why do we need views in general, can't we just select statement and obtain a desired output?
Imagine your db is used by a web app in turn used by billions of users if you would like to allow each user to see this table instead of typing and running sql select statement each time a user request appears, the view can allow each user to see the result set on their user space.
A view acts as a short cu for witing the same SELECT statement each time a new request has been made.

It save a lot of coding time.
Occupies no extra memory.

Acts as a dynamic table because it instantly reflects data and structural changes in the base table.

Eg. If we modify the to_date of emp_no 10001 in dept_emp table the same changed value will appear in view.
UPDATE dept_emp
SET
    to_date = '2025-06-05'
WHERE
    emp_no = 10001;

SELECT
    *
FROM
    v_dept_emp_latest_date  where emp_no=10001;

Don't forget they are not real physical data sets meaning we cannot insert or update the information that has already been extracted.
They should be seen as temporary virtual data tables retrieving information from base tables.

Exercise - Create a view that will extract the average salary of all managers registered in the database. Round this value to the nearest cent.
           If you have worked correctly, after executing the view from the “Schemas” section in Workbench, you should obtain the value of 66924.27.
CREATE OR REPLACE VIEW v_avg_manager_sal AS
    SELECT
        ROUND(AVG(s.salary), 2) as avg_mngr_sal
    FROM
        salaries s
            JOIN
        dept_manager m ON s.emp_no = m.emp_no;

select * from v_avg_manager_sal; # '66924.27'

Stored Routines
===============
Routine definition - A usual, fixed action, or series of actions, repeated periodically.

Stored Routine - an SQL statement, or a set of SQL statements, that can be stored on the database server.
Whenever a user needs to run the query in question, they can call, reference or invoke the routine.

Stored Routines are of two types -
    Stored Procedures -- also called procedures
    Functions   -- User defined functions / built-in functions.

semi-colons - they function as a statement terminator.
    - technically, they can also be called delimiters.

by typing DELIMTER $$, we'll be able to use the dollar symbols as the delimiter.
DELIMITER $$
The semi-colon won't be our delimiter anymore.

Why would we want to set a temporary delimiter?
In your long sheet of code, each query is terminated by a semi-colon.
Then if we call a stored procedure that uses the semi-colon as a delimiter. In that case SQL engine will run only the first query in the stored procedure delimited by semi-colon and will come out of the procedure without running other queries.

Query1;
Query2;
call stored_proc1;      --> p_Query1;
                            p_Query2; ## won't be called
Query3;

To avoid this problem, we need a temporary delimiter different from the standard semi-colon.
There are various temp delimiter which can be used like $$ or //

Query1;
Query2;
call stored_proc1;      --> DELIMTER $$
                            p_Query1$$
                            p_Query2$$
Query3;

Syntax:
DELIMITER $$
CREATE PROCEDURE procedure_name([param1, param2])      # Parameters represent certain values that the procedure will use to complete the calculation,        BEGIN                                             #  it is suppose to execute
        SELECT * FROM employees                         # For this query we are creating the stored procedure
        LIMIT 100;
     END$$
DELIMITER ;                                             ## From this line ; will again act as a delimtier

Eg: Create a non-parameterized procedure which returns first 100o rows from the employees table.
DROP PROCEDURE IF EXISTS select_employees;
DELIMITER $$
CREATE PROCEDURE select_employees()
	BEGIN
		SELECT * FROM employees
        LIMIT 1000;
	END$$
DELIMITER ;

There are 3 ways to call a procedure:
1. call dbname.proc_name(); # call employees.select_employees(); # can be called without () but it is general practise to use ()
2. use dbname; call proc_name() # call select_employees()
3. Lighting symbol besides procedure name in workbench.

Exercise - Create a procedure that will provide the average salary of all employees.
DROP Procedure if exists avg_salary;
DELIMITER $$
Create Procedure avg_salary()
BEGIN
	select avg(salary) as avg_salary from salaries;
END$$
Delimiter ;;

call avg_salary();

We can also create a stored proc using work bench tools -
Right Click on StoredProcedure drop down in employees table
Click on Option 'Create Stored Procedure'
New tab will be opened with the Procedure structure.
You just need to change the name and insert the logic.
This process helps with the boiler plate code.

How can we drop a procedure?
DROP PROCEDURE procedure_name;
Eg. - DROP PROCEDURE select_employees;
Or Right click on procedure and select 'Drop Stored Procedure'

Stored Procedures with IN parameters:
----------------------------------
A stored routine can perform calculation that transforms an input value in an output value.
Stored Procedures can take an input value and then use it in the query, or queries, written in the body pf the procedure.
    This value is represented by the IN parameter.
    After the calculation is ready, a result will be returned.

With the IN parameter, the passed value is used as a variable in stored proc and then the output of the query/queries is returned.
But sometimes we need to return the output as a variable which can be used in other functions or other parts of the code, for that we can use out param.

DELIMITER $$
CREATE PROCEDURE procedure_name(in parameter)
BEGIN
    SELECT * FROM employees
    LIMIT 1000;
END$$
DELIMITER ;


Eg - select first_name, last_name, salary, from_date, to_date of the specified employee
DROP PROCEDURE IF EXISTS emp_salary;
DELIMITER $$
CREATE PROCEDURE emp_salary(IN p_emp_no INT)
BEGIN
	SELECT
		e.first_name, e.last_name, s.salary, s.from_date, s.to_date
	FROM
		employees e
			JOIN
		salaries s ON e.emp_no = s.emp_no
	WHERE
		e.emp_no = p_emp_no;
END$$
DELIMITER ;

call emp_salary(10001);

Eg - Select Avg Salary along with first and last name of the employee.
DROP PROCEDURE IF EXISTS emp_avg_salary;

DELIMITER $$
CREATE PROCEDURE emp_avg_salary(IN p_emp_no INT)
BEGIN
	SELECT
		e.first_name, e.last_name, AVG(s.salary) as avg_sal
	FROM
		employees e
		JOIN
		salaries s ON e.emp_no = s.emp_no
	WHERE e.emp_no = p_emp_no
    GROUP BY e.emp_no;
END$$
DELIMITER ;

call emp_avg_salary(10300);

Stored Procedures with IN and OUT parameters
============================================
With the IN parameter, the passed value is used as a variable in stored proc and then the output of the query/queries is returned.
But sometimes we need to return the output as a variable which can be used in other functions or other parts of the code, for that we can use out param.
OUT parameter will represent the variable containing the output value o the operation executed by the query of the stored procedure.

CREATE PROCEDURE procedure_name(in parameter, out parameter)

Eg:
DROP PROCEDURE IF EXISTS emp_avg_sal_out;
DELIMITER $$
CREATE PROCEDURE emp_avg_sal_out(IN p_emp_no INT, OUT p_avg_sal DECIMAL(10,2))
BEGIN
	SELECT AVG(s.salary) INTO p_avg_sal
	FROM
		employees e
	JOIN
		salaries s ON e.emp_no = s.emp_no
	WHERE e.emp_no=p_emp_no
	GROUP BY e.emp_no;
END$$
DELIMITER ;

set @v_avg_sal = 0;
call emp_avg_sal_out(10001, @v_avg_sal);
select @v_avg_sal;

Exercise - Create a procedure called ‘emp_info’ that uses as parameters the first and the last name of an individual, and returns their employee number.

DROP PROCEDURE IF EXISTS emp_info;
DELIMITER $$
CREATE PROCEDURE emp_info(IN p_first_name VARCHAR(20), IN p_last_name VARCHAR(20), OUT p_emp_no INT)
BEGIN
    SELECT emp_no INTO p_emp_no FROM employees WHERE p_first_name=first_name AND  last_name=p_last_name;
END$$
DELIMITER ;

SET @v_emp_no=0;
CALL emp_info('Parto', 'Bamford', @v_emp_no);
SELECT @v_emp_no;

Variables:
----------
When we are defining a program, such as a stored procedure for instance, we can say that we are using parameters.
One the stored proc structure has been solidified(signature is set) then it will be applied to the database. The input value you inser is typically referred to as the argument, while the obtained value is stored in a variable.
SET keyword is used to define a variable.
For SQL engine to understand that a text is a variable, it should be prefixed with @
Normal practice is to use v as the prefix.
Eg: SET v_emp_no=0 # Initially variable is assigned with value 0

IN-OUT PARAMETER -
We can pass IN-OUT parameter to a stored proc where the in and out values will be same.

Exercise - Create a variable, called ‘v_emp_no’, where you will store the output of the procedure you created in the last exercise.
           Call the same procedure, inserting the values ‘Aruna’ and ‘Journel’ as a first and last name respectively.
           Finally, select the obtained output.

 SET @v_emp_no=0;
 CALL emp_info('Aruna', 'Journel', @v_emp_no);
 SELECT @v_emp_no;

 User Defined Functions in MySQL
 -------------------------------
 Syntax:

 DELIMTER $$
 CREATE FUNCTION func_name(parameter datatype) RETURNS datatype
 DETERMINISTIC NO SQL READS SQL DATA
  BEGIN
 DECLARE variable_name datatype
    SELECT .... INTO out_var ....
 RETURN variable_name
 END$$
 DELIMITER ;

 Difference between stored proc and func?
 Function does not have OUT parameters to define between the parentheses after the object's name.
 All parameters are IN, and since this well known, we need not explicitly indicate it with the word IN.
 Althoughm there are no OUT paramters, there is a return value.
 It is obtained after running the query contained in the body of the function. It can be of any datatype.

 Eg - Function to Get Avg Salary by providing an empno
 DROP FUNCTION IF EXISTS f_emp_avg_salary;
 DELIMITER $$
 CREATE FUNCTION f_emp_avg_salary (p_emp_no INT) RETURNS DECIMAL(10,2)
 DETERMINISTIC NO SQL READS SQL DATA
 BEGIN
 	DECLARE v_avg_sal DECIMAL(10,2);
 	select ROUND(AVG(salary)) INTO v_avg_sal from
     employees e
     join salaries s on e.emp_no = s.emp_no
     where e.emp_no=p_emp_no
     group by e.emp_no;
     RETURN v_avg_sal;
 END $$
 DELIMITER ;

 #Calling function
 SELECT f_emp_avg_salary(10001);

 To get rid of Error 1418
 SET @@global.log_bin_trust_function_creators := 1;

 Error Code: 1418.
 Error Code: 1418. This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled…

 Let’s begin by saying that a log is a software component where you can save information about some events or errors that happened during the execution of a certain application. A log is preserved for traceability or debugging reasons and this is how it is used in MySQL as well.

 Consequently, a Binary Log is a log that contains database changes. This type of logging affects the way in which we need to structure our code when creating MySQL functions.

 When the Binary Log has been enabled, it will always check whether a function is changing the data in the database and what is the result to be produced. The situation can be described like this.

 Unless we specify what the exact behavior of our function should be, our code will lead to an error. This error is with code 1418 and states that the function has none of the following characteristics in its declaration: DETERMINISTIC, NO SQL, or READS SQL DATA.

 To solve this error, we must include one (or more) of these characteristics in our code in the way shown in the previous video. They must be placed right after we ‘ve specified the return type of the function. Here’s the syntax to use:

 create function <function name> <function parameters> returns <type> <characteristics> …
 Let’s check the meaning of these characteristics:
 · DETERMINISTIC – it states that the function will always return identical result given the same input
 · NO SQL – means that the code in our function does not contain SQL (rarely the case)
 · READS SQL DATA – this is usually when a simple SELECT statement is present

 When none of those is present in our code, MySQL assumes that our function is non deterministic and that it changes data. This might not be the case, but still, in the end, an error is raised just because MySQL cannot know a priori what our function will do. Adding one of those to our code will prevent this error of showing up.

 That said, there is another way to stop the error - by disabling the binary log when creating functions. And we can achieve this by executing the following command:

 SET @@global.log_bin_trust_function_creators := 1;

 Technically speaking, this operation isn’t the safest one out there. Nevertheless, for the purposes of this course, it is the one that will solve the potential problems regardless of the version of MySQL.

 In conclusion, remember that sometimes the Binary Log may be disabled anyway and you don’t have to take any of the above actions. In that case, we simply hope you’ve enjoyed reading this article! Thank you!

Exercise - Create a function called ‘emp_info’ that takes for parameters the first and last name of an employee, and returns the salary from the newest contract of that employee.
           Hint: In the BEGIN-END block of this program, you need to declare and use two variables – v_max_from_date that will be of the DATE type, and v_salary, that will be of the DECIMAL (10,2) type.
           Finally, select this function.

DROP function if exists f_emp_info;
DELIMITER $$
CREATE FUNCTION f_emp_info(p_first_name VARCHAR(30), p_last_name VARCHAR(30)) RETURNS DECIMAL(10,2)
DETERMINISTIC
BEGIN
	DECLARE v_max_date DATE;
	DECLARE v_sal DECIMAL(10,2);

    select MAX(from_date) INTO v_max_date from employees e join salaries s on e.emp_no=s.emp_no
    where e.first_name = p_first_name AND e.last_name = p_last_name
    group by e.emp_no;

    select ROUND(s.salary,2) INTO v_sal from employees e join salaries s on e.emp_no=s.emp_no
    where e.first_name = p_first_name AND e.last_name = p_last_name AND s.from_date=v_max_date;

    RETURN v_sal;
END$$
DELIMITER ;

select f_emp_info('Aruna', 'Journel');

Stored Routines - Conclusions
------------------------------
Technical Difference
SP - Does not return a value, but stores value in a out variable similar to global variable which is assigned a value in function.
Func - Returns a value.

SP - Called using CALL keyword;
Func - It can be invoked from a SELECT statement.

Conceptual Difference:
SP - Can have No params, single IN OUT or multiple IN OUT params
Function - Can return a single value only.

If you need to obtain more than one value as a result of a calculation, you are better off using a procedure.
If you need to return a single value, then you can use a function, you can use proc as well but it is more common to use function.

How about involving an INSERT, UPDATE or a DELETE statement in a proc or func?
In those cases, the operation performed will apply changes to the data in your database.
There will be no value, or values to be returned and displayed to the user.

SP - can be used for INSERT, UPDATE DELETE without a OUT param but not a function because function should always return a value.

SP - Called using CALL keyword;
Func - It can be invoked from a SELECT statement.
This means we can easily include a function as one of the columns inside a SELECT statement. BUT we cannot include a proc in a SELECT statement.
Eg -
SET @v_emp_no = 11300;
SELECT
    emp_no,
    first_name,
    last_name,
    F_EMP_AVG_SALARY(@v_emp_no) AS avg_sal
FROM
    employees
WHERE
    emp_no = @v_emp_no;

Once you become an advanced SQL user, and have gained a lot of practice, you will appreciate the advantages and disadvantages of both types of programs.
You will encounter many cases where you should choose between procedures and functions.

Advanced SQL Topics
--------------------
Scope = Visibility = The region of a computer program where a phenomenon, such as a variable, is considered valid.

Types of Variables in SQL -
    Local
    Session
    Global

Local variable - A variable that is visible only in the BEGIN-END block in which it is created.
    DECLARE keyword is used to create local variables only within BEGIN-END Block.

Session Variables:
------------------
Session - A series of information exchange interactions, or a dialogue, between a computer and a user.
Eg. A dialogue between the MYSQL server and a client application like MySQL Workbench.
A session begins at a certain point in time and terminated at another, later point.
A session starts after a successful connection between a client(like workbench) and a mysql server.

Session variable - is a variable that exists only for the session in which you are operating.
It is defined on a server and it lives there.
It is visible only to the connection being used.

Two points to create a sessions variable.
1. It is defined using SET keyword.
2. variable name has @ as the prefix.
Eg. SET @s_var1 = 3;
    SET @s_var2 = 4;
    SET SESSION s_var3 = 5;
    select @s_var1, @s_var2;

Global Variables: (Also called System variables)
-----------------
Global Variables apply to all connections related to a specific server.
Syntax - SET GLOBAL var_name = value;
SET @@global.var_name = value;

We cannot set any variable as global. A specific group of pre-defined variables in MySQL is suitable for this job. They are called system variables.
Eg. .max_connections; - indicates the max number of connections to a server that can be established at a certain point in time.
.max_join_size; - sets the max memory space allocated for the joins created by a certain connection.
Eg.
SET GLOBAL max_connections = 150; # OR
SET @@global.max_connections = 151;
select @@global.max_connections;

User defined vs System Variables:
---------------------------------
Variables in mysql can be characterized according to the way they have been created:
User defined - Variables that can bse set by the user manually
system - Variables that are predefined on our system - the MySQL server.

Local Variables - User defined Only.
Global Variables - System Only.
Session Variables - Both user defined and system variables can be set as session variables but there are limitations to this rule.
Not all Existing Global variables cannot be re defined as system variables like max_connections.
Some global variables can be set as Session variables - SET SESSION sql_mode='NO_ZERO_DATE';

TRIGGERS:
##########################################################
##########################################################

-- SECTION: Advanced SQL Topics

##########################################################
##########################################################



###########
-- LECTURE: MySQL Triggers


# In this lesson, we will introduce you to MySQL triggers.

# By definition, a MySQL trigger is a type of stored program, associated with a table,
# that will be activated automatically once a specific event related to the table of association occurs.

# This event must be related to one of the following three DML statements: INSERT, UPDATE, or DELETE.
# Therefore, triggers are a powerful and handy tool that professionals love to use where database consistency
# and integrity are concerned.

# Moreover, to any of these DML statements, one of two types of triggers can be assigned – a “before”, or an “after” trigger.

# In other words, a trigger is a MySQL object that can “trigger” a specific action or calculation ‘before’ or ‘after’ an INSERT,
# UPDATE, or DELETE statement has been executed. For instance, a trigger can be activated before a new record is inserted into a table,
# or after a record has been updated.

# Perfect! Let’s execute some code.

# First, in case you are just starting Workbench, select “Employees” as your default database.
USE employees;

# Then, execute a COMMIT statement, because the triggers we are about to create will make some changes to
# the state of the data in our database. At the end of the exercise, we will ROLLBACK up to the moment of this COMMIT.
COMMIT;

# We said triggers are a type of stored program. Well, one could say the syntax resembles that of stored procedures, couldn’t they?

# BEFORE INSERT
DELIMITER $$

CREATE TRIGGER before_salaries_insert
BEFORE INSERT ON salaries
FOR EACH ROW
BEGIN
	IF NEW.salary < 0 THEN
		SET NEW.salary = 0;
	END IF;
END $$

DELIMITER ;

# After stating we want to CREATE a TRIGGER and then indicating its name, we must indicate its type and the name of the table
# to which it will be applied. In this case, we devised a “before” trigger, which will be activated whenever new data is inserted
# in the “Salaries” table.

# Great!

# Then, an interesting phrase follows – “for each row”. It designates that before the trigger is activated, MySQL will perform a #
# check for a change of the state of the data on all rows. In our case, a change in the data of the “Salaries” table will be caused
# by the insertion of a new record.

# Within the BEGIN-END block, you can see a piece of code that is easier to understand if you just read it without focusing on
# the syntax.

# The body of this block acts as the core of the “before_salaries_insert” trigger. Basically, it says that if the newly inserted
# salary is of negative value, it will be set as 0.
/*
	IF NEW.salary < 0 THEN
		SET NEW.salary = 0;
	END IF;
*/

# From a programmer’s perspective, there are three things to note about these three lines of code.

# First, especially for those of you who are familiar with some programming, this is an example of a conditional. The IF statement
# starts the conditional block. Then, if the condition for negative salary is satisfied, one must use the keyword THEN before showing
# what action should follow. The operation is terminated by the END IF phrase and a semi-colon.

# The second thing to be noted here is even more interesting. That’s the use of the keyword NEW. In general, it refers to a row that
# has just been inserted or updated. In our case, after we insert a new record, “NEW dot salary” will refer to the value that will
# be inserted in the “Salary” column of the “Salaries” table.

# The third part of the syntax regards the SET keyword. As you already know, it is used whenever a value has to be assigned to a
# certain variable. Here, the variable is the newly inserted salary, and the value to be assigned is 0.

# All right! Let’s execute this query.
# BEFORE INSERT
DELIMITER $$

CREATE TRIGGER before_salaries_insert
BEFORE INSERT ON salaries
FOR EACH ROW
BEGIN
	IF NEW.salary < 0 THEN
		SET NEW.salary = 0;
	END IF;
END $$

DELIMITER ;

# Let’s check the values of the “Salaries” table for employee 10001.
SELECT
    *
FROM
    salaries
WHERE
    emp_no = '10001';

# Now, let’s insert a new entry for employee 10001, whose salary will be a negative number.
INSERT INTO salaries VALUES ('10001', -92891, '2010-06-22', '9999-01-01');

# Let’s run the same SELECT query to see whether the newly created record has a salary of 0 dollars per year.
SELECT
    *
FROM
    salaries
WHERE
    emp_no = '10001';

# You can see that the “before_salaries_insert” trigger was activated automatically. It corrected the value of minus 92,891
# we tried to insert.

# Fantastic!

# Now, let’s look at a BEFORE UPDATE trigger. The code is similar to the one of the trigger we created above, with two
# substantial differences.
# BEFORE UPDATE
DELIMITER $$

CREATE TRIGGER trig_upd_salary
BEFORE UPDATE ON salaries
FOR EACH ROW
BEGIN
	IF NEW.salary < 0 THEN
		SET NEW.salary = OLD.salary;
	END IF;
END $$

DELIMITER ;

# First, we indicated that this will be a BEFORE UPDATE trigger.
/*
BEFORE UPDATE ON salaries
*/

# Second, in the IF conditional statement, instead of setting the new value to 0, we are basically telling MySQL to keep the old value.
# Technically, this is achieved by setting the NEW value in the “Salary” column to be equal to the OLD one. This is a good example of
# when the OLD keyword needs to be used.
/*
	IF NEW.salary < 0 THEN
		SET NEW.salary = OLD.salary;
	END IF;
*/

# Create the “before_salaries_update” trigger by executing the above statement.

# Then, run the following UPDATE statement, with which we will modify the salary value of employee 10001 with another positive value.
UPDATE salaries
SET
    salary = 98765
WHERE
    emp_no = '10001'
        AND from_date = '2010-06-22';

# Execute the following SELECT statement to see that the record has been successfully updated.
SELECT
    *
FROM
    salaries
WHERE
    emp_no = '10001'
        AND from_date = '2010-06-22';

# Now, let’s run another UPDATE statement, with which we will try to modify the salary earned by 10001 with a negative value, minus 50,000.
UPDATE salaries
SET
    salary = - 50000
WHERE
    emp_no = '10001'
        AND from_date = '2010-06-22';

# Let’s run the same SELECT statement to check if the salary value was adjusted.
SELECT
    *
FROM
    salaries
WHERE
    emp_no = '10001'
        AND from_date = '2010-06-22';

# No, it wasn’t. Everything remained intact. So, we can conclude that only an update with a salary higher than zero dollars per year
# would be implemented.


# All right. For the moment, you know you have created only two triggers. But how could you prove that to someone who is seeing your
# script for the first time?
# Well, in the ‘info’ section of the “employees” database, you can find a tab related to triggers. When you click on its name,
# MySQL will show you the name, the related event, table, timing, and other characteristics regarding each trigger currently in use.

# Awesome!

# Let’s introduce you to another interesting fact about MySQL. You already know there are pre-defined system variables, but system
# functions exist too!
# System functions can also be called built-in functions.
# Often applied in practice, they provide data related to the moment of the execution of a certain query.

# For instance, SYSDATE() delivers the date and time of the moment at which you have invoked this function.
SELECT SYSDATE();

# Another frequently employed function, “Date Format”, assigns a specific format to a given date. For instance, the following query
# could extract the current date, quoting the year, the month, and the day.
SELECT DATE_FORMAT(SYSDATE(), '%y-%m-%d') as today;

# Of course, there are many other ways in which you could format a date; what we showed here was just an example.
# So, using system functions seems cool, doesn’t it?

# Wonderful! You already know how to work with the syntax that allows you to create triggers.

# As an exercise, try to understand the following query. Technically, it regards the creation of a more complex trigger.
#It is of the size that professionals often have to deal with.

DELIMITER $$

CREATE TRIGGER trig_ins_dept_mng
AFTER INSERT ON dept_manager
FOR EACH ROW
BEGIN
	DECLARE v_curr_salary int;

    SELECT
		MAX(salary)
	INTO v_curr_salary FROM
		salaries
	WHERE
		emp_no = NEW.emp_no;

	IF v_curr_salary IS NOT NULL THEN
		UPDATE salaries
		SET
			to_date = SYSDATE()
		WHERE
			emp_no = NEW.emp_no and to_date = NEW.to_date;

		INSERT INTO salaries
			VALUES (NEW.emp_no, v_curr_salary + 20000, NEW.from_date, NEW.to_date);
    END IF;
END $$

DELIMITER ;

# After you are sure you have understood how this query works, please execute it and then run the following INSERT statement.
INSERT INTO dept_manager VALUES ('111534', 'd009', date_format(sysdate(), '%y-%m-%d'), '9999-01-01');

# SELECT the record of employee number 111534 in the ‘dept_manager’ table, and then in the ‘salaries’ table to see how the output was affected.
SELECT
    *
FROM
    dept_manager
WHERE
    emp_no = 111534;

SELECT
    *
FROM
    salaries
WHERE
    emp_no = 111534;

# Conceptually, this was an ‘after’ trigger that automatically added $20,000 to the salary of the employee who was just promoted as a manager.
# Moreover, it set the start date of her new contract to be the day on which you executed the insert statement.

# Finally, to restore the data in the database to the state from the beginning of this lecture, execute the following ROLLBACK statement.
ROLLBACK;

# End.

MySQL Triggers
---------------
A type of stored program, associated with a table, that will be activated automatically once a specific event occurs.
This event must be related to the associated table and represented by one of the following three DML statements:
    - INSERT
    - UPDATE
    - DELETE
A trigger is a MySQL object that can trigger a specific action or calculation 'before' or 'After' and INSERT, UPDATE or DELETE statement has been executed.

System/Built In functions
--------------------------
Often applied in practice, they provide data about the moment of the execution of a certain query.

How to drop a trigger?
DROP TRIGGER before_salaries_update;

Exercise - Create a trigger that checks if the hire date of an employee is higher than the current date. If true, set this date to be the current date. Format the output appropriately (YY-MM-DD).
DELIMITER $$
CREATE TRIGGER before_hire_date
BEFORE INSERT ON employees
FOR EACH ROW
BEGIN
	IF NEW.hire_date >  DATE_FORMAT(SYSDATE(), '%Y-%m-%d') THEN
		SET NEW.hire_date = DATE_FORMAT(SYSDATE(), '%Y-%m-%d');
    END IF;
END $$
DELIMITER ;

INSERT INTO employees
VALUES (199029, '1992-01-01', 'Ramesh', 'Chandoo', 'M', '2022-01-01');

select * from employees where emp_no=199029;

## Output
# emp_no, birth_date, first_name, last_name, gender, hire_date
# '199029', '1992-01-01', 'Ramesh', 'Chandoo', 'M', '2021-06-21'

Indexes -
---------
Consider a library where book are kept at random, it will be difficult to find a book.
But if there is an index which indexes the books by genres and then alphabets then it will be much easier to find a book.

The index of a table functions like index of a book.
Data is taken from a column of the table and is stored in a certain order in a distinct place, called an index.
Normally the datasets will typically contain 100,000+ or even 1,000,000+ records.
The larger the db, the slower the process of finding the record or records you need.
We can use an index that will increase the speed of searches related to a table.

SYNTAX - CREATE INDEX index_name
         ON TABLE (col1, col2...)

The parentheses serves us to indicate the column names on which our search will be based. It will speed up the search and the data will be fetched in a quicker way.
These cols should be the cols of the table where the search is done frequently.

select * from employees where hire_date > '2000-01-01'; # 0.177 sec / 0.000012 sec
Create Index i_hire_date ON employees(hire_date);
select * from employees where hire_date > '2000-01-01'; # 0.0013 sec / 0.000021 sec

Composite Index - Index applied on more than one cols not just a single one.
CREATE INDEX index_name
ON TABLE (col1, col2...)

Eg. select * from employees where first_name='Aruna' and last_name='Motley'; # 0.134 sec / 0.000010 sec
    create index i_composite_emp_name ON employees(first_name, last_name);
    select * from employees where first_name='Aruna' and last_name='Motley'; # 0.0010 sec / 0.000020 sec

DB Admin should carefully pick the columns that would optimize the search.

There are other Indexes in MySQL.
We have come across many indexes previously like Primary key, unique key.
    They represent columns on which a person would typically base their search.
Eg- emp_no is employees table is Primary key, this column represents unique values an analyst could take advantage of to extract distinct values from the data table.

We can get the existing indexes details in two way -
1. Workbench -- db/table -- info -- Indexes
2. #show index from table [from db];
   show index from dept_emp from employees;
   show index from dept_manager;































Combining SQL and Tableau -
---------------------------
SQL - specifically designed for the domain of the RDBMS.
Python/R - complex mathematical computations (business, statistics, Finance)
Tableau - Used massively for Business Intelligence and Analytics, Visualizations of datesets.

Integration - We can integrate two or more programming langages and tools, with the idea of extracting a particular type of output.

Tableau - can create -graphs, charts, reports, dashboards
Tableau is - highly intuitive, easy to understand.
goal - to help users project their data by offering a huge variety of data visualization tools to choose from.

Tableau has Custom SQL option to access your db and to extract the exact query output. You can apply joins on your sql data using tableau.

SQL stored proc provide better performace when used on SQL server compared to running it from Tableau.
The Tableau in-memory engine is also suitable for similar types of calculations when only using a smaller dataset.
Stored Procs knowledge is useful when working with Tableau.

Re-organize your data in a proper format for analysis -
    - Tableau is not the best place to complete the pre-processing step.
    - Pre-processing on a db level instead, is associated with much better performance.
  Hence knowledge in SQL can help you a great deal while working with Tableau when preparing your data for analysis.

Custom Tableau option is present only in Tableau Desktop which is the paid version.
But we can work with Tableau public and MySql workbench.

How we will work?
1. Receive a business task.
2. Use SQL to execure a query retrieving a relevant dataset from the database.
3. Export the newly obtained data in a csv file to be used in Tableau.
4. Create a professional and understandable visualization in Tableau.


Questions:
Why is char faster than varchar?
